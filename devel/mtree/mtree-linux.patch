diff -ru -ruN mtree/Makefile mtree-linux/Makefile
--- mtree/Makefile	2005-03-29 13:44:17.000000000 +0200
+++ mtree-linux/Makefile	2001-08-05 20:23:56.000000000 +0200
@@ -1,17 +1,16 @@
-#	From: @(#)Makefile	8.1 (Berkeley) 6/6/93
-# $FreeBSD: src/usr.sbin/mtree/Makefile,v 1.27 2005/03/29 11:44:17 tobez Exp $
+OBJS    = mtree.o compare.o crc.o create.o md5c.o md5hl.o misc.o \
+          setmode.o spec.o stat_flags.o unvis.o verify.o vis.o
 
-.PATH: ${.CURDIR}/../../usr.bin/cksum
+CFLAGS  = -g -I. -Wall -Dlint -D__LIBC12_SOURCE__ -Dlinux -DHAVE_FCNTL_H \
+          -DHAVE_ERRNO_H -DHAVE_UNISTD_H
 
-PROG=	mtree
-MAN=	mtree.8
-SRCS=	compare.c crc.c create.c excludes.c misc.c mtree.c spec.c verify.c
-SRCS+=	specspec.c
+all: $(OBJS) mtree
 
-WARNS?=	4
+mtree:
+	gcc -o mtree $(OBJS)
 
-CFLAGS+= -DMD5 -DSHA1 -DRMD160 -DSHA256
-DPADD=	${LIBMD}
-LDADD=	-lmd
+clean:
+	@-rm -f *.o mtree
 
-.include <bsd.prog.mk>
+.c.o:
+	gcc $(CFLAGS) -c -o $@ $<
\ No newline at end of file
diff -ru -ruN mtree/compare.c mtree-linux/compare.c
--- mtree/compare.c	2005-03-29 13:44:17.000000000 +0200
+++ mtree-linux/compare.c	2001-08-06 09:36:58.000000000 +0200
@@ -1,3 +1,5 @@
+/*	$NetBSD: compare.c,v 1.22 1999/07/10 19:59:28 christos Exp $	*/
+
 /*-
  * Copyright (c) 1989, 1993
  *	The Regents of the University of California.  All rights reserved.
@@ -10,7 +12,11 @@
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
  *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
  *
@@ -27,61 +33,96 @@
  * SUCH DAMAGE.
  */
 
-#if 0
+#include <sys/cdefs.h>
 #ifndef lint
+#if 0
 static char sccsid[] = "@(#)compare.c	8.1 (Berkeley) 6/6/93";
-#endif /* not lint */
+#else
+__RCSID("$NetBSD: compare.c,v 1.22 1999/07/10 19:59:28 christos Exp $");
 #endif
-#include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/usr.sbin/mtree/compare.c,v 1.34 2005/03/29 11:44:17 tobez Exp $");
+#endif /* not lint */
 
 #include <sys/param.h>
 #include <sys/stat.h>
-#include <sys/time.h>
-
-#include <err.h>
-#include <errno.h>
+#include <sys/types.h>
 #include <fcntl.h>
 #include <fts.h>
-#ifdef MD5
+#include <errno.h>
 #include <md5.h>
-#endif
-#ifdef RMD160
-#include <ripemd.h>
-#endif
-#ifdef SHA1
-#include <sha.h>
-#endif
-#ifdef SHA256
-#include <sha256.h>
-#endif
-#include <stdint.h>
 #include <stdio.h>
 #include <time.h>
 #include <unistd.h>
-#include <vis.h>
-
 #include "mtree.h"
 #include "extern.h"
 
+extern int iflag, mflag, tflag, uflag;
+
+static char *ftype __P((u_int));
+
 #define	INDENTNAMELEN	8
-#define	LABEL \
-	if (!label++) { \
-		len = printf("%s changed\n", RP(p)); \
-		tab = "\t"; \
-	}
+#define MARK                                                                  \
+do {                                                                          \
+	len = printf("%s: ", RP(p));                                          \
+	if (len > INDENTNAMELEN) {                                            \
+		tab = "\t";                                                   \
+		(void)printf("\n");                                           \
+	} else {                                                              \
+		tab = "";                                                     \
+		(void)printf("%*s", INDENTNAMELEN - (int)len, "");            \
+	}                                                                     \
+} while (0)
+#define	LABEL if (!label++) MARK
+
+#define CHANGEFLAGS(path, oflags) \
+	if (flags != (oflags)) {                                              \
+		if (!label) {                                                 \
+			MARK;                                                 \
+			(void)printf("%sflags (\"%s\"", tab,                  \
+			    flags_to_string(p->fts_statp->st_flags, "none")); \
+		}                                                             \
+		if (chflags(path, flags)) {                                   \
+			label++;                                              \
+			(void)printf(", not modified: %s)\n",                 \
+			    strerror(errno));                                 \
+		} else                                                        \
+			(void)printf(", modified to \"%s\")\n",               \
+			     flags_to_string(flags, "none"));                 \
+	}
+
+/* SETFLAGS:
+ * given pflags, additionally set those flags specified in sflags and
+ * selected by mask (the other flags are left unchanged). oflags is
+ * passed as reference to check if chflags is necessary.
+ */
+#define SETFLAGS(path, sflags, pflags, oflags, mask)                          \
+do {                                                                          \
+	flags = ((sflags) & (mask)) | (pflags);                               \
+        CHANGEFLAGS(path, oflags);                                            \
+} while (0)
+
+/* CLEARFLAGS:
+ * given pflags, reset the flags specified in sflags and selected by mask
+ * (the other flags are left unchanged). oflags is
+ * passed as reference to check if chflags is necessary.
+ */
+#define CLEARFLAGS(path, sflags, pflags, oflags, mask)                        \
+do {                                                                          \
+	flags = (~((sflags) & (mask)) & CH_MASK) & (pflags);                  \
+        CHANGEFLAGS(path, oflags);                                            \
+} while (0)
 
 int
-compare(char *name __unused, NODE *s, FTSENT *p)
+compare(name, s, p)
+	char *name;
+	NODE *s;
+	FTSENT *p;
 {
-	struct timeval tv[2];
-	uint32_t val;
+	u_int32_t len, val, flags;
 	int fd, label;
-	off_t len;
-	char *cp;
-	const char *tab = "";
-	char *fflags;
+	char *cp, *tab;
+	char md5buf[35];
 
+	tab = NULL;
 	label = 0;
 	switch(s->type) {
 	case F_BLOCK:
@@ -111,96 +152,163 @@
 	case F_SOCK:
 		if (!S_ISSOCK(p->fts_statp->st_mode)) {
 typeerr:		LABEL;
-			(void)printf("\ttype expected %s found %s\n",
+			(void)printf("\ttype (%s, %s)\n",
 			    ftype(s->type), inotype(p->fts_statp->st_mode));
-			return (label);
 		}
 		break;
 	}
+#ifndef linux
+	if (iflag && !uflag) {
+		if (s->flags & F_FLAGS)
+		    SETFLAGS(p->fts_accpath, s->st_flags,
+			p->fts_statp->st_flags, p->fts_statp->st_flags,
+			SP_FLGS);
+		return (label);
+        }
+	if (mflag && !uflag) {
+		if (s->flags & F_FLAGS)
+		    CLEARFLAGS(p->fts_accpath, s->st_flags, 
+			p->fts_statp->st_flags, p->fts_statp->st_flags,
+			SP_FLGS);
+		return (label);
+        }
+#endif
 	/* Set the uid/gid first, then set the mode. */
 	if (s->flags & (F_UID | F_UNAME) && s->st_uid != p->fts_statp->st_uid) {
 		LABEL;
-		(void)printf("%suser expected %lu found %lu",
+		(void)printf("%suser (%lu, %lu",
 		    tab, (u_long)s->st_uid, (u_long)p->fts_statp->st_uid);
-		if (uflag)
+		if (uflag) {
 			if (chown(p->fts_accpath, s->st_uid, -1))
-				(void)printf(" not modified: %s\n",
+				(void)printf(", not modified: %s)\n",
 				    strerror(errno));
 			else
-				(void)printf(" modified\n");
-		else
-			(void)printf("\n");
+				(void)printf(", modified)\n");
+		} else
+			(void)printf(")\n");
 		tab = "\t";
 	}
 	if (s->flags & (F_GID | F_GNAME) && s->st_gid != p->fts_statp->st_gid) {
 		LABEL;
-		(void)printf("%sgid expected %lu found %lu",
+		(void)printf("%sgid (%lu, %lu",
 		    tab, (u_long)s->st_gid, (u_long)p->fts_statp->st_gid);
-		if (uflag)
+		if (uflag) {
 			if (chown(p->fts_accpath, -1, s->st_gid))
-				(void)printf(" not modified: %s\n",
+				(void)printf(", not modified: %s)\n",
 				    strerror(errno));
 			else
-				(void)printf(" modified\n");
+				(void)printf(", modified)\n");
+		}
 		else
-			(void)printf("\n");
+			(void)printf(")\n");
 		tab = "\t";
 	}
 	if (s->flags & F_MODE &&
-	    !S_ISLNK(p->fts_statp->st_mode) &&
 	    s->st_mode != (p->fts_statp->st_mode & MBITS)) {
 		LABEL;
-		(void)printf("%spermissions expected %#o found %#o",
-		    tab, s->st_mode, p->fts_statp->st_mode & MBITS);
-		if (uflag)
+		(void)printf("%spermissions (%#lo, %#lo",
+		    tab, (u_long)s->st_mode,
+		    (u_long)p->fts_statp->st_mode & MBITS);
+		if (uflag) {
 			if (chmod(p->fts_accpath, s->st_mode))
-				(void)printf(" not modified: %s\n",
+				(void)printf(", not modified: %s)\n",
 				    strerror(errno));
 			else
-				(void)printf(" modified\n");
+				(void)printf(", modified)\n");
+		}
 		else
-			(void)printf("\n");
+			(void)printf(")\n");
 		tab = "\t";
 	}
 	if (s->flags & F_NLINK && s->type != F_DIR &&
 	    s->st_nlink != p->fts_statp->st_nlink) {
 		LABEL;
-		(void)printf("%slink_count expected %u found %u\n",
-		    tab, s->st_nlink, p->fts_statp->st_nlink);
+		(void)printf("%slink count (%lu, %lu)\n",
+		    tab, (u_long)s->st_nlink, (u_long)p->fts_statp->st_nlink);
 		tab = "\t";
 	}
-	if (s->flags & F_SIZE && s->st_size != p->fts_statp->st_size &&
-		!S_ISDIR(p->fts_statp->st_mode)) {
+	if (s->flags & F_SIZE && s->st_size != p->fts_statp->st_size) {
 		LABEL;
-		(void)printf("%ssize expected %jd found %jd\n", tab,
-		    (intmax_t)s->st_size, (intmax_t)p->fts_statp->st_size);
+		(void)printf("%ssize (%qd, %qd)\n",
+		    tab, (long long)s->st_size,
+		    (long long)p->fts_statp->st_size);
 		tab = "\t";
 	}
 	/*
 	 * XXX
-	 * Catches nano-second differences, but doesn't display them.
+	 * Since utimes(2) only takes a timeval, there's no point in
+	 * comparing the low bits of the timespec nanosecond field.  This
+	 * will only result in mismatches that we can never fix.
+	 *
+	 * Doesn't display microsecond differences.
 	 */
-	if ((s->flags & F_TIME) &&
-	     ((s->st_mtimespec.tv_sec != p->fts_statp->st_mtimespec.tv_sec) ||
-	     (s->st_mtimespec.tv_nsec != p->fts_statp->st_mtimespec.tv_nsec))) {
-		LABEL;
-		(void)printf("%smodification time expected %.24s ",
-		    tab, ctime(&s->st_mtimespec.tv_sec));
-		(void)printf("found %.24s",
-		    ctime(&p->fts_statp->st_mtimespec.tv_sec));
+	if (s->flags & F_TIME) {
+		struct timeval tv[2];
+		struct stat *ps = p->fts_statp;
+		time_t smtime = s->st_mtimespec.tv_sec;
+
+#ifdef BSD4_4
+		time_t pmtime = ps->st_mtimespec.tv_sec;
+
+		TIMESPEC_TO_TIMEVAL(&tv[1], &ps->st_mtimespec);
+#else
+		time_t pmtime = (time_t)ps->st_mtime;
+
+		tv[1].tv_sec = ps->st_mtime;
+		tv[1].tv_usec = 0;
+#endif
+		TIMESPEC_TO_TIMEVAL(&tv[0], &s->st_mtimespec);
+
+		if (tv[0].tv_sec != tv[1].tv_sec ||
+		    tv[0].tv_usec != tv[1].tv_usec) {
+			LABEL;
+			(void)printf("%smodification time (%.24s, ",
+			    tab, ctime(&smtime));
+			(void)printf("%.24s", ctime(&pmtime));
+			if (tflag) {
+				tv[1] = tv[0];
+				if (utimes(p->fts_accpath, tv))
+					(void)printf(", not modified: %s)\n",
+					    strerror(errno));
+				else
+					(void)printf(", modified)\n");
+			} else
+				(void)printf(")\n");
+			tab = "\t";
+		}
+	}
+	/*
+	 * XXX
+	 * since chflags(2) will reset file times, the utimes() above
+	 * may have been useless!  oh well, we'd rather have correct
+	 * flags, rather than times?
+	 */
+#ifndef linux
+        if ((s->flags & F_FLAGS) && ((s->st_flags != p->fts_statp->st_flags)
+	    || mflag || iflag)) {
+		if (s->st_flags != p->fts_statp->st_flags) {
+			LABEL;
+			(void)printf("%sflags (\"%s\" is not ", tab,
+			    flags_to_string(s->st_flags, "none"));
+			(void)printf("\"%s\"",
+			    flags_to_string(p->fts_statp->st_flags, "none"));
+		}
 		if (uflag) {
-			tv[0].tv_sec = s->st_mtimespec.tv_sec;
-			tv[0].tv_usec = s->st_mtimespec.tv_nsec / 1000;
-			tv[1] = tv[0];
-			if (utimes(p->fts_accpath, tv))
-				(void)printf(" not modified: %s\n",
-				    strerror(errno));
+			if (iflag)
+				SETFLAGS(p->fts_accpath, s->st_flags,
+				    0, p->fts_statp->st_flags, CH_MASK);
+			else if (mflag)
+				CLEARFLAGS(p->fts_accpath, s->st_flags,
+				    0, p->fts_statp->st_flags, SP_FLGS);
 			else
-				(void)printf(" modified\n");
+				SETFLAGS(p->fts_accpath, s->st_flags,
+			     	    0, p->fts_statp->st_flags,
+				    (~SP_FLGS & CH_MASK));
 		} else
-			(void)printf("\n");
+			(void)printf(")\n");
 		tab = "\t";
 	}
+#endif
 	if (s->flags & F_CKSUM) {
 		if ((fd = open(p->fts_accpath, O_RDONLY, 0)) < 0) {
 			LABEL;
@@ -217,116 +325,38 @@
 			(void)close(fd);
 			if (s->cksum != val) {
 				LABEL;
-				(void)printf("%scksum expected %lu found %lu\n",
+				(void)printf("%scksum (%lu, %lu)\n", 
 				    tab, s->cksum, (unsigned long)val);
-				tab = "\t";
 			}
-		}
-	}
-	if ((s->flags & F_FLAGS) && s->st_flags != p->fts_statp->st_flags) {
-		LABEL;
-		fflags = flags_to_string(s->st_flags);
-		(void)printf("%sflags expected \"%s\"", tab, fflags);
-		free(fflags);
-
-		fflags = flags_to_string(p->fts_statp->st_flags);
-		(void)printf(" found \"%s\"", fflags);
-		free(fflags);
-
-		if (uflag)
-			if (chflags(p->fts_accpath, s->st_flags))
-				(void)printf(" not modified: %s\n",
-				    strerror(errno));
-			else
-				(void)printf(" modified\n");
-		else
-			(void)printf("\n");
-		tab = "\t";
-	}
-#ifdef MD5
-	if (s->flags & F_MD5) {
-		char *new_digest, buf[33];
-
-		new_digest = MD5File(p->fts_accpath, buf);
-		if (!new_digest) {
-			LABEL;
-			printf("%sMD5: %s: %s\n", tab, p->fts_accpath,
-			       strerror(errno));
-			tab = "\t";
-		} else if (strcmp(new_digest, s->md5digest)) {
-			LABEL;
-			printf("%sMD5 expected %s found %s\n", tab, s->md5digest,
-			       new_digest);
 			tab = "\t";
 		}
 	}
-#endif /* MD5 */
-#ifdef SHA1
-	if (s->flags & F_SHA1) {
-		char *new_digest, buf[41];
-
-		new_digest = SHA1_File(p->fts_accpath, buf);
-		if (!new_digest) {
-			LABEL;
-			printf("%sSHA-1: %s: %s\n", tab, p->fts_accpath,
-			       strerror(errno));
-			tab = "\t";
-		} else if (strcmp(new_digest, s->sha1digest)) {
-			LABEL;
-			printf("%sSHA-1 expected %s found %s\n",
-			       tab, s->sha1digest, new_digest);
-			tab = "\t";
-		}
-	}
-#endif /* SHA1 */
-#ifdef RMD160
-	if (s->flags & F_RMD160) {
-		char *new_digest, buf[41];
-
-		new_digest = RIPEMD160_File(p->fts_accpath, buf);
-		if (!new_digest) {
-			LABEL;
-			printf("%sRIPEMD160: %s: %s\n", tab,
-			       p->fts_accpath, strerror(errno));
-			tab = "\t";
-		} else if (strcmp(new_digest, s->rmd160digest)) {
-			LABEL;
-			printf("%sRIPEMD160 expected %s found %s\n",
-			       tab, s->rmd160digest, new_digest);
-			tab = "\t";
-		}
-	}
-#endif /* RMD160 */
-#ifdef SHA256
-	if (s->flags & F_SHA256) {
-		char *new_digest, buf[65];
-
-		new_digest = SHA256_File(p->fts_accpath, buf);
-		if (!new_digest) {
+	if (s->flags & F_MD5) {
+		if (MD5File(p->fts_accpath, md5buf) == NULL) {
 			LABEL;
-			printf("%sSHA-256: %s: %s\n", tab, p->fts_accpath,
-			       strerror(errno));
+			(void)printf("%smd5: %s: %s\n",
+			    tab, p->fts_accpath, strerror(errno));
 			tab = "\t";
-		} else if (strcmp(new_digest, s->sha256digest)) {
-			LABEL;
-			printf("%sSHA-256 expected %s found %s\n",
-			       tab, s->sha256digest, new_digest);
+		} else {
+			if (strcmp(s->md5sum, md5buf)) {
+				LABEL;
+				(void)printf("%smd5 (0x%s, 0x%s)\n",
+				    tab, s->md5sum, md5buf);
+			}
 			tab = "\t";
 		}
 	}
-#endif /* SHA256 */
 
-	if (s->flags & F_SLINK &&
-	    strcmp(cp = rlink(p->fts_accpath), s->slink)) {
+	if (s->flags & F_SLINK && strcmp(cp = rlink(name), s->slink)) {
 		LABEL;
-		(void)printf("%slink_ref expected %s found %s\n",
-		      tab, s->slink, cp);
+		(void)printf("%slink ref (%s, %s)\n", tab, cp, s->slink);
 	}
 	return (label);
 }
 
-const char *
-inotype(u_int type)
+char *
+inotype(type)
+	u_int type;
 {
 	switch(type & S_IFMT) {
 	case S_IFBLK:
@@ -349,8 +379,9 @@
 	/* NOTREACHED */
 }
 
-const char *
-ftype(u_int type)
+static char *
+ftype(type)
+	u_int type;
 {
 	switch(type) {
 	case F_BLOCK:
@@ -374,15 +405,14 @@
 }
 
 char *
-rlink(char *name)
+rlink(name)
+	char *name;
 {
-	static char lbuf[MAXPATHLEN * 4];
+	static char lbuf[MAXPATHLEN];
 	int len;
-	char tbuf[MAXPATHLEN];
 
-	if ((len = readlink(name, tbuf, sizeof(tbuf) - 1)) == -1)
-		err(1, "line %d: %s", lineno, name);
-	tbuf[len] = '\0';
-	strvis(lbuf, tbuf, VIS_WHITE | VIS_OCTAL);
+	if ((len = readlink(name, lbuf, sizeof(lbuf))) == -1)
+		mtree_err("%s: %s", name, strerror(errno));
+	lbuf[len] = '\0';
 	return (lbuf);
 }
diff -ru -ruN mtree/compare.c.orig mtree-linux/compare.c.orig
--- mtree/compare.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ mtree-linux/compare.c.orig	1999-07-10 21:59:28.000000000 +0200
@@ -0,0 +1,414 @@
+/*	$NetBSD: compare.c,v 1.22 1999/07/10 19:59:28 christos Exp $	*/
+
+/*-
+ * Copyright (c) 1989, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+#ifndef lint
+#if 0
+static char sccsid[] = "@(#)compare.c	8.1 (Berkeley) 6/6/93";
+#else
+__RCSID("$NetBSD: compare.c,v 1.22 1999/07/10 19:59:28 christos Exp $");
+#endif
+#endif /* not lint */
+
+#include <sys/param.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <fcntl.h>
+#include <fts.h>
+#include <errno.h>
+#include <md5.h>
+#include <stdio.h>
+#include <time.h>
+#include <unistd.h>
+#include "mtree.h"
+#include "extern.h"
+
+extern int iflag, mflag, tflag, uflag;
+
+static char *ftype __P((u_int));
+
+#define	INDENTNAMELEN	8
+#define MARK                                                                  \
+do {                                                                          \
+	len = printf("%s: ", RP(p));                                          \
+	if (len > INDENTNAMELEN) {                                            \
+		tab = "\t";                                                   \
+		(void)printf("\n");                                           \
+	} else {                                                              \
+		tab = "";                                                     \
+		(void)printf("%*s", INDENTNAMELEN - (int)len, "");            \
+	}                                                                     \
+} while (0)
+#define	LABEL if (!label++) MARK
+
+#define CHANGEFLAGS(path, oflags) \
+	if (flags != (oflags)) {                                              \
+		if (!label) {                                                 \
+			MARK;                                                 \
+			(void)printf("%sflags (\"%s\"", tab,                  \
+			    flags_to_string(p->fts_statp->st_flags, "none")); \
+		}                                                             \
+		if (chflags(path, flags)) {                                   \
+			label++;                                              \
+			(void)printf(", not modified: %s)\n",                 \
+			    strerror(errno));                                 \
+		} else                                                        \
+			(void)printf(", modified to \"%s\")\n",               \
+			     flags_to_string(flags, "none"));                 \
+	}
+
+/* SETFLAGS:
+ * given pflags, additionally set those flags specified in sflags and
+ * selected by mask (the other flags are left unchanged). oflags is
+ * passed as reference to check if chflags is necessary.
+ */
+#define SETFLAGS(path, sflags, pflags, oflags, mask)                          \
+do {                                                                          \
+	flags = ((sflags) & (mask)) | (pflags);                               \
+        CHANGEFLAGS(path, oflags);                                            \
+} while (0)
+
+/* CLEARFLAGS:
+ * given pflags, reset the flags specified in sflags and selected by mask
+ * (the other flags are left unchanged). oflags is
+ * passed as reference to check if chflags is necessary.
+ */
+#define CLEARFLAGS(path, sflags, pflags, oflags, mask)                        \
+do {                                                                          \
+	flags = (~((sflags) & (mask)) & CH_MASK) & (pflags);                  \
+        CHANGEFLAGS(path, oflags);                                            \
+} while (0)
+
+int
+compare(name, s, p)
+	char *name;
+	NODE *s;
+	FTSENT *p;
+{
+	u_int32_t len, val, flags;
+	int fd, label;
+	char *cp, *tab;
+	char md5buf[35];
+
+	tab = NULL;
+	label = 0;
+	switch(s->type) {
+	case F_BLOCK:
+		if (!S_ISBLK(p->fts_statp->st_mode))
+			goto typeerr;
+		break;
+	case F_CHAR:
+		if (!S_ISCHR(p->fts_statp->st_mode))
+			goto typeerr;
+		break;
+	case F_DIR:
+		if (!S_ISDIR(p->fts_statp->st_mode))
+			goto typeerr;
+		break;
+	case F_FIFO:
+		if (!S_ISFIFO(p->fts_statp->st_mode))
+			goto typeerr;
+		break;
+	case F_FILE:
+		if (!S_ISREG(p->fts_statp->st_mode))
+			goto typeerr;
+		break;
+	case F_LINK:
+		if (!S_ISLNK(p->fts_statp->st_mode))
+			goto typeerr;
+		break;
+	case F_SOCK:
+		if (!S_ISSOCK(p->fts_statp->st_mode)) {
+typeerr:		LABEL;
+			(void)printf("\ttype (%s, %s)\n",
+			    ftype(s->type), inotype(p->fts_statp->st_mode));
+		}
+		break;
+	}
+	if (iflag && !uflag) {
+		if (s->flags & F_FLAGS)
+		    SETFLAGS(p->fts_accpath, s->st_flags,
+			p->fts_statp->st_flags, p->fts_statp->st_flags,
+			SP_FLGS);
+		return (label);
+        }
+	if (mflag && !uflag) {
+		if (s->flags & F_FLAGS)
+		    CLEARFLAGS(p->fts_accpath, s->st_flags, 
+			p->fts_statp->st_flags, p->fts_statp->st_flags,
+			SP_FLGS);
+		return (label);
+        }
+	/* Set the uid/gid first, then set the mode. */
+	if (s->flags & (F_UID | F_UNAME) && s->st_uid != p->fts_statp->st_uid) {
+		LABEL;
+		(void)printf("%suser (%lu, %lu",
+		    tab, (u_long)s->st_uid, (u_long)p->fts_statp->st_uid);
+		if (uflag) {
+			if (chown(p->fts_accpath, s->st_uid, -1))
+				(void)printf(", not modified: %s)\n",
+				    strerror(errno));
+			else
+				(void)printf(", modified)\n");
+		} else
+			(void)printf(")\n");
+		tab = "\t";
+	}
+	if (s->flags & (F_GID | F_GNAME) && s->st_gid != p->fts_statp->st_gid) {
+		LABEL;
+		(void)printf("%sgid (%lu, %lu",
+		    tab, (u_long)s->st_gid, (u_long)p->fts_statp->st_gid);
+		if (uflag) {
+			if (chown(p->fts_accpath, -1, s->st_gid))
+				(void)printf(", not modified: %s)\n",
+				    strerror(errno));
+			else
+				(void)printf(", modified)\n");
+		}
+		else
+			(void)printf(")\n");
+		tab = "\t";
+	}
+	if (s->flags & F_MODE &&
+	    s->st_mode != (p->fts_statp->st_mode & MBITS)) {
+		LABEL;
+		(void)printf("%spermissions (%#lo, %#lo",
+		    tab, (u_long)s->st_mode,
+		    (u_long)p->fts_statp->st_mode & MBITS);
+		if (uflag) {
+			if (chmod(p->fts_accpath, s->st_mode))
+				(void)printf(", not modified: %s)\n",
+				    strerror(errno));
+			else
+				(void)printf(", modified)\n");
+		}
+		else
+			(void)printf(")\n");
+		tab = "\t";
+	}
+	if (s->flags & F_NLINK && s->type != F_DIR &&
+	    s->st_nlink != p->fts_statp->st_nlink) {
+		LABEL;
+		(void)printf("%slink count (%lu, %lu)\n",
+		    tab, (u_long)s->st_nlink, (u_long)p->fts_statp->st_nlink);
+		tab = "\t";
+	}
+	if (s->flags & F_SIZE && s->st_size != p->fts_statp->st_size) {
+		LABEL;
+		(void)printf("%ssize (%qd, %qd)\n",
+		    tab, (long long)s->st_size,
+		    (long long)p->fts_statp->st_size);
+		tab = "\t";
+	}
+	/*
+	 * XXX
+	 * Since utimes(2) only takes a timeval, there's no point in
+	 * comparing the low bits of the timespec nanosecond field.  This
+	 * will only result in mismatches that we can never fix.
+	 *
+	 * Doesn't display microsecond differences.
+	 */
+	if (s->flags & F_TIME) {
+		struct timeval tv[2];
+		struct stat *ps = p->fts_statp;
+		time_t smtime = s->st_mtimespec.tv_sec;
+
+#ifdef BSD4_4
+		time_t pmtime = ps->st_mtimespec.tv_sec;
+
+		TIMESPEC_TO_TIMEVAL(&tv[1], &ps->st_mtimespec);
+#else
+		time_t pmtime = (time_t)ps->st_mtime;
+
+		tv[1].tv_sec = ps->st_mtime;
+		tv[1].tv_usec = 0;
+#endif
+		TIMESPEC_TO_TIMEVAL(&tv[0], &s->st_mtimespec);
+
+		if (tv[0].tv_sec != tv[1].tv_sec ||
+		    tv[0].tv_usec != tv[1].tv_usec) {
+			LABEL;
+			(void)printf("%smodification time (%.24s, ",
+			    tab, ctime(&smtime));
+			(void)printf("%.24s", ctime(&pmtime));
+			if (tflag) {
+				tv[1] = tv[0];
+				if (utimes(p->fts_accpath, tv))
+					(void)printf(", not modified: %s)\n",
+					    strerror(errno));
+				else
+					(void)printf(", modified)\n");
+			} else
+				(void)printf(")\n");
+			tab = "\t";
+		}
+	}
+	/*
+	 * XXX
+	 * since chflags(2) will reset file times, the utimes() above
+	 * may have been useless!  oh well, we'd rather have correct
+	 * flags, rather than times?
+	 */
+        if ((s->flags & F_FLAGS) && ((s->st_flags != p->fts_statp->st_flags)
+	    || mflag || iflag)) {
+		if (s->st_flags != p->fts_statp->st_flags) {
+			LABEL;
+			(void)printf("%sflags (\"%s\" is not ", tab,
+			    flags_to_string(s->st_flags, "none"));
+			(void)printf("\"%s\"",
+			    flags_to_string(p->fts_statp->st_flags, "none"));
+		}
+		if (uflag) {
+			if (iflag)
+				SETFLAGS(p->fts_accpath, s->st_flags,
+				    0, p->fts_statp->st_flags, CH_MASK);
+			else if (mflag)
+				CLEARFLAGS(p->fts_accpath, s->st_flags,
+				    0, p->fts_statp->st_flags, SP_FLGS);
+			else
+				SETFLAGS(p->fts_accpath, s->st_flags,
+			     	    0, p->fts_statp->st_flags,
+				    (~SP_FLGS & CH_MASK));
+		} else
+			(void)printf(")\n");
+		tab = "\t";
+	}
+	if (s->flags & F_CKSUM) {
+		if ((fd = open(p->fts_accpath, O_RDONLY, 0)) < 0) {
+			LABEL;
+			(void)printf("%scksum: %s: %s\n",
+			    tab, p->fts_accpath, strerror(errno));
+			tab = "\t";
+		} else if (crc(fd, &val, &len)) {
+			(void)close(fd);
+			LABEL;
+			(void)printf("%scksum: %s: %s\n",
+			    tab, p->fts_accpath, strerror(errno));
+			tab = "\t";
+		} else {
+			(void)close(fd);
+			if (s->cksum != val) {
+				LABEL;
+				(void)printf("%scksum (%lu, %lu)\n", 
+				    tab, s->cksum, (unsigned long)val);
+			}
+			tab = "\t";
+		}
+	}
+	if (s->flags & F_MD5) {
+		if (MD5File(p->fts_accpath, md5buf) == NULL) {
+			LABEL;
+			(void)printf("%smd5: %s: %s\n",
+			    tab, p->fts_accpath, strerror(errno));
+			tab = "\t";
+		} else {
+			if (strcmp(s->md5sum, md5buf)) {
+				LABEL;
+				(void)printf("%smd5 (0x%s, 0x%s)\n",
+				    tab, s->md5sum, md5buf);
+			}
+			tab = "\t";
+		}
+	}
+
+	if (s->flags & F_SLINK && strcmp(cp = rlink(name), s->slink)) {
+		LABEL;
+		(void)printf("%slink ref (%s, %s)\n", tab, cp, s->slink);
+	}
+	return (label);
+}
+
+char *
+inotype(type)
+	u_int type;
+{
+	switch(type & S_IFMT) {
+	case S_IFBLK:
+		return ("block");
+	case S_IFCHR:
+		return ("char");
+	case S_IFDIR:
+		return ("dir");
+	case S_IFIFO:
+		return ("fifo");
+	case S_IFREG:
+		return ("file");
+	case S_IFLNK:
+		return ("link");
+	case S_IFSOCK:
+		return ("socket");
+	default:
+		return ("unknown");
+	}
+	/* NOTREACHED */
+}
+
+static char *
+ftype(type)
+	u_int type;
+{
+	switch(type) {
+	case F_BLOCK:
+		return ("block");
+	case F_CHAR:
+		return ("char");
+	case F_DIR:
+		return ("dir");
+	case F_FIFO:
+		return ("fifo");
+	case F_FILE:
+		return ("file");
+	case F_LINK:
+		return ("link");
+	case F_SOCK:
+		return ("socket");
+	default:
+		return ("unknown");
+	}
+	/* NOTREACHED */
+}
+
+char *
+rlink(name)
+	char *name;
+{
+	static char lbuf[MAXPATHLEN];
+	int len;
+
+	if ((len = readlink(name, lbuf, sizeof(lbuf))) == -1)
+		mtree_err("%s: %s", name, strerror(errno));
+	lbuf[len] = '\0';
+	return (lbuf);
+}
diff -ru -ruN mtree/crc.c mtree-linux/crc.c
--- mtree/crc.c	1970-01-01 01:00:00.000000000 +0100
+++ mtree-linux/crc.c	2001-08-05 13:57:38.000000000 +0200
@@ -0,0 +1,149 @@
+/*	$NetBSD: crc.c,v 1.8 1997/10/17 11:37:03 lukem Exp $	*/
+
+/*-
+ * Copyright (c) 1991, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * James W. Williams of NASA Goddard Space Flight Center.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+#ifndef lint
+#if 0
+static char sccsid[] = "@(#)crc.c	8.1 (Berkeley) 6/17/93";
+#else
+__RCSID("$NetBSD: crc.c,v 1.8 1997/10/17 11:37:03 lukem Exp $");
+#endif
+#endif /* not lint */
+
+#include <sys/types.h>
+#include <unistd.h>
+
+/*#include "extern.h"*/
+
+static const u_int32_t crctab[] = {
+	0x0,
+	0x04c11db7, 0x09823b6e, 0x0d4326d9, 0x130476dc, 0x17c56b6b,
+	0x1a864db2, 0x1e475005, 0x2608edb8, 0x22c9f00f, 0x2f8ad6d6,
+	0x2b4bcb61, 0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,
+	0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9, 0x5f15adac,
+	0x5bd4b01b, 0x569796c2, 0x52568b75, 0x6a1936c8, 0x6ed82b7f,
+	0x639b0da6, 0x675a1011, 0x791d4014, 0x7ddc5da3, 0x709f7b7a,
+	0x745e66cd, 0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,
+	0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5, 0xbe2b5b58,
+	0xbaea46ef, 0xb7a96036, 0xb3687d81, 0xad2f2d84, 0xa9ee3033,
+	0xa4ad16ea, 0xa06c0b5d, 0xd4326d90, 0xd0f37027, 0xddb056fe,
+	0xd9714b49, 0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,
+	0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1, 0xe13ef6f4,
+	0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d, 0x34867077, 0x30476dc0,
+	0x3d044b19, 0x39c556ae, 0x278206ab, 0x23431b1c, 0x2e003dc5,
+	0x2ac12072, 0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16,
+	0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca, 0x7897ab07,
+	0x7c56b6b0, 0x71159069, 0x75d48dde, 0x6b93dddb, 0x6f52c06c,
+	0x6211e6b5, 0x66d0fb02, 0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1,
+	0x53dc6066, 0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
+	0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e, 0xbfa1b04b,
+	0xbb60adfc, 0xb6238b25, 0xb2e29692, 0x8aad2b2f, 0x8e6c3698,
+	0x832f1041, 0x87ee0df6, 0x99a95df3, 0x9d684044, 0x902b669d,
+	0x94ea7b2a, 0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e,
+	0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2, 0xc6bcf05f,
+	0xc27dede8, 0xcf3ecb31, 0xcbffd686, 0xd5b88683, 0xd1799b34,
+	0xdc3abded, 0xd8fba05a, 0x690ce0ee, 0x6dcdfd59, 0x608edb80,
+	0x644fc637, 0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,
+	0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f, 0x5c007b8a,
+	0x58c1663d, 0x558240e4, 0x51435d53, 0x251d3b9e, 0x21dc2629,
+	0x2c9f00f0, 0x285e1d47, 0x36194d42, 0x32d850f5, 0x3f9b762c,
+	0x3b5a6b9b, 0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,
+	0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623, 0xf12f560e,
+	0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7, 0xe22b20d2, 0xe6ea3d65,
+	0xeba91bbc, 0xef68060b, 0xd727bbb6, 0xd3e6a601, 0xdea580d8,
+	0xda649d6f, 0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,
+	0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7, 0xae3afba2,
+	0xaafbe615, 0xa7b8c0cc, 0xa379dd7b, 0x9b3660c6, 0x9ff77d71,
+	0x92b45ba8, 0x9675461f, 0x8832161a, 0x8cf30bad, 0x81b02d74,
+	0x857130c3, 0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640,
+	0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c, 0x7b827d21,
+	0x7f436096, 0x7200464f, 0x76c15bf8, 0x68860bfd, 0x6c47164a,
+	0x61043093, 0x65c52d24, 0x119b4be9, 0x155a565e, 0x18197087,
+	0x1cd86d30, 0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,
+	0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088, 0x2497d08d,
+	0x2056cd3a, 0x2d15ebe3, 0x29d4f654, 0xc5a92679, 0xc1683bce,
+	0xcc2b1d17, 0xc8ea00a0, 0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb,
+	0xdbee767c, 0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18,
+	0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4, 0x89b8fd09,
+	0x8d79e0be, 0x803ac667, 0x84fbdbd0, 0x9abc8bd5, 0x9e7d9662,
+	0x933eb0bb, 0x97ffad0c, 0xafb010b1, 0xab710d06, 0xa6322bdf,
+	0xa2f33668, 0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4
+};
+
+/*
+ * Compute a POSIX 1003.2 checksum.  This routine has been broken out so that
+ * other programs can use it.  It takes a file descriptor to read from and
+ * locations to store the crc and the number of bytes read.  It returns 0 on
+ * success and 1 on failure.  Errno is set on failure.
+ */
+u_int32_t crc_total = ~0;		/* The crc over a number of files. */
+
+int
+crc(fd, cval, clen)
+	register int fd;
+	u_int32_t *cval, *clen;
+{
+	register u_char *p;
+	register int nr;
+	register u_int32_t crc, len;
+	u_char buf[16 * 1024];
+
+#define	COMPUTE(var, ch)	(var) = (var) << 8 ^ crctab[(var) >> 24 ^ (ch)]
+
+	crc = len = 0;
+	crc_total = ~crc_total;
+	while ((nr = read(fd, buf, sizeof(buf))) > 0)
+		for (len += nr, p = buf; nr--; ++p) {
+			COMPUTE(crc, *p);
+			COMPUTE(crc_total, *p);
+		}
+	if (nr < 0)
+		return (1);
+
+	*clen = len;
+
+	/* Include the length of the file. */
+	for (; len != 0; len >>= 8) {
+		COMPUTE(crc, len & 0xff);
+		COMPUTE(crc_total, len & 0xff);
+	}
+
+	*cval = ~crc;
+	crc_total = ~crc_total;
+	return (0);
+}
diff -ru -ruN mtree/crc.c.orig mtree-linux/crc.c.orig
--- mtree/crc.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ mtree-linux/crc.c.orig	1997-10-17 13:37:03.000000000 +0200
@@ -0,0 +1,149 @@
+/*	$NetBSD: crc.c,v 1.8 1997/10/17 11:37:03 lukem Exp $	*/
+
+/*-
+ * Copyright (c) 1991, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * James W. Williams of NASA Goddard Space Flight Center.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+#ifndef lint
+#if 0
+static char sccsid[] = "@(#)crc.c	8.1 (Berkeley) 6/17/93";
+#else
+__RCSID("$NetBSD: crc.c,v 1.8 1997/10/17 11:37:03 lukem Exp $");
+#endif
+#endif /* not lint */
+
+#include <sys/types.h>
+#include <unistd.h>
+
+#include "extern.h"
+
+static const u_int32_t crctab[] = {
+	0x0,
+	0x04c11db7, 0x09823b6e, 0x0d4326d9, 0x130476dc, 0x17c56b6b,
+	0x1a864db2, 0x1e475005, 0x2608edb8, 0x22c9f00f, 0x2f8ad6d6,
+	0x2b4bcb61, 0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,
+	0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9, 0x5f15adac,
+	0x5bd4b01b, 0x569796c2, 0x52568b75, 0x6a1936c8, 0x6ed82b7f,
+	0x639b0da6, 0x675a1011, 0x791d4014, 0x7ddc5da3, 0x709f7b7a,
+	0x745e66cd, 0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,
+	0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5, 0xbe2b5b58,
+	0xbaea46ef, 0xb7a96036, 0xb3687d81, 0xad2f2d84, 0xa9ee3033,
+	0xa4ad16ea, 0xa06c0b5d, 0xd4326d90, 0xd0f37027, 0xddb056fe,
+	0xd9714b49, 0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,
+	0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1, 0xe13ef6f4,
+	0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d, 0x34867077, 0x30476dc0,
+	0x3d044b19, 0x39c556ae, 0x278206ab, 0x23431b1c, 0x2e003dc5,
+	0x2ac12072, 0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16,
+	0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca, 0x7897ab07,
+	0x7c56b6b0, 0x71159069, 0x75d48dde, 0x6b93dddb, 0x6f52c06c,
+	0x6211e6b5, 0x66d0fb02, 0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1,
+	0x53dc6066, 0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
+	0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e, 0xbfa1b04b,
+	0xbb60adfc, 0xb6238b25, 0xb2e29692, 0x8aad2b2f, 0x8e6c3698,
+	0x832f1041, 0x87ee0df6, 0x99a95df3, 0x9d684044, 0x902b669d,
+	0x94ea7b2a, 0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e,
+	0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2, 0xc6bcf05f,
+	0xc27dede8, 0xcf3ecb31, 0xcbffd686, 0xd5b88683, 0xd1799b34,
+	0xdc3abded, 0xd8fba05a, 0x690ce0ee, 0x6dcdfd59, 0x608edb80,
+	0x644fc637, 0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,
+	0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f, 0x5c007b8a,
+	0x58c1663d, 0x558240e4, 0x51435d53, 0x251d3b9e, 0x21dc2629,
+	0x2c9f00f0, 0x285e1d47, 0x36194d42, 0x32d850f5, 0x3f9b762c,
+	0x3b5a6b9b, 0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,
+	0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623, 0xf12f560e,
+	0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7, 0xe22b20d2, 0xe6ea3d65,
+	0xeba91bbc, 0xef68060b, 0xd727bbb6, 0xd3e6a601, 0xdea580d8,
+	0xda649d6f, 0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,
+	0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7, 0xae3afba2,
+	0xaafbe615, 0xa7b8c0cc, 0xa379dd7b, 0x9b3660c6, 0x9ff77d71,
+	0x92b45ba8, 0x9675461f, 0x8832161a, 0x8cf30bad, 0x81b02d74,
+	0x857130c3, 0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640,
+	0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c, 0x7b827d21,
+	0x7f436096, 0x7200464f, 0x76c15bf8, 0x68860bfd, 0x6c47164a,
+	0x61043093, 0x65c52d24, 0x119b4be9, 0x155a565e, 0x18197087,
+	0x1cd86d30, 0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,
+	0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088, 0x2497d08d,
+	0x2056cd3a, 0x2d15ebe3, 0x29d4f654, 0xc5a92679, 0xc1683bce,
+	0xcc2b1d17, 0xc8ea00a0, 0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb,
+	0xdbee767c, 0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18,
+	0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4, 0x89b8fd09,
+	0x8d79e0be, 0x803ac667, 0x84fbdbd0, 0x9abc8bd5, 0x9e7d9662,
+	0x933eb0bb, 0x97ffad0c, 0xafb010b1, 0xab710d06, 0xa6322bdf,
+	0xa2f33668, 0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4
+};
+
+/*
+ * Compute a POSIX 1003.2 checksum.  This routine has been broken out so that
+ * other programs can use it.  It takes a file descriptor to read from and
+ * locations to store the crc and the number of bytes read.  It returns 0 on
+ * success and 1 on failure.  Errno is set on failure.
+ */
+u_int32_t crc_total = ~0;		/* The crc over a number of files. */
+
+int
+crc(fd, cval, clen)
+	register int fd;
+	u_int32_t *cval, *clen;
+{
+	register u_char *p;
+	register int nr;
+	register u_int32_t crc, len;
+	u_char buf[16 * 1024];
+
+#define	COMPUTE(var, ch)	(var) = (var) << 8 ^ crctab[(var) >> 24 ^ (ch)]
+
+	crc = len = 0;
+	crc_total = ~crc_total;
+	while ((nr = read(fd, buf, sizeof(buf))) > 0)
+		for (len += nr, p = buf; nr--; ++p) {
+			COMPUTE(crc, *p);
+			COMPUTE(crc_total, *p);
+		}
+	if (nr < 0)
+		return (1);
+
+	*clen = len;
+
+	/* Include the length of the file. */
+	for (; len != 0; len >>= 8) {
+		COMPUTE(crc, len & 0xff);
+		COMPUTE(crc_total, len & 0xff);
+	}
+
+	*cval = ~crc;
+	crc_total = ~crc_total;
+	return (0);
+}
diff -ru -ruN mtree/create.c mtree-linux/create.c
--- mtree/create.c	2005-03-29 13:44:17.000000000 +0200
+++ mtree-linux/create.c	2001-08-06 09:46:20.000000000 +0200
@@ -1,3 +1,5 @@
+/*	$NetBSD: create.c,v 1.25.4.1 2000/10/17 19:50:25 tv Exp $	*/
+
 /*-
  * Copyright (c) 1989, 1993
  *	The Regents of the University of California.  All rights reserved.
@@ -10,7 +12,11 @@
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
  *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
  *
@@ -27,37 +33,26 @@
  * SUCH DAMAGE.
  */
 
-#if 0
+#include <sys/cdefs.h>
 #ifndef lint
+#if 0
 static char sccsid[] = "@(#)create.c	8.1 (Berkeley) 6/6/93";
-#endif /* not lint */
+#else
+__RCSID("$NetBSD: create.c,v 1.25.4.1 2000/10/17 19:50:25 tv Exp $");
 #endif
-#include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/usr.sbin/mtree/create.c,v 1.37 2005/03/29 11:44:17 tobez Exp $");
+#endif /* not lint */
 
 #include <sys/param.h>
 #include <sys/stat.h>
 #include <dirent.h>
-#include <err.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <fts.h>
 #include <grp.h>
-#ifdef MD5
 #include <md5.h>
-#endif
-#ifdef SHA1
-#include <sha.h>
-#endif
-#ifdef RMD160
-#include <ripemd.h>
-#endif
-#ifdef SHA256
-#include <sha256.h>
-#endif
 #include <pwd.h>
-#include <stdint.h>
 #include <stdio.h>
+#include <string.h>
 #include <time.h>
 #include <unistd.h>
 #include <vis.h>
@@ -66,221 +61,175 @@
 
 #define	INDENTNAMELEN	15
 #define	MAXLINELEN	80
+#define VISFLAGS        VIS_CSTYLE
+
+extern int crc_total, ftsoptions;
+extern int dflag, sflag;
+extern int keys;
+extern char fullpath[MAXPATHLEN];
 
 static gid_t gid;
 static uid_t uid;
 static mode_t mode;
-static u_long flags = 0xffffffff;
-
-static int	dsort(const FTSENT * const *, const FTSENT * const *);
-static void	output(int, int *, const char *, ...) __printflike(3, 4);
-static int	statd(FTS *, FTSENT *, uid_t *, gid_t *, mode_t *, u_long *);
-static void	statf(int, FTSENT *);
+static u_long flags;
+static char codebuf[4*MAXPATHLEN + 1];
+static const char extra[] = { ' ', '\t', '\n', '\\', '#', '\0' };
+
+static int	dsort __P((const FTSENT **, const FTSENT **));
+static void	output __P((int *, const char *, ...))
+	__attribute__((__format__(__printf__, 2, 3)));
+static int	statd __P((FTS *, FTSENT *, uid_t *, gid_t *, mode_t *,
+			   u_long *));
+static void	statf __P((FTSENT *));
 
 void
-cwalk(void)
+cwalk()
 {
 	FTS *t;
 	FTSENT *p;
-	time_t cl;
-	char *argv[2], host[MAXHOSTNAMELEN];
-	char dot[] = ".";
-	int indent = 0;
-
-	if (!nflag) {
-		(void)time(&cl);
-		(void)gethostname(host, sizeof(host));
-		(void)printf(
-		    "#\t   user: %s\n#\tmachine: %s\n",
-		    getlogin(), host);
-		(void)printf(
-		    "#\t   tree: %s\n#\t   date: %s",
-		    fullpath, ctime(&cl));
-	}
+	time_t clock;
+	char *argv[2], host[MAXHOSTNAMELEN + 1];
 
-	argv[0] = dot;
+	(void)time(&clock);
+	(void)gethostname(host, sizeof(host));
+	host[sizeof(host) - 1] = '\0';
+	(void)printf(
+	    "#\t   user: %s\n#\tmachine: %s\n#\t   tree: %s\n#\t   date: %s",
+	    getlogin(), host, fullpath, ctime(&clock));
+
+	argv[0] = ".";
 	argv[1] = NULL;
 	if ((t = fts_open(argv, ftsoptions, dsort)) == NULL)
-		err(1, "fts_open()");
-	while ((p = fts_read(t))) {
-		if (iflag)
-			indent = p->fts_level * 4;
-		if (check_excludes(p->fts_name, p->fts_path)) {
-			fts_set(t, p, FTS_SKIP);
-			continue;
-		}
+		mtree_err("fts_open: %s", strerror(errno));
+	while ((p = fts_read(t)) != NULL)
 		switch(p->fts_info) {
 		case FTS_D:
-			if (!dflag)
-				(void)printf("\n");
-			if (!nflag)
-				(void)printf("# %s\n", p->fts_path);
+			(void)printf("\n# %s\n", p->fts_path);
 			statd(t, p, &uid, &gid, &mode, &flags);
-			statf(indent, p);
+			statf(p);
 			break;
 		case FTS_DP:
-			if (!nflag && (p->fts_level > 0))
-				(void)printf("%*s# %s\n", indent, "", p->fts_path);
-			(void)printf("%*s..\n", indent, "");
-			if (!dflag)
-				(void)printf("\n");
+			if (p->fts_level > 0)
+				(void)printf("# %s\n..\n\n", p->fts_path);
 			break;
 		case FTS_DNR:
 		case FTS_ERR:
 		case FTS_NS:
-			warnx("%s: %s", p->fts_path, strerror(p->fts_errno));
+			(void)fprintf(stderr,
+			    "mtree: %s: %s\n", p->fts_path, strerror(errno));
 			break;
 		default:
 			if (!dflag)
-				statf(indent, p);
+				statf(p);
 			break;
-
+			
 		}
-	}
 	(void)fts_close(t);
 	if (sflag && keys & F_CKSUM)
-		warnx("%s checksum: %lu", fullpath, (unsigned long)crc_total);
+		(void)fprintf(stderr,
+		    "mtree: %s checksum: %u\n", fullpath, crc_total);
 }
 
 static void
-statf(int indent, FTSENT *p)
+statf(p)
+	FTSENT *p;
 {
 	struct group *gr;
 	struct passwd *pw;
-	uint32_t val;
-	off_t len;
-	int fd, offset;
-	char *fflags;
-	char *escaped_name;
-
-	escaped_name = calloc(1, p->fts_namelen * 4  +  1);
-	if (escaped_name == NULL)
-		errx(1, "statf(): calloc() failed");
-	strvis(escaped_name, p->fts_name, VIS_WHITE | VIS_OCTAL | VIS_GLOB);
-
-	if (iflag || S_ISDIR(p->fts_statp->st_mode))
-		offset = printf("%*s%s", indent, "", escaped_name);
+	u_int32_t len, val;
+	int fd, indent;
+	char md5buf[33], *md5cp;
+
+	strsvis(codebuf, p->fts_name, VISFLAGS, extra);
+	if (S_ISDIR(p->fts_statp->st_mode))
+		indent = printf("%s", codebuf); 
 	else
-		offset = printf("%*s    %s", indent, "", escaped_name);
-
-	free(escaped_name);
+		indent = printf("    %s", codebuf);
 
-	if (offset > (INDENTNAMELEN + indent))
-		offset = MAXLINELEN;
+	if (indent > INDENTNAMELEN)
+		indent = MAXLINELEN;
 	else
-		offset += printf("%*s", (INDENTNAMELEN + indent) - offset, "");
+		indent += printf("%*s", INDENTNAMELEN - indent, "");
 
-	if (!S_ISREG(p->fts_statp->st_mode) && !dflag)
-		output(indent, &offset, "type=%s", inotype(p->fts_statp->st_mode));
-	if (p->fts_statp->st_uid != uid) {
-		if (keys & F_UNAME) {
-			pw = getpwuid(p->fts_statp->st_uid);
-			if (pw != NULL)
-				output(indent, &offset, "uname=%s", pw->pw_name);
-			else if (wflag)
-				warnx("Could not get uname for uid=%u",
-				    p->fts_statp->st_uid);
-			else
-				errx(1,
-				    "Could not get uname for uid=%u",
-				    p->fts_statp->st_uid);
-		}
-		if (keys & F_UID)
-			output(indent, &offset, "uid=%u", p->fts_statp->st_uid);
-	}
-	if (p->fts_statp->st_gid != gid) {
-		if (keys & F_GNAME) {
-			gr = getgrgid(p->fts_statp->st_gid);
-			if (gr != NULL)
-				output(indent, &offset, "gname=%s", gr->gr_name);
-			else if (wflag)
-				warnx("Could not get gname for gid=%u",
-				    p->fts_statp->st_gid);
-			else
-				errx(1,
-				    "Could not get gname for gid=%u",
-				    p->fts_statp->st_gid);
-		}
-		if (keys & F_GID)
-			output(indent, &offset, "gid=%u", p->fts_statp->st_gid);
+	if (!S_ISREG(p->fts_statp->st_mode))
+		output(&indent, "type=%s", inotype(p->fts_statp->st_mode));
+	if (keys & (F_UID | F_UNAME) && p->fts_statp->st_uid != uid) {
+		if (keys & F_UNAME && (pw = getpwuid(p->fts_statp->st_uid)))
+			output(&indent, "uname=%s", pw->pw_name);
+		else /* if (keys & F_UID) */
+			output(&indent, "uid=%u", p->fts_statp->st_uid);
+	}
+	if (keys & (F_GID | F_GNAME) && p->fts_statp->st_gid != gid) {
+		if (keys & F_GNAME && (gr = getgrgid(p->fts_statp->st_gid)))
+			output(&indent, "gname=%s", gr->gr_name);
+		else /* if (keys & F_GID) */
+			output(&indent, "gid=%u", p->fts_statp->st_gid);
 	}
 	if (keys & F_MODE && (p->fts_statp->st_mode & MBITS) != mode)
-		output(indent, &offset, "mode=%#o", p->fts_statp->st_mode & MBITS);
+		output(&indent, "mode=%#o", p->fts_statp->st_mode & MBITS);
 	if (keys & F_NLINK && p->fts_statp->st_nlink != 1)
-		output(indent, &offset, "nlink=%u", p->fts_statp->st_nlink);
-	if (keys & F_SIZE)
-		output(indent, &offset, "size=%jd",
-		    (intmax_t)p->fts_statp->st_size);
+		output(&indent, "nlink=%u", p->fts_statp->st_nlink);
+	if (keys & F_SIZE && S_ISREG(p->fts_statp->st_mode))
+		output(&indent, "size=%lld", (long long)p->fts_statp->st_size);
+#ifndef __APPLE__
+# ifdef BSD4_4
 	if (keys & F_TIME)
-		output(indent, &offset, "time=%ld.%ld",
+		output(&indent, "time=%ld.%ld",
 		    (long)p->fts_statp->st_mtimespec.tv_sec,
 		    p->fts_statp->st_mtimespec.tv_nsec);
+# else
+		output(&indent, "time=%ld.%ld",
+		    p->fts_statp->st_mtime, 0);
+# endif
+#else
+	if (keys & F_TIME)
+		output(&indent, "time=%ld.%ld",
+		    p->fts_statp->st_mtimespec.ts_sec,
+		    p->fts_statp->st_mtimespec.ts_nsec);
+#endif
 	if (keys & F_CKSUM && S_ISREG(p->fts_statp->st_mode)) {
 		if ((fd = open(p->fts_accpath, O_RDONLY, 0)) < 0 ||
 		    crc(fd, &val, &len))
-			err(1, "%s", p->fts_accpath);
+			mtree_err("%s: %s", p->fts_accpath, strerror(errno));
 		(void)close(fd);
-		output(indent, &offset, "cksum=%lu", (unsigned long)val);
+		output(&indent, "cksum=%lu", (long)val);
 	}
-#ifdef MD5
 	if (keys & F_MD5 && S_ISREG(p->fts_statp->st_mode)) {
-		char *digest, buf[33];
-
-		digest = MD5File(p->fts_accpath, buf);
-		if (!digest)
-			err(1, "%s", p->fts_accpath);
-		output(indent, &offset, "md5digest=%s", digest);
-	}
-#endif /* MD5 */
-#ifdef SHA1
-	if (keys & F_SHA1 && S_ISREG(p->fts_statp->st_mode)) {
-		char *digest, buf[41];
-
-		digest = SHA1_File(p->fts_accpath, buf);
-		if (!digest)
-			err(1, "%s", p->fts_accpath);
-		output(indent, &offset, "sha1digest=%s", digest);
-	}
-#endif /* SHA1 */
-#ifdef RMD160
-	if (keys & F_RMD160 && S_ISREG(p->fts_statp->st_mode)) {
-		char *digest, buf[41];
-
-		digest = RIPEMD160_File(p->fts_accpath, buf);
-		if (!digest)
-			err(1, "%s", p->fts_accpath);
-		output(indent, &offset, "ripemd160digest=%s", digest);
+		if ((md5cp = MD5File(p->fts_accpath, md5buf)) == NULL)
+			mtree_err("%s: %s", p->fts_accpath, "MD5File");
+				  output(&indent, "md5=%s", md5cp);
 	}
-#endif /* RMD160 */
-#ifdef SHA256
-	if (keys & F_SHA256 && S_ISREG(p->fts_statp->st_mode)) {
-		char *digest, buf[65];
-
-		digest = SHA256_File(p->fts_accpath, buf);
-		if (!digest)
-			err(1, "%s", p->fts_accpath);
-		output(indent, &offset, "sha256digest=%s", digest);
-	}
-#endif /* SHA256 */
 	if (keys & F_SLINK &&
 	    (p->fts_info == FTS_SL || p->fts_info == FTS_SLNONE))
-		output(indent, &offset, "link=%s", rlink(p->fts_accpath));
-	if (keys & F_FLAGS && p->fts_statp->st_flags != flags) {
-		fflags = flags_to_string(p->fts_statp->st_flags);
-		output(indent, &offset, "flags=%s", fflags);
-		free(fflags);
-	}
+		output(&indent, "link=%s", rlink(p->fts_accpath));
+#ifndef linux
+	if (keys & F_FLAGS && p->fts_statp->st_flags != flags)
+		output(&indent, "flags=%s",
+		    flags_to_string(p->fts_statp->st_flags, "none"));
+#endif
 	(void)putchar('\n');
 }
 
-#define	MAXGID	5000
-#define	MAXUID	5000
-#define	MAXMODE	MBITS + 1
-#define	MAXFLAGS 256
-#define	MAXS 16
+/* XXX
+ * FLAGS2INDEX will fail once the user and system settable bits need more
+ * than one byte, respectively.
+ */
+#define FLAGS2INDEX(x)  (((x >> 8) & 0x0000ff00) | (x & 0x000000ff))
+
+#define	MTREE_MAXGID	5000
+#define	MTREE_MAXUID	5000
+#define	MTREE_MAXMODE	(MBITS + 1)
+#define	MTREE_MAXFLAGS  (FLAGS2INDEX(CH_MASK) + 1)   /* 1808 */
+#define	MTREE_MAXS 16
 
 static int
-statd(FTS *t, FTSENT *parent, uid_t *puid, gid_t *pgid, mode_t *pmode, u_long *pflags)
+statd(t, parent, puid, pgid, pmode, pflags)
+	FTS *t;
+	FTSENT *parent;
+	uid_t *puid;
+	gid_t *pgid;
+	mode_t *pmode;
+	u_long *pflags;
 {
 	FTSENT *p;
 	gid_t sgid;
@@ -289,117 +238,96 @@
 	u_long sflags;
 	struct group *gr;
 	struct passwd *pw;
-	gid_t savegid = *pgid;
-	uid_t saveuid = *puid;
-	mode_t savemode = *pmode;
-	u_long saveflags = *pflags;
+	gid_t savegid;
+	uid_t saveuid;
+	mode_t savemode;
+	u_long saveflags;
 	u_short maxgid, maxuid, maxmode, maxflags;
-	u_short g[MAXGID], u[MAXUID], m[MAXMODE], f[MAXFLAGS];
-	char *fflags;
-	static int first = 1;
+#ifndef linux
+	u_short g[MTREE_MAXGID], u[MTREE_MAXUID],
+		m[MTREE_MAXMODE], f[MTREE_MAXFLAGS];
+#else	
+	u_short g[MTREE_MAXGID], u[MTREE_MAXUID],
+	  m[MTREE_MAXMODE];
+#endif
 
+	savegid = 0;
+	saveuid = 0;
+	savemode = 0;
+	saveflags = 0;
 	if ((p = fts_children(t, 0)) == NULL) {
 		if (errno)
-			err(1, "%s", RP(parent));
+			mtree_err("%s: %s", RP(parent), strerror(errno));
 		return (1);
 	}
 
-	bzero(g, sizeof(g));
-	bzero(u, sizeof(u));
-	bzero(m, sizeof(m));
-	bzero(f, sizeof(f));
+	memset(g, 0, sizeof(g));
+	memset(u, 0, sizeof(u));
+	memset(m, 0, sizeof(m));
+#ifndef linux
+	memset(f, 0, sizeof(f));
+#endif
 
 	maxuid = maxgid = maxmode = maxflags = 0;
 	for (; p; p = p->fts_link) {
-		if (!dflag || (dflag && S_ISDIR(p->fts_statp->st_mode))) {
-			smode = p->fts_statp->st_mode & MBITS;
-			if (smode < MAXMODE && ++m[smode] > maxmode) {
-				savemode = smode;
-				maxmode = m[smode];
-			}
-			sgid = p->fts_statp->st_gid;
-			if (sgid < MAXGID && ++g[sgid] > maxgid) {
-				savegid = sgid;
-				maxgid = g[sgid];
-			}
-			suid = p->fts_statp->st_uid;
-			if (suid < MAXUID && ++u[suid] > maxuid) {
-				saveuid = suid;
-				maxuid = u[suid];
-			}
-
-			/*
-			 * XXX
-			 * note that the below will break when file flags
-			 * are extended beyond the first 4 bytes of each
-			 * half word of the flags
-			 */
-#define FLAGS2IDX(f) ((f & 0xf) | ((f >> 12) & 0xf0))
-			sflags = p->fts_statp->st_flags;
-			if (FLAGS2IDX(sflags) < MAXFLAGS &&
-			    ++f[FLAGS2IDX(sflags)] > maxflags) {
-				saveflags = sflags;
-				maxflags = f[FLAGS2IDX(sflags)];
-			}
+		smode = p->fts_statp->st_mode & MBITS;
+		if (smode < MTREE_MAXMODE && ++m[smode] > maxmode) {
+			savemode = smode;
+			maxmode = m[smode];
 		}
-	}
-	/*
-	 * If the /set record is the same as the last one we do not need to output
-	 * a new one.  So first we check to see if anything changed.  Note that we
-	 * always output a /set record for the first directory.
-	 */
-	if ((((keys & F_UNAME) | (keys & F_UID)) && (*puid != saveuid)) ||
-	    (((keys & F_GNAME) | (keys & F_GID)) && (*pgid != savegid)) ||
-	    ((keys & F_MODE) && (*pmode != savemode)) ||
-	    ((keys & F_FLAGS) && (*pflags != saveflags)) ||
-	    (first)) {
-		first = 0;
-		if (dflag)
-			(void)printf("/set type=dir");
-		else
-			(void)printf("/set type=file");
-		if (keys & F_UNAME) {
-			pw = getpwuid(saveuid);
-			if (pw != NULL)
-				(void)printf(" uname=%s", pw->pw_name);
-			else if (wflag)
-				warnx( "Could not get uname for uid=%u", saveuid);
-			else
-				errx(1, "Could not get uname for uid=%u", saveuid);
+		sgid = p->fts_statp->st_gid;
+		if (sgid < MTREE_MAXGID && ++g[sgid] > maxgid) {
+			savegid = sgid;
+			maxgid = g[sgid];
 		}
-		if (keys & F_UID)
-			(void)printf(" uid=%lu", (u_long)saveuid);
-		if (keys & F_GNAME) {
-			gr = getgrgid(savegid);
-			if (gr != NULL)
-				(void)printf(" gname=%s", gr->gr_name);
-			else if (wflag)
-				warnx("Could not get gname for gid=%u", savegid);
-			else
-				errx(1, "Could not get gname for gid=%u", savegid);
+		suid = p->fts_statp->st_uid;
+		if (suid < MTREE_MAXUID && ++u[suid] > maxuid) {
+			saveuid = suid;
+			maxuid = u[suid];
 		}
-		if (keys & F_GID)
-			(void)printf(" gid=%lu", (u_long)savegid);
-		if (keys & F_MODE)
-			(void)printf(" mode=%#o", savemode);
-		if (keys & F_NLINK)
-			(void)printf(" nlink=1");
-		if (keys & F_FLAGS) {
-			fflags = flags_to_string(saveflags);
-			(void)printf(" flags=%s", fflags);
-			free(fflags);
+#ifndef linux
+		sflags = FLAGS2INDEX(p->fts_statp->st_flags);
+		if (sflags < MTREE_MAXFLAGS && ++f[sflags] > maxflags) {
+			saveflags = p->fts_statp->st_flags;
+			maxflags = f[sflags];
 		}
-		(void)printf("\n");
-		*puid = saveuid;
-		*pgid = savegid;
-		*pmode = savemode;
-		*pflags = saveflags;
+#endif
+	}
+	(void)printf("/set type=file");
+	if (keys & F_GID)
+		(void)printf(" gid=%lu", (u_long)savegid);
+	if (keys & F_GNAME) {
+		if ((gr = getgrgid(savegid)) != NULL)
+			(void)printf(" gname=%s", gr->gr_name);
+		else
+			(void)printf(" gid=%lu", (u_long)savegid);
 	}
+	if (keys & F_UNAME) {
+		if ((pw = getpwuid(saveuid)) != NULL)
+			(void)printf(" uname=%s", pw->pw_name);
+		else
+			(void)printf(" uid=%lu", (u_long)saveuid);
+	}
+	if (keys & F_UID)
+		(void)printf(" uid=%lu", (u_long)saveuid);
+	if (keys & F_MODE)
+		(void)printf(" mode=%#lo", (u_long)savemode);
+	if (keys & F_NLINK)
+		(void)printf(" nlink=1");
+	if (keys & F_FLAGS)
+		(void)printf(" flags=%s",
+		    flags_to_string(saveflags, "none"));
+	(void)printf("\n");
+	*puid = saveuid;
+	*pgid = savegid;
+	*pmode = savemode;
+	*pflags = saveflags;
 	return (0);
 }
 
 static int
-dsort(const FTSENT * const *a, const FTSENT * const *b)
+dsort(a, b)
+	const FTSENT **a, **b;
 {
 	if (S_ISDIR((*a)->fts_statp->st_mode)) {
 		if (!S_ISDIR((*b)->fts_statp->st_mode))
@@ -409,20 +337,35 @@
 	return (strcmp((*a)->fts_name, (*b)->fts_name));
 }
 
+#if __STDC__
 #include <stdarg.h>
+#else
+#include <varargs.h>
+#endif
 
 void
-output(int indent, int *offset, const char *fmt, ...)
+#if __STDC__
+output(int *offset, const char *fmt, ...)
+#else
+output(offset, fmt, va_alist)
+	int *offset;
+	char *fmt;
+        va_dcl
+#endif
 {
 	va_list ap;
 	char buf[1024];
+#if __STDC__
 	va_start(ap, fmt);
+#else
+	va_start(ap);
+#endif
 	(void)vsnprintf(buf, sizeof(buf), fmt, ap);
 	va_end(ap);
 
 	if (*offset + strlen(buf) > MAXLINELEN - 3) {
-		(void)printf(" \\\n%*s", INDENTNAMELEN + indent, "");
-		*offset = INDENTNAMELEN + indent;
+		(void)printf(" \\\n%*s", INDENTNAMELEN, "");
+		*offset = INDENTNAMELEN;
 	}
 	*offset += printf(" %s", buf) + 1;
 }
diff -ru -ruN mtree/create.c.orig mtree-linux/create.c.orig
--- mtree/create.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ mtree-linux/create.c.orig	2000-10-17 21:50:25.000000000 +0200
@@ -0,0 +1,361 @@
+/*	$NetBSD: create.c,v 1.25.4.1 2000/10/17 19:50:25 tv Exp $	*/
+
+/*-
+ * Copyright (c) 1989, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+#ifndef lint
+#if 0
+static char sccsid[] = "@(#)create.c	8.1 (Berkeley) 6/6/93";
+#else
+__RCSID("$NetBSD: create.c,v 1.25.4.1 2000/10/17 19:50:25 tv Exp $");
+#endif
+#endif /* not lint */
+
+#include <sys/param.h>
+#include <sys/stat.h>
+#include <dirent.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <fts.h>
+#include <grp.h>
+#include <md5.h>
+#include <pwd.h>
+#include <stdio.h>
+#include <string.h>
+#include <time.h>
+#include <unistd.h>
+#include <vis.h>
+#include "mtree.h"
+#include "extern.h"
+
+#define	INDENTNAMELEN	15
+#define	MAXLINELEN	80
+#define VISFLAGS        VIS_CSTYLE
+
+extern int crc_total, ftsoptions;
+extern int dflag, sflag;
+extern int keys;
+extern char fullpath[MAXPATHLEN];
+
+static gid_t gid;
+static uid_t uid;
+static mode_t mode;
+static u_long flags;
+static char codebuf[4*MAXPATHLEN + 1];
+static const char extra[] = { ' ', '\t', '\n', '\\', '#', '\0' };
+
+static int	dsort __P((const FTSENT **, const FTSENT **));
+static void	output __P((int *, const char *, ...))
+	__attribute__((__format__(__printf__, 2, 3)));
+static int	statd __P((FTS *, FTSENT *, uid_t *, gid_t *, mode_t *,
+			   u_long *));
+static void	statf __P((FTSENT *));
+
+void
+cwalk()
+{
+	FTS *t;
+	FTSENT *p;
+	time_t clock;
+	char *argv[2], host[MAXHOSTNAMELEN + 1];
+
+	(void)time(&clock);
+	(void)gethostname(host, sizeof(host));
+	host[sizeof(host) - 1] = '\0';
+	(void)printf(
+	    "#\t   user: %s\n#\tmachine: %s\n#\t   tree: %s\n#\t   date: %s",
+	    getlogin(), host, fullpath, ctime(&clock));
+
+	argv[0] = ".";
+	argv[1] = NULL;
+	if ((t = fts_open(argv, ftsoptions, dsort)) == NULL)
+		mtree_err("fts_open: %s", strerror(errno));
+	while ((p = fts_read(t)) != NULL)
+		switch(p->fts_info) {
+		case FTS_D:
+			(void)printf("\n# %s\n", p->fts_path);
+			statd(t, p, &uid, &gid, &mode, &flags);
+			statf(p);
+			break;
+		case FTS_DP:
+			if (p->fts_level > 0)
+				(void)printf("# %s\n..\n\n", p->fts_path);
+			break;
+		case FTS_DNR:
+		case FTS_ERR:
+		case FTS_NS:
+			(void)fprintf(stderr,
+			    "mtree: %s: %s\n", p->fts_path, strerror(errno));
+			break;
+		default:
+			if (!dflag)
+				statf(p);
+			break;
+			
+		}
+	(void)fts_close(t);
+	if (sflag && keys & F_CKSUM)
+		(void)fprintf(stderr,
+		    "mtree: %s checksum: %u\n", fullpath, crc_total);
+}
+
+static void
+statf(p)
+	FTSENT *p;
+{
+	struct group *gr;
+	struct passwd *pw;
+	u_int32_t len, val;
+	int fd, indent;
+	char md5buf[33], *md5cp;
+
+	strsvis(codebuf, p->fts_name, VISFLAGS, extra);
+	if (S_ISDIR(p->fts_statp->st_mode))
+		indent = printf("%s", codebuf); 
+	else
+		indent = printf("    %s", codebuf);
+
+	if (indent > INDENTNAMELEN)
+		indent = MAXLINELEN;
+	else
+		indent += printf("%*s", INDENTNAMELEN - indent, "");
+
+	if (!S_ISREG(p->fts_statp->st_mode))
+		output(&indent, "type=%s", inotype(p->fts_statp->st_mode));
+	if (keys & (F_UID | F_UNAME) && p->fts_statp->st_uid != uid) {
+		if (keys & F_UNAME && (pw = getpwuid(p->fts_statp->st_uid)))
+			output(&indent, "uname=%s", pw->pw_name);
+		else /* if (keys & F_UID) */
+			output(&indent, "uid=%u", p->fts_statp->st_uid);
+	}
+	if (keys & (F_GID | F_GNAME) && p->fts_statp->st_gid != gid) {
+		if (keys & F_GNAME && (gr = getgrgid(p->fts_statp->st_gid)))
+			output(&indent, "gname=%s", gr->gr_name);
+		else /* if (keys & F_GID) */
+			output(&indent, "gid=%u", p->fts_statp->st_gid);
+	}
+	if (keys & F_MODE && (p->fts_statp->st_mode & MBITS) != mode)
+		output(&indent, "mode=%#o", p->fts_statp->st_mode & MBITS);
+	if (keys & F_NLINK && p->fts_statp->st_nlink != 1)
+		output(&indent, "nlink=%u", p->fts_statp->st_nlink);
+	if (keys & F_SIZE && S_ISREG(p->fts_statp->st_mode))
+		output(&indent, "size=%lld", (long long)p->fts_statp->st_size);
+#ifndef __APPLE__
+# ifdef BSD4_4
+	if (keys & F_TIME)
+		output(&indent, "time=%ld.%ld",
+		    (long)p->fts_statp->st_mtimespec.tv_sec,
+		    p->fts_statp->st_mtimespec.tv_nsec);
+# else
+		output(&indent, "time=%ld.%ld",
+		    p->fts_statp->st_mtime, 0);
+# endif
+#else
+	if (keys & F_TIME)
+		output(&indent, "time=%ld.%ld",
+		    p->fts_statp->st_mtimespec.ts_sec,
+		    p->fts_statp->st_mtimespec.ts_nsec);
+#endif
+	if (keys & F_CKSUM && S_ISREG(p->fts_statp->st_mode)) {
+		if ((fd = open(p->fts_accpath, O_RDONLY, 0)) < 0 ||
+		    crc(fd, &val, &len))
+			mtree_err("%s: %s", p->fts_accpath, strerror(errno));
+		(void)close(fd);
+		output(&indent, "cksum=%lu", (long)val);
+	}
+	if (keys & F_MD5 && S_ISREG(p->fts_statp->st_mode)) {
+		if ((md5cp = MD5File(p->fts_accpath, md5buf)) == NULL)
+			mtree_err("%s: %s", p->fts_accpath, "MD5File");
+				  output(&indent, "md5=%s", md5cp);
+	}
+	if (keys & F_SLINK &&
+	    (p->fts_info == FTS_SL || p->fts_info == FTS_SLNONE))
+		output(&indent, "link=%s", rlink(p->fts_accpath));
+	if (keys & F_FLAGS && p->fts_statp->st_flags != flags)
+		output(&indent, "flags=%s",
+		    flags_to_string(p->fts_statp->st_flags, "none"));
+	(void)putchar('\n');
+}
+
+/* XXX
+ * FLAGS2INDEX will fail once the user and system settable bits need more
+ * than one byte, respectively.
+ */
+#define FLAGS2INDEX(x)  (((x >> 8) & 0x0000ff00) | (x & 0x000000ff))
+
+#define	MTREE_MAXGID	5000
+#define	MTREE_MAXUID	5000
+#define	MTREE_MAXMODE	(MBITS + 1)
+#define	MTREE_MAXFLAGS  (FLAGS2INDEX(CH_MASK) + 1)   /* 1808 */
+#define	MTREE_MAXS 16
+
+static int
+statd(t, parent, puid, pgid, pmode, pflags)
+	FTS *t;
+	FTSENT *parent;
+	uid_t *puid;
+	gid_t *pgid;
+	mode_t *pmode;
+	u_long *pflags;
+{
+	FTSENT *p;
+	gid_t sgid;
+	uid_t suid;
+	mode_t smode;
+	u_long sflags;
+	struct group *gr;
+	struct passwd *pw;
+	gid_t savegid;
+	uid_t saveuid;
+	mode_t savemode;
+	u_long saveflags;
+	u_short maxgid, maxuid, maxmode, maxflags;
+	u_short g[MTREE_MAXGID], u[MTREE_MAXUID],
+		m[MTREE_MAXMODE], f[MTREE_MAXFLAGS];
+
+	savegid = 0;
+	saveuid = 0;
+	savemode = 0;
+	saveflags = 0;
+	if ((p = fts_children(t, 0)) == NULL) {
+		if (errno)
+			mtree_err("%s: %s", RP(parent), strerror(errno));
+		return (1);
+	}
+
+	memset(g, 0, sizeof(g));
+	memset(u, 0, sizeof(u));
+	memset(m, 0, sizeof(m));
+	memset(f, 0, sizeof(f));
+
+	maxuid = maxgid = maxmode = maxflags = 0;
+	for (; p; p = p->fts_link) {
+		smode = p->fts_statp->st_mode & MBITS;
+		if (smode < MTREE_MAXMODE && ++m[smode] > maxmode) {
+			savemode = smode;
+			maxmode = m[smode];
+		}
+		sgid = p->fts_statp->st_gid;
+		if (sgid < MTREE_MAXGID && ++g[sgid] > maxgid) {
+			savegid = sgid;
+			maxgid = g[sgid];
+		}
+		suid = p->fts_statp->st_uid;
+		if (suid < MTREE_MAXUID && ++u[suid] > maxuid) {
+			saveuid = suid;
+			maxuid = u[suid];
+		}
+
+		sflags = FLAGS2INDEX(p->fts_statp->st_flags);
+		if (sflags < MTREE_MAXFLAGS && ++f[sflags] > maxflags) {
+			saveflags = p->fts_statp->st_flags;
+			maxflags = f[sflags];
+		}
+	}
+	(void)printf("/set type=file");
+	if (keys & F_GID)
+		(void)printf(" gid=%lu", (u_long)savegid);
+	if (keys & F_GNAME) {
+		if ((gr = getgrgid(savegid)) != NULL)
+			(void)printf(" gname=%s", gr->gr_name);
+		else
+			(void)printf(" gid=%lu", (u_long)savegid);
+	}
+	if (keys & F_UNAME) {
+		if ((pw = getpwuid(saveuid)) != NULL)
+			(void)printf(" uname=%s", pw->pw_name);
+		else
+			(void)printf(" uid=%lu", (u_long)saveuid);
+	}
+	if (keys & F_UID)
+		(void)printf(" uid=%lu", (u_long)saveuid);
+	if (keys & F_MODE)
+		(void)printf(" mode=%#lo", (u_long)savemode);
+	if (keys & F_NLINK)
+		(void)printf(" nlink=1");
+	if (keys & F_FLAGS)
+		(void)printf(" flags=%s",
+		    flags_to_string(saveflags, "none"));
+	(void)printf("\n");
+	*puid = saveuid;
+	*pgid = savegid;
+	*pmode = savemode;
+	*pflags = saveflags;
+	return (0);
+}
+
+static int
+dsort(a, b)
+	const FTSENT **a, **b;
+{
+	if (S_ISDIR((*a)->fts_statp->st_mode)) {
+		if (!S_ISDIR((*b)->fts_statp->st_mode))
+			return (1);
+	} else if (S_ISDIR((*b)->fts_statp->st_mode))
+		return (-1);
+	return (strcmp((*a)->fts_name, (*b)->fts_name));
+}
+
+#if __STDC__
+#include <stdarg.h>
+#else
+#include <varargs.h>
+#endif
+
+void
+#if __STDC__
+output(int *offset, const char *fmt, ...)
+#else
+output(offset, fmt, va_alist)
+	int *offset;
+	char *fmt;
+        va_dcl
+#endif
+{
+	va_list ap;
+	char buf[1024];
+#if __STDC__
+	va_start(ap, fmt);
+#else
+	va_start(ap);
+#endif
+	(void)vsnprintf(buf, sizeof(buf), fmt, ap);
+	va_end(ap);
+
+	if (*offset + strlen(buf) > MAXLINELEN - 3) {
+		(void)printf(" \\\n%*s", INDENTNAMELEN, "");
+		*offset = INDENTNAMELEN;
+	}
+	*offset += printf(" %s", buf) + 1;
+}
diff -ru -ruN mtree/digest-types.h mtree-linux/digest-types.h
--- mtree/digest-types.h	1970-01-01 01:00:00.000000000 +0100
+++ mtree-linux/digest-types.h	2001-08-04 11:34:24.000000000 +0200
@@ -0,0 +1,11 @@
+/* digest-types.h -- this file was generated for i686-pc-linux-gnu by
+                     $Id: mtree-linux.patch,v 1.1 2006/10/09 15:32:39 root Exp $ */
+
+#ifndef __digest_types_h__
+#define __digest_types_h__
+
+#include <sys/types.h>
+#include <inttypes.h>
+#include <sys/bitypes.h>
+
+#endif /* __digest_types_h__ */
diff -ru -ruN mtree/excludes.c mtree-linux/excludes.c
--- mtree/excludes.c	2003-10-21 10:27:05.000000000 +0200
+++ mtree-linux/excludes.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,111 +0,0 @@
-/*
- * Copyright 2000 Massachusetts Institute of Technology
- *
- * Permission to use, copy, modify, and distribute this software and
- * its documentation for any purpose and without fee is hereby
- * granted, provided that both the above copyright notice and this
- * permission notice appear in all copies, that both the above
- * copyright notice and this permission notice appear in all
- * supporting documentation, and that the name of M.I.T. not be used
- * in advertising or publicity pertaining to distribution of the
- * software without specific, written prior permission.  M.I.T. makes
- * no representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied
- * warranty.
- *
- * THIS SOFTWARE IS PROVIDED BY M.I.T. ``AS IS''.  M.I.T. DISCLAIMS
- * ALL EXPRESS OR IMPLIED WARRANTIES WITH REGARD TO THIS SOFTWARE,
- * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
- * SHALL M.I.T. BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/usr.sbin/mtree/excludes.c,v 1.8 2003/10/21 08:27:05 phk Exp $");
-
-#include <sys/types.h>
-#include <sys/time.h>		/* XXX for mtree.h */
-#include <sys/queue.h>
-
-#include <err.h>
-#include <fnmatch.h>
-#include <fts.h>
-#include <stdio.h>
-#include <stdlib.h>
-
-#include "mtree.h"		/* XXX for extern.h */
-#include "extern.h"
-
-/*
- * We're assuming that there won't be a whole lot of excludes,
- * so it's OK to use a stupid algorithm.
- */
-struct exclude {
-	LIST_ENTRY(exclude) link;
-	const char *glob;
-	int pathname;
-};
-static LIST_HEAD(, exclude) excludes;
-
-void
-init_excludes(void)
-{
-	LIST_INIT(&excludes);
-}
-
-void
-read_excludes_file(const char *name)
-{
-	FILE *fp;
-	char *line, *str;
-	struct exclude *e;
-	size_t len;
-
-	fp = fopen(name, "r");
-	if (fp == 0)
-		err(1, "%s", name);
-
-	while ((line = fgetln(fp, &len)) != 0) {
-		if (line[len - 1] == '\n')
-			len--;
-		if (len == 0)
-			continue;
-
-		str = malloc(len + 1);
-		e = malloc(sizeof *e);
-		if (str == 0 || e == 0)
-			errx(1, "memory allocation error");
-		e->glob = str;
-		memcpy(str, line, len);
-		str[len] = '\0';
-		if (strchr(str, '/'))
-			e->pathname = 1;
-		else
-			e->pathname = 0;
-		LIST_INSERT_HEAD(&excludes, e, link);
-	}
-	fclose(fp);
-}
-
-int
-check_excludes(const char *fname, const char *path)
-{
-	struct exclude *e;
-
-	/* fnmatch(3) has a funny return value convention... */
-#define MATCH(g, n) (fnmatch((g), (n), FNM_PATHNAME) == 0)
-
-	LIST_FOREACH(e, &excludes, link) {
-		if ((e->pathname && MATCH(e->glob, path))
-		    || MATCH(e->glob, fname))
-			return 1;
-	}
-	return 0;
-}
diff -ru -ruN mtree/extern.h mtree-linux/extern.h
--- mtree/extern.h	2004-01-11 20:38:48.000000000 +0100
+++ mtree-linux/extern.h	2001-08-05 13:02:59.000000000 +0200
@@ -1,3 +1,5 @@
+/*	$NetBSD: extern.h,v 1.7.4.1 2000/10/17 19:50:26 tv Exp $	*/
+
 /*-
  * Copyright (c) 1991, 1993
  *	The Regents of the University of California.  All rights reserved.
@@ -10,7 +12,11 @@
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
  *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
  *
@@ -27,33 +33,66 @@
  * SUCH DAMAGE.
  *
  *	@(#)extern.h	8.1 (Berkeley) 6/6/93
- * $FreeBSD: src/usr.sbin/mtree/extern.h,v 1.13 2004/01/11 19:38:48 phk Exp $
  */
-extern uint32_t crc_total;
 
-#ifdef _FTS_H_
-int	 compare(char *, NODE *, FTSENT *);
-#endif
-int	 crc(int, uint32_t *, off_t *);
-void	 cwalk(void);
-char	*flags_to_string(u_long);
-
-const char	*inotype(u_int);
-u_int	 parsekey(char *, int *);
-char	*rlink(char *);
-NODE	*mtree_readspec(FILE *fi);
-int	mtree_verifyspec(FILE *fi);
-int	mtree_specspec(FILE *fi, FILE *fj);
-
-int	 check_excludes(const char *, const char *);
-void	 init_excludes(void);
-void	 read_excludes_file(const char *);
-const char * ftype(u_int type);
-
-extern int ftsoptions;
-extern u_int keys;
-extern int lineno;
-extern int dflag, eflag, iflag, nflag, qflag, rflag, sflag, uflag, wflag;
-#ifdef MAXPATHLEN
-extern char fullpath[MAXPATHLEN];
+#include "mtree.h"
+
+#ifdef __APPLE__
+#include <fts.h>
 #endif
+
+int	 compare __P((char *, NODE *, FTSENT *));
+int	 crc __P((int, u_int32_t *, u_int32_t *));
+void	 cwalk __P((void));
+void	 mtree_err __P((const char *, ...))
+	__attribute__((__format__(__printf__, 1, 2)));
+char	*inotype __P((u_int));
+u_int	 parsekey __P((char *, int *));
+char	*rlink __P((char *));
+NODE	*spec __P((void));
+int	 verify __P((void));
+
+#ifdef linux
+
+mode_t   getmode __P((const void *, mode_t));
+void    *setmode __P((const char *));
+
+#define S_ISTXT 0001000
+
+# if !defined UF_NODUMP
+#  define UF_NODUMP 0
+# endif
+# if !defined UF_IMMUTABLE
+#  define UF_IMMUTABLE 0
+# endif
+# if !defined UF_APPEND
+#  define UF_APPEND 0
+# endif
+# if !defined UF_OPAQUE
+#  define UF_OPAQUE 0
+# endif
+# if !defined UF_NOUNLINK
+#  define UF_NOUNLINK 0
+# endif
+# if !defined SF_ARCHIVED
+#  define SF_ARCHIVED 0
+# endif
+# if !defined SF_IMMUTABLE
+#  define SF_IMMUTABLE 0
+# endif
+# if !defined SF_APPEND
+#  define SF_APPEND 0
+# endif
+# if !defined SF_NOUNLINK
+#  define SF_NOUNLINK 0
+# endif
+# define CHFLAGS_MASK  ( UF_NODUMP | UF_IMMUTABLE | UF_APPEND | UF_OPAQUE | UF_NOUNLINK | SF_ARCHIVED | SF_IMMUTABLE | SF_APPEND | SF_NOUNLINK )
+
+#endif /* linux */
+
+#include "stat_flags.h"
+
+
+
+
+
diff -ru -ruN mtree/extern.h.orig mtree-linux/extern.h.orig
--- mtree/extern.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ mtree-linux/extern.h.orig	2000-10-17 21:50:26.000000000 +0200
@@ -0,0 +1,55 @@
+/*	$NetBSD: extern.h,v 1.7.4.1 2000/10/17 19:50:26 tv Exp $	*/
+
+/*-
+ * Copyright (c) 1991, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)extern.h	8.1 (Berkeley) 6/6/93
+ */
+
+#include "mtree.h"
+
+#ifdef __APPLE__
+#include <fts.h>
+#endif
+
+int	 compare __P((char *, NODE *, FTSENT *));
+int	 crc __P((int, u_int32_t *, u_int32_t *));
+void	 cwalk __P((void));
+void	 mtree_err __P((const char *, ...))
+	__attribute__((__format__(__printf__, 1, 2)));
+char	*inotype __P((u_int));
+u_int	 parsekey __P((char *, int *));
+char	*rlink __P((char *));
+NODE	*spec __P((void));
+int	 verify __P((void));
+
+#include "stat_flags.h"
diff -ru -ruN mtree/filelist mtree-linux/filelist
--- mtree/filelist	1970-01-01 01:00:00.000000000 +0100
+++ mtree-linux/filelist	2001-08-06 10:25:33.000000000 +0200
@@ -0,0 +1,33 @@
+Taken from NetBSD 1.5.1:
+------------------------
+/usr/src/usr.sbin/mtree/compare.c
+/usr/src/usr.bin/cksum/crc.c
+/usr/src/usr.sbin/mtree/create.c
+/usr/src/usr.sbin/mtree/extern.h
+/usr/src/usr.sbin/mtree/misc.c
+/usr/src/usr.sbin/mtree/mtree.8
+/usr/src/usr.sbin/mtree/mtree.c
+/usr/src/usr.sbin/mtree/mtree.h
+/usr/src/lib/libc/gen/setmode.3
+/usr/src/lib/libc/gen/setmode.c
+/usr/src/usr.sbin/mtree/spec.c
+/usr/src/bin/ls/stat_flags.c
+/usr/src/bin/ls/stat_flags.h
+/usr/src/lib/libc/gen/unvis.3
+/usr/src/lib/libc/gen/unvis.c
+/usr/src/lib/libc/gen/vis.3
+/usr/src/lib/libc/gen/vis.c
+/usr/src/include/vis.h
+
+
+Taken from op-0.2:
+------------------
+digest-types.h (autogenerated when building op)
+
+op/tools/digest/md5.h
+op/tools/digest/md5c.c
+op/tools/digest/md5hl.c
+
+
+For each $(file) I have modified, the original source 
+is in $(file).orig
\ No newline at end of file
diff -ru -ruN mtree/md5.h mtree-linux/md5.h
--- mtree/md5.h	1970-01-01 01:00:00.000000000 +0100
+++ mtree-linux/md5.h	2001-07-20 03:11:02.000000000 +0200
@@ -0,0 +1,53 @@
+/*	$NetBSD: md5.h,v 1.1.1.1 2001/03/06 11:21:05 agc Exp $	*/
+
+/*
+ * This file is derived from the RSA Data Security, Inc. MD5 Message-Digest
+ * Algorithm and has been modified by Jason R. Thorpe <thorpej@NetBSD.ORG>
+ * for portability and formatting.
+ */
+
+/*
+ * Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
+ * rights reserved.
+ *
+ * License to copy and use this software is granted provided that it
+ * is identified as the "RSA Data Security, Inc. MD5 Message-Digest
+ * Algorithm" in all material mentioning or referencing this software
+ * or this function.
+ * 
+ * License is also granted to make and use derivative works provided
+ * that such works are identified as "derived from the RSA Data
+ * Security, Inc. MD5 Message-Digest Algorithm" in all material
+ * mentioning or referencing the derived work.
+ * 
+ * RSA Data Security, Inc. makes no representations concerning either
+ * the merchantability of this software or the suitability of this
+ * software for any particular purpose. It is provided "as is"
+ * without express or implied warranty of any kind.
+ * 
+ * These notices must be retained in any copies of any part of this
+ * documentation and/or software.
+ */
+
+#ifndef _SYS_MD5_H_
+#define _SYS_MD5_H_
+
+/* MD5 context. */
+typedef struct MD5Context {
+	u_int32_t state[4];	/* state (ABCD) */
+	u_int32_t count[2];	/* number of bits, modulo 2^64 (lsb first) */
+	unsigned char buffer[64]; /* input buffer */
+} MD5_CTX;
+
+__BEGIN_DECLS
+void	MD5Init __P((MD5_CTX *));
+void	MD5Update __P((MD5_CTX *, const unsigned char *, unsigned int));
+void	MD5Final __P((unsigned char[16], MD5_CTX *));
+#ifndef _KERNEL
+char	*MD5End __P((MD5_CTX *, char *));
+char	*MD5File __P((const char *, char *));
+char	*MD5Data __P((const unsigned char *, unsigned int, char *));
+#endif /* _KERNEL */
+__END_DECLS
+
+#endif /* _SYS_MD5_H_ */
diff -ru -ruN mtree/md5c.c mtree-linux/md5c.c
--- mtree/md5c.c	1970-01-01 01:00:00.000000000 +0100
+++ mtree-linux/md5c.c	2001-08-06 09:58:01.000000000 +0200
@@ -0,0 +1,367 @@
+/*	$NetBSD: md5c.c,v 1.2 2001/07/09 21:43:20 hubertf Exp $	*/
+
+/*
+ * This file is derived from the RSA Data Security, Inc. MD5 Message-Digest
+ * Algorithm and has been modifed by Jason R. Thorpe <thorpej@NetBSD.ORG>
+ * for portability and formatting.
+ */
+
+/*
+ * Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
+ * rights reserved.
+ *
+ * License to copy and use this software is granted provided that it
+ * is identified as the "RSA Data Security, Inc. MD5 Message-Digest
+ * Algorithm" in all material mentioning or referencing this software
+ * or this function.
+ *
+ * License is also granted to make and use derivative works provided
+ * that such works are identified as "derived from the RSA Data
+ * Security, Inc. MD5 Message-Digest Algorithm" in all material
+ * mentioning or referencing the derived work.
+ *
+ * RSA Data Security, Inc. makes no representations concerning either
+ * the merchantability of this software or the suitability of this
+ * software for any particular purpose. It is provided "as is"
+ * without express or implied warranty of any kind.
+ *
+ * These notices must be retained in any copies of any part of this
+ * documentation and/or software.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <digest-types.h>
+
+#if defined(_KERNEL) || defined(_STANDALONE)
+#include <lib/libkern/libkern.h>
+#include <sys/param.h>
+#include <sys/md5.h>
+#define _DIAGASSERT(x)	(void)0
+#else
+/* #include "namespace.h" */
+#include <assert.h>
+#include <string.h>
+#include <md5.h>
+#endif /* _KERNEL || _STANDALONE */
+
+#define	ZEROIZE(d, l)		memset((d), 0, (l))
+
+typedef unsigned char *POINTER;
+typedef u_int16_t UINT2;
+typedef u_int32_t UINT4;
+
+/*
+ * Constants for MD5Transform routine.
+ */
+#define S11 7
+#define S12 12
+#define S13 17
+#define S14 22
+#define S21 5
+#define S22 9
+#define S23 14
+#define S24 20
+#define S31 4
+#define S32 11
+#define S33 16
+#define S34 23
+#define S41 6
+#define S42 10
+#define S43 15
+#define S44 21
+
+#if 0
+#if !defined(_KERNEL) && !defined(_STANDALONE) && defined(__weak_alias)
+__weak_alias(MD5Init,_MD5Init)
+__weak_alias(MD5Update,_MD5Update)
+__weak_alias(MD5Final,_MD5Final)
+#endif
+#endif
+
+#ifndef _DIAGASSERT
+#define _DIAGASSERT(cond)	assert(cond)
+#endif
+
+static void MD5Transform __P((UINT4 [4], const unsigned char [64]));
+
+static void Encode __P((unsigned char *, UINT4 *, unsigned int));
+static void Decode __P((UINT4 *, const unsigned char *, unsigned int));
+
+/*
+ * Encodes input (UINT4) into output (unsigned char).  Assumes len is
+ * a multiple of 4.
+ */
+static void
+Encode (output, input, len)
+	unsigned char *output;
+	UINT4 *input;
+	unsigned int len;
+{
+	unsigned int i, j;
+
+	for (i = 0, j = 0; j < len; i++, j += 4) {
+		output[j] = (unsigned char)(input[i] & 0xff);
+		output[j+1] = (unsigned char)((input[i] >> 8) & 0xff);
+		output[j+2] = (unsigned char)((input[i] >> 16) & 0xff);
+		output[j+3] = (unsigned char)((input[i] >> 24) & 0xff);
+	}
+}
+
+/*
+ * Decodes input (unsigned char) into output (UINT4).  Assumes len is
+ * a multiple of 4.
+ */
+static void
+Decode (output, input, len)
+	UINT4 *output;
+	const unsigned char *input;
+	unsigned int len;
+{
+	unsigned int i, j;
+
+	for (i = 0, j = 0; j < len; i++, j += 4)
+		output[i] = ((UINT4)input[j]) | (((UINT4)input[j+1]) << 8) |
+		    (((UINT4)input[j+2]) << 16) | (((UINT4)input[j+3]) << 24);
+}
+
+static const unsigned char PADDING[64] = {
+	0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+};
+
+/*
+ * F, G, H and I are basic MD5 functions.
+ */
+#define F(x, y, z)	(((x) & (y)) | ((~x) & (z)))
+#define G(x, y, z)	(((x) & (z)) | ((y) & (~z)))
+#define H(x, y, z)	((x) ^ (y) ^ (z))
+#define I(x, y, z)	((y) ^ ((x) | (~z)))
+
+/*
+ * ROTATE_LEFT rotates x left n bits.
+ */
+#define ROTATE_LEFT(x, n)	(((x) << (n)) | ((x) >> (32-(n))))
+
+/*
+ * FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4.
+ * Rotation is separate from addition to prevent recomputation.
+ */
+#define FF(a, b, c, d, x, s, ac) { \
+	(a) += F ((b), (c), (d)) + (x) + (UINT4)(ac); \
+	(a) = ROTATE_LEFT ((a), (s)); \
+	(a) += (b); \
+}
+
+#define GG(a, b, c, d, x, s, ac) { \
+	(a) += G ((b), (c), (d)) + (x) + (UINT4)(ac); \
+	(a) = ROTATE_LEFT ((a), (s)); \
+	(a) += (b); \
+}
+
+#define HH(a, b, c, d, x, s, ac) { \
+	(a) += H ((b), (c), (d)) + (x) + (UINT4)(ac); \
+	(a) = ROTATE_LEFT ((a), (s)); \
+	(a) += (b); \
+}
+
+#define II(a, b, c, d, x, s, ac) { \
+	(a) += I ((b), (c), (d)) + (x) + (UINT4)(ac); \
+	(a) = ROTATE_LEFT ((a), (s)); \
+	(a) += (b); \
+}
+
+/*
+ * MD5 initialization. Begins an MD5 operation, writing a new context.
+ */
+void
+MD5Init(context)
+	MD5_CTX *context;		/* context */
+{
+
+	_DIAGASSERT(context != 0);
+
+	context->count[0] = context->count[1] = 0;
+
+	/* Load magic initialization constants. */
+	context->state[0] = 0x67452301;
+	context->state[1] = 0xefcdab89;
+	context->state[2] = 0x98badcfe;
+	context->state[3] = 0x10325476;
+}
+
+/*
+ * MD5 block update operation.  Continues an MD5 message-digest
+ * operation, processing another message block, and updating the
+ * context.
+ */
+void
+MD5Update(context, input, inputLen)
+	MD5_CTX *context;		/* context */
+	const unsigned char *input;	/* input block */
+	unsigned int inputLen;		/* length of input block */
+{
+	unsigned int i, idx, partLen;
+
+	_DIAGASSERT(context != 0);
+	_DIAGASSERT(input != 0);
+
+	/* Compute number of bytes mod 64 */
+	idx = (unsigned int)((context->count[0] >> 3) & 0x3F);
+
+	/* Update number of bits */
+	if ((context->count[0] += ((UINT4)inputLen << 3))
+	    < ((UINT4)inputLen << 3))
+		context->count[1]++;
+	context->count[1] += ((UINT4)inputLen >> 29);
+
+	partLen = 64 - idx;
+
+	/* Transform as many times as possible. */
+	if (inputLen >= partLen) {
+		/* LINTED const castaway ok */
+		memcpy((POINTER)&context->buffer[idx],
+		    input, partLen);
+		MD5Transform(context->state, context->buffer);
+
+		for (i = partLen; i + 63 < inputLen; i += 64)
+			MD5Transform(context->state, &input[i]);
+
+		idx = 0;
+	} else
+		i = 0;
+
+	/* Buffer remaining input */
+	/* LINTED const castaway ok */
+	memcpy((POINTER)&context->buffer[idx], &input[i],
+	    inputLen - i);
+}
+
+/*
+ * MD5 finalization.  Ends an MD5 message-digest operation, writing the
+ * message digest and zeroing the context.
+ */
+void
+MD5Final(digest, context)
+	unsigned char digest[16];	/* message digest */
+	MD5_CTX *context;		/* context */
+{
+	unsigned char bits[8];
+	unsigned int idx, padLen;
+
+	_DIAGASSERT(digest != 0);
+	_DIAGASSERT(context != 0);
+
+	/* Save number of bits */
+	Encode(bits, context->count, 8);
+
+	/* Pad out to 56 mod 64. */
+	idx = (unsigned int)((context->count[0] >> 3) & 0x3f);
+	padLen = (idx < 56) ? (56 - idx) : (120 - idx);
+	MD5Update (context, PADDING, padLen);
+
+	/* Append length (before padding) */
+	MD5Update(context, bits, 8);
+
+	/* Store state in digest */
+	Encode(digest, context->state, 16);
+
+	/* Zeroize sensitive information. */
+	ZEROIZE((POINTER)(void *)context, sizeof(*context));
+}
+
+/*
+ * MD5 basic transformation. Transforms state based on block.
+ */
+static void
+MD5Transform(state, block)
+	UINT4 state[4];
+	const unsigned char block[64];
+{
+	UINT4 a = state[0], b = state[1], c = state[2], d = state[3], x[16];
+
+	Decode(x, block, 64);
+
+	/* Round 1 */
+	FF (a, b, c, d, x[ 0], S11, 0xd76aa478); /* 1 */
+	FF (d, a, b, c, x[ 1], S12, 0xe8c7b756); /* 2 */
+	FF (c, d, a, b, x[ 2], S13, 0x242070db); /* 3 */
+	FF (b, c, d, a, x[ 3], S14, 0xc1bdceee); /* 4 */
+	FF (a, b, c, d, x[ 4], S11, 0xf57c0faf); /* 5 */
+	FF (d, a, b, c, x[ 5], S12, 0x4787c62a); /* 6 */
+	FF (c, d, a, b, x[ 6], S13, 0xa8304613); /* 7 */
+	FF (b, c, d, a, x[ 7], S14, 0xfd469501); /* 8 */
+	FF (a, b, c, d, x[ 8], S11, 0x698098d8); /* 9 */
+	FF (d, a, b, c, x[ 9], S12, 0x8b44f7af); /* 10 */
+	FF (c, d, a, b, x[10], S13, 0xffff5bb1); /* 11 */
+	FF (b, c, d, a, x[11], S14, 0x895cd7be); /* 12 */
+	FF (a, b, c, d, x[12], S11, 0x6b901122); /* 13 */
+	FF (d, a, b, c, x[13], S12, 0xfd987193); /* 14 */
+	FF (c, d, a, b, x[14], S13, 0xa679438e); /* 15 */
+	FF (b, c, d, a, x[15], S14, 0x49b40821); /* 16 */
+
+	/* Round 2 */
+	GG (a, b, c, d, x[ 1], S21, 0xf61e2562); /* 17 */
+	GG (d, a, b, c, x[ 6], S22, 0xc040b340); /* 18 */
+	GG (c, d, a, b, x[11], S23, 0x265e5a51); /* 19 */
+	GG (b, c, d, a, x[ 0], S24, 0xe9b6c7aa); /* 20 */
+	GG (a, b, c, d, x[ 5], S21, 0xd62f105d); /* 21 */
+	GG (d, a, b, c, x[10], S22,  0x2441453); /* 22 */
+	GG (c, d, a, b, x[15], S23, 0xd8a1e681); /* 23 */
+	GG (b, c, d, a, x[ 4], S24, 0xe7d3fbc8); /* 24 */
+	GG (a, b, c, d, x[ 9], S21, 0x21e1cde6); /* 25 */
+	GG (d, a, b, c, x[14], S22, 0xc33707d6); /* 26 */
+	GG (c, d, a, b, x[ 3], S23, 0xf4d50d87); /* 27 */
+	GG (b, c, d, a, x[ 8], S24, 0x455a14ed); /* 28 */
+	GG (a, b, c, d, x[13], S21, 0xa9e3e905); /* 29 */
+	GG (d, a, b, c, x[ 2], S22, 0xfcefa3f8); /* 30 */
+	GG (c, d, a, b, x[ 7], S23, 0x676f02d9); /* 31 */
+	GG (b, c, d, a, x[12], S24, 0x8d2a4c8a); /* 32 */
+
+	/* Round 3 */
+	HH (a, b, c, d, x[ 5], S31, 0xfffa3942); /* 33 */
+	HH (d, a, b, c, x[ 8], S32, 0x8771f681); /* 34 */
+	HH (c, d, a, b, x[11], S33, 0x6d9d6122); /* 35 */
+	HH (b, c, d, a, x[14], S34, 0xfde5380c); /* 36 */
+	HH (a, b, c, d, x[ 1], S31, 0xa4beea44); /* 37 */
+	HH (d, a, b, c, x[ 4], S32, 0x4bdecfa9); /* 38 */
+	HH (c, d, a, b, x[ 7], S33, 0xf6bb4b60); /* 39 */
+	HH (b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */
+	HH (a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */
+	HH (d, a, b, c, x[ 0], S32, 0xeaa127fa); /* 42 */
+	HH (c, d, a, b, x[ 3], S33, 0xd4ef3085); /* 43 */
+	HH (b, c, d, a, x[ 6], S34,  0x4881d05); /* 44 */
+	HH (a, b, c, d, x[ 9], S31, 0xd9d4d039); /* 45 */
+	HH (d, a, b, c, x[12], S32, 0xe6db99e5); /* 46 */
+	HH (c, d, a, b, x[15], S33, 0x1fa27cf8); /* 47 */
+	HH (b, c, d, a, x[ 2], S34, 0xc4ac5665); /* 48 */
+
+	/* Round 4 */
+	II (a, b, c, d, x[ 0], S41, 0xf4292244); /* 49 */
+	II (d, a, b, c, x[ 7], S42, 0x432aff97); /* 50 */
+	II (c, d, a, b, x[14], S43, 0xab9423a7); /* 51 */
+	II (b, c, d, a, x[ 5], S44, 0xfc93a039); /* 52 */
+	II (a, b, c, d, x[12], S41, 0x655b59c3); /* 53 */
+	II (d, a, b, c, x[ 3], S42, 0x8f0ccc92); /* 54 */
+	II (c, d, a, b, x[10], S43, 0xffeff47d); /* 55 */
+	II (b, c, d, a, x[ 1], S44, 0x85845dd1); /* 56 */
+	II (a, b, c, d, x[ 8], S41, 0x6fa87e4f); /* 57 */
+	II (d, a, b, c, x[15], S42, 0xfe2ce6e0); /* 58 */
+	II (c, d, a, b, x[ 6], S43, 0xa3014314); /* 59 */
+	II (b, c, d, a, x[13], S44, 0x4e0811a1); /* 60 */
+	II (a, b, c, d, x[ 4], S41, 0xf7537e82); /* 61 */
+	II (d, a, b, c, x[11], S42, 0xbd3af235); /* 62 */
+	II (c, d, a, b, x[ 2], S43, 0x2ad7d2bb); /* 63 */
+	II (b, c, d, a, x[ 9], S44, 0xeb86d391); /* 64 */
+
+	state[0] += a;
+	state[1] += b;
+	state[2] += c;
+	state[3] += d;
+
+	/* Zeroize sensitive information. */
+	ZEROIZE((POINTER)(void *)x, sizeof (x));
+}
diff -ru -ruN mtree/md5hl.c mtree-linux/md5hl.c
--- mtree/md5hl.c	1970-01-01 01:00:00.000000000 +0100
+++ mtree-linux/md5hl.c	2001-08-06 09:59:47.000000000 +0200
@@ -0,0 +1,126 @@
+/*	$NetBSD: md5hl.c,v 1.2 2001/07/09 21:43:21 hubertf Exp $	*/
+
+/*
+ * Written by Jason R. Thorpe <thorpej@netbsd.org>, April 29, 1997.
+ * Public domain.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <digest-types.h>
+
+#define	MDALGORITHM	MD5
+
+/* #include "namespace.h" */
+#include <md5.h>
+
+#ifndef _DIAGASSERT
+#define _DIAGASSERT(cond)	assert(cond)
+#endif
+
+/*	$NetBSD: md5hl.c,v 1.2 2001/07/09 21:43:21 hubertf Exp $	*/
+
+/*
+ * ----------------------------------------------------------------------------
+ * "THE BEER-WARE LICENSE" (Revision 42):
+ * <phk@login.dkuug.dk> wrote this file.  As long as you retain this notice you
+ * can do whatever you want with this stuff. If we meet some day, and you think
+ * this stuff is worth it, you can buy me a beer in return.   Poul-Henning Kamp
+ * ----------------------------------------------------------------------------
+ *
+ * from FreeBSD Id: mdXhl.c,v 1.8 1996/10/25 06:48:12 bde Exp
+ */
+
+/*
+ * Modifed April 29, 1997 by Jason R. Thorpe <thorpej@netbsd.org>
+ */
+
+#include <assert.h>
+#ifdef HAVE_FCNTL_H
+#include <fcntl.h>
+#endif
+#ifdef HAVE_ERRNO_H
+#include <errno.h>
+#endif
+#include <stdio.h>
+#include <stdlib.h>
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+
+#define	CONCAT(x,y)	__CONCAT(x,y)
+#define	MDNAME(x)	CONCAT(MDALGORITHM,x)
+
+char *
+MDNAME(End)(ctx, buf)
+	MDNAME(_CTX) *ctx;
+	char *buf;
+{
+	int i;
+	unsigned char digest[16];
+	static const char hex[]="0123456789abcdef";
+
+	_DIAGASSERT(ctx != 0);
+
+	if (buf == NULL)
+		buf = malloc(33);
+	if (buf == NULL)
+		return (NULL);
+
+	MDNAME(Final)(digest, ctx);
+
+	for (i = 0; i < 16; i++) {
+		buf[i+i] = hex[(u_int32_t)digest[i] >> 4];
+		buf[i+i+1] = hex[digest[i] & 0x0f];
+	}
+
+	buf[i+i] = '\0';
+	return (buf);
+}
+
+char *
+MDNAME(File)(filename, buf)
+	const char *filename;
+	char *buf;
+{
+	unsigned char buffer[BUFSIZ];
+	MDNAME(_CTX) ctx;
+	int f, i, j;
+
+	_DIAGASSERT(filename != 0);
+	/* buf may be NULL */
+
+	MDNAME(Init)(&ctx);
+	f = open(filename, O_RDONLY, 0666);
+	if (f < 0)
+		return NULL;
+
+	while ((i = read(f, buffer, sizeof(buffer))) > 0)
+		MDNAME(Update)(&ctx, buffer, (unsigned int)i);
+
+	j = errno;
+	close(f);
+	errno = j;
+
+	if (i < 0)
+		return NULL;
+
+	return (MDNAME(End)(&ctx, buf));
+}
+
+char *
+MDNAME(Data)(data, len, buf)
+	const unsigned char *data;
+	unsigned int len;
+	char *buf;
+{
+	MDNAME(_CTX) ctx;
+
+	_DIAGASSERT(data != 0);
+
+	MDNAME(Init)(&ctx);
+	MDNAME(Update)(&ctx, data, len);
+	return (MDNAME(End)(&ctx, buf));
+}
diff -ru -ruN mtree/misc.c mtree-linux/misc.c
--- mtree/misc.c	2005-03-29 13:44:17.000000000 +0200
+++ mtree-linux/misc.c	1998-12-06 20:07:53.000000000 +0100
@@ -1,3 +1,5 @@
+/*	$NetBSD: misc.c,v 1.8 1998/12/06 19:07:53 jwise Exp $	*/
+
 /*-
  * Copyright (c) 1991, 1993
  *	The Regents of the University of California.  All rights reserved.
@@ -10,7 +12,11 @@
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
  *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
  *
@@ -25,27 +31,26 @@
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
+ *
+ *	@(#)misc.c	8.1 (Berkeley) 6/6/93
  */
 
-#if 0
-#ifndef lint
-static char sccsid[] = "@(#)misc.c	8.1 (Berkeley) 6/6/93";
-#endif /*not lint */
-#endif
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/usr.sbin/mtree/misc.c,v 1.16 2005/03/29 11:44:17 tobez Exp $");
+#ifndef lint
+__RCSID("$NetBSD: misc.c,v 1.8 1998/12/06 19:07:53 jwise Exp $");
+#endif /* not lint */
 
 #include <sys/types.h>
 #include <sys/stat.h>
-#include <err.h>
 #include <fts.h>
 #include <stdio.h>
-#include <unistd.h>
 #include "mtree.h"
 #include "extern.h"
 
+extern int lineno;
+
 typedef struct _key {
-	const char *name;			/* key name */
+	char *name;			/* key name */
 	u_int val;			/* value */
 
 #define	NEEDVALUE	0x01
@@ -60,32 +65,23 @@
 	{"gname",	F_GNAME,	NEEDVALUE},
 	{"ignore",	F_IGN,		0},
 	{"link",	F_SLINK,	NEEDVALUE},
-#ifdef MD5
-	{"md5digest",	F_MD5,		NEEDVALUE},
-#endif
+	{"md5",		F_MD5,		NEEDVALUE},
 	{"mode",	F_MODE,		NEEDVALUE},
 	{"nlink",	F_NLINK,	NEEDVALUE},
-	{"nochange",	F_NOCHANGE,	0},
-#ifdef RMD160
-	{"ripemd160digest", F_RMD160,	NEEDVALUE},
-#endif
-#ifdef SHA1
-	{"sha1digest",	F_SHA1,		NEEDVALUE},
-#endif
-#ifdef SHA256
-	{"sha256digest",	F_SHA256,		NEEDVALUE},
-#endif
+	{"optional",	F_OPT,		0},
 	{"size",	F_SIZE,		NEEDVALUE},
 	{"time",	F_TIME,		NEEDVALUE},
 	{"type",	F_TYPE,		NEEDVALUE},
 	{"uid",		F_UID,		NEEDVALUE},
-	{"uname",	F_UNAME,	NEEDVALUE},
+	{"uname",	F_UNAME,	NEEDVALUE}
 };
 
-int keycompare(const void *, const void *);
+int keycompare __P((const void *, const void *));
 
 u_int
-parsekey(char *name, int *needvaluep)
+parsekey(name, needvaluep)
+	char *name;
+	int *needvaluep;
 {
 	KEY *k, tmp;
 
@@ -93,31 +89,49 @@
 	k = (KEY *)bsearch(&tmp, keylist, sizeof(keylist) / sizeof(KEY),
 	    sizeof(KEY), keycompare);
 	if (k == NULL)
-		errx(1, "line %d: unknown keyword %s", lineno, name);
+		mtree_err("unknown keyword %s", name);
 
 	if (needvaluep)
 		*needvaluep = k->flags & NEEDVALUE ? 1 : 0;
+
 	return (k->val);
 }
 
 int
-keycompare(const void *a, const void *b)
+keycompare(a, b)
+	const void *a, *b;
 {
-	return (strcmp(((const KEY *)a)->name, ((const KEY *)b)->name));
+	return (strcmp(((KEY *)a)->name, ((KEY *)b)->name));
 }
 
-char *
-flags_to_string(u_long fflags)
-{
-	char *string;
-
-	string = fflagstostr(fflags);
-	if (string != NULL && *string == '\0') {
-		free(string);
-		string = strdup("none");
-	}
-	if (string == NULL)
-		err(1, NULL);
+#if __STDC__
+#include <stdarg.h>
+#else
+#include <varargs.h>
+#endif
 
-	return string;
+void
+#if __STDC__
+mtree_err(const char *fmt, ...)
+#else
+mtree_err(fmt, va_alist)
+	char *fmt;
+        va_dcl
+#endif
+{
+	va_list ap;
+#if __STDC__
+	va_start(ap, fmt);
+#else
+	va_start(ap);
+#endif
+	(void)fprintf(stderr, "mtree: ");
+	(void)vfprintf(stderr, fmt, ap);
+	va_end(ap);
+	(void)fprintf(stderr, "\n");
+	if (lineno)
+		(void)fprintf(stderr,
+		    "mtree: failed at line %d of the specification\n", lineno);
+	exit(1);
+	/* NOTREACHED */
 }
diff -ru -ruN mtree/mtree.8 mtree-linux/mtree.8
--- mtree/mtree.8	2006-07-28 18:27:40.000000000 +0200
+++ mtree-linux/mtree.8	1999-11-07 21:23:01.000000000 +0100
@@ -1,3 +1,5 @@
+.\"	$NetBSD: mtree.8,v 1.12 1999/11/07 20:23:01 wennmach Exp $
+.\"
 .\" Copyright (c) 1989, 1990, 1993
 .\"	The Regents of the University of California.  All rights reserved.
 .\"
@@ -9,6 +11,10 @@
 .\" 2. Redistributions in binary form must reproduce the above copyright
 .\"    notice, this list of conditions and the following disclaimer in the
 .\"    documentation and/or other materials provided with the distribution.
+.\" 3. All advertising materials mentioning features or use of this software
+.\"    must display the following acknowledgement:
+.\"	This product includes software developed by the University of
+.\"	California, Berkeley and its contributors.
 .\" 4. Neither the name of the University nor the names of its contributors
 .\"    may be used to endorse or promote products derived from this software
 .\"    without specific prior written permission.
@@ -25,20 +31,19 @@
 .\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 .\" SUCH DAMAGE.
 .\"
-.\"     From: @(#)mtree.8	8.2 (Berkeley) 12/11/93
-.\" $FreeBSD: src/usr.sbin/mtree/mtree.8,v 1.52.2.2 2006/07/28 16:27:40 maxim Exp $
+.\"     @(#)mtree.8	8.2 (Berkeley) 12/11/93
 .\"
-.Dd July 03, 2006
+.Dd December 11, 1993
 .Dt MTREE 8
 .Os
 .Sh NAME
 .Nm mtree
 .Nd map a directory hierarchy
 .Sh SYNOPSIS
-.Nm
-.Op Fl LPUcdeinqruxw
+.Nm ""
+.Op Fl cderUux
 .Bk -words
-.Op Fl f Ar spec
+.Op Fl i | Fl m
 .Ek
 .Bk -words
 .Op Fl f Ar spec
@@ -55,122 +60,78 @@
 .Bk -words
 .Op Fl s Ar seed
 .Ek
-.Bk -words
-.Op Fl X Ar exclude-list
-.Ek
 .Sh DESCRIPTION
-The
+The utility
 .Nm
-utility compares the file hierarchy rooted in the current directory against a
+compares the file hierarchy rooted in the current directory against a
 specification read from the standard input.
 Messages are written to the standard output for any files whose
-characteristics do not match the specifications, or which are
+characteristics do not match the specification, or which are
 missing from either the file hierarchy or the specification.
 .Pp
 The options are as follows:
 .Bl -tag -width flag
-.It Fl L
-Follow all symbolic links in the file hierarchy.
-.It Fl P
-Do not follow symbolic links in the file hierarchy, instead consider
-the symbolic link itself in any comparisons.
-This is the default.
-.It Fl U
-Modify the owner, group, permissions, and modification time of existing
-files to match the specification and create any missing directories or
-symbolic links.
-User, group and permissions must all be specified for missing directories
-to be created.
-Corrected mismatches are not considered errors.
 .It Fl c
 Print a specification for the file hierarchy to the standard output.
 .It Fl d
 Ignore everything except directory type files.
 .It Fl e
-Do not complain about files that are in the file hierarchy, but not in the
+Don't complain about files that are in the file hierarchy, but not in the
 specification.
-.It Fl i
-Indent the output 4 spaces each time a directory level is descended when
-create a specification with the
-.Fl c
-option.
-This does not affect either the /set statements or the comment before each
-directory.
-It does however affect the comment before the close of each directory.
-.It Fl n
-Do not emit pathname comments when creating a specification.
-Normally
-a comment is emitted before each directory and before the close of that
-directory when using the
-.Fl c
-option.
-.It Fl q
-Quiet mode.
-Do not complain when a
-.Dq missing
-directory cannot be created because it already exists.
-This occurs when the directory is a symbolic link.
-.It Fl r
-Remove any files in the file hierarchy that are not described in the
-specification.
-.It Fl u
-Same as
-.Fl U
-except a status of 2 is returned if the file hierarchy did not match
-the specification.
-.It Fl w
-Make some errorconditions non-fatal warnings.
-.It Fl x
-Do not descend below mount points in the file hierarchy.
-.It Fl f Ar file
+.It Fl f
 Read the specification from
-.Ar file ,
+.Ar file  ,
 instead of from the standard input.
-.Pp
-If this option is specified twice, the two specifications are compared
-to each other rather than to the file hierarchy.
-The specifications be sorted like output generated using
-.Fl c .
-The output format in this case is somewhat remniscent of
-.Xr comm 1 ,
-having "in first spec only", "in second spec only", and "different"
-columns, prefixed by zero, one and two TAB characters respectively.
-Each entry in the "different" column occupies two lines, one from each specification.
-.It Fl K Ar keywords
-Add the specified (whitespace or comma separated)
-.Ar keywords
-to the current set of keywords.
-.It Fl k Ar keywords
+.It Fl i
+If specified, set the schg and/or sappnd flags.
+.It Fl K
+Add the specified (whitespace or comma separated) keywords to the current
+set of keywords.
+.It Fl k
 Use the ``type'' keyword plus the specified (whitespace or comma separated)
-.Ar keywords
-instead of the current set of keywords.
-.It Fl p Ar path
+keywords instead of the current set of keywords.
+.It Fl m
+If the schg and/or sappnd flags are specified, reset these flags. Note that
+this is only possible with securelevel less than 1 (i. e. in single user mode
+or while the system is running in insecure mode). See
+.Xr init 8
+for information on security levels.
+.It Fl p
 Use the file hierarchy rooted in
-.Ar path ,
+.Ar path  ,
 instead of the current directory.
-.It Fl s Ar seed
+.It Fl r
+Remove any files in the file hierarchy that are not described in the
+specification.
+.It Fl s
 Display a single checksum to the standard error output that represents all
 of the files for which the keyword
 .Cm cksum
 was specified.
 The checksum is seeded with the specified value.
-.It Fl X Ar exclude-list
-The specified file contains
-.Xr fnmatch 3
-patterns matching files to be excluded from
-the specification, one to a line.
-If the pattern contains a
-.Ql \&/
-character, it will be matched against entire pathnames (relative to
-the starting directory); otherwise,
-it will be matched against basenames only.
-No comments are allowed in
-the
-.Ar exclude-list
-file.
+.It Fl U
+Modify the owner, group, permissions, and flags of existing files to match
+the specification and create any missing directories.
+User, group, and permissions must all be specified for missing directories
+to be created.
+Note that unless the
+.Fl i
+option is given, the schg and sappnd flags will not be set, even if
+specified. If 
+.Fl m
+is given, these flags will be reset.
+Exit with a status of 0 on success, 1 if any error occurred;
+a mismatch is not considered to be an error if it was corrected.
+.It Fl u
+Same as
+.Fl U
+except a status of 2 is returned if the file hierarchy did not match 
+the specification.
+.It Fl x
+Don't descend below mount points in the file hierarchy.
 .El
 .Pp
-Specifications are mostly composed of ``keywords'', i.e., strings
+Specifications are mostly composed of ``keywords'', i.e. strings that
 that specify values relating to files.
 No keywords have default values, and if a keyword has no value set, no
 checks based on it are performed.
@@ -183,46 +144,33 @@
 .Xr cksum 1
 utility.
 .It Cm flags
-The file flags as a symbolic name.
-See
+The file flags as a symbolic name.  See
 .Xr chflags 1
-for information on these names.
-If no flags are to be set the string
+for information on these names.  If no flags are to be set the string
 .Dq none
 may be used to override the current default.
+Note that the schg and sappnd flags are treated specially (see the
+.Fl i
+and
+.Fl m
+options).
 .It Cm ignore
 Ignore any file hierarchy below this file.
 .It Cm gid
 The file group as a numeric value.
 .It Cm gname
 The file group as a symbolic name.
-.It Cm md5digest
-The MD5 message digest of the file.
-.It Cm sha1digest
-The
-.Tn FIPS
-160-1
-.Pq Dq Tn SHA-1
-message digest of the file.
-.It Cm sha256digest
-The
-.Tn FIPS
-180-2
-.Pq Dq Tn SHA-256
-message digest of the file.
-.It Cm ripemd160digest
-The
-.Tn RIPEMD160
-message digest of the file.
+.It Cm link
+The file the symbolic link is expected to reference.
+.It Cm md5
+The MD5 cryptographic checksum of the file.
 .It Cm mode
 The current file's permissions as a numeric (octal) or symbolic
 value.
 .It Cm nlink
 The number of hard links the file is expected to have.
-.It Cm nochange
-Make sure this file or directory exists but otherwise ignore all attributes.
 .It Cm optional
-The file is optional; do not complain about the file if it is
+The file is optional; don't complain about the file if it's
 not in the file hierarchy.
 .It Cm uid
 The file owner as a numeric value.
@@ -230,13 +178,11 @@
 The file owner as a symbolic name.
 .It Cm size
 The size, in bytes, of the file.
-.It Cm link
-The file the symbolic link is expected to reference.
 .It Cm time
 The last modification time of the file.
 .It Cm type
 The type of the file; may be set to any one of the following:
-.Pp
+.sp
 .Bl -tag -width Cm -compact
 .It Cm block
 block special device
@@ -258,10 +204,10 @@
 The default set of keywords are
 .Cm flags ,
 .Cm gid ,
+.Cm link ,
 .Cm mode ,
 .Cm nlink ,
 .Cm size ,
-.Cm link ,
 .Cm time ,
 and
 .Cm uid .
@@ -288,6 +234,12 @@
 characters (``['', ``]'', ``?'' or ``*''), in which case files
 in the hierarchy will be associated with the first pattern that
 they match.
+.Nm
+uses strvis(3) (in VIS_CSTYLE format) to encode file names containing
+non-printable characters. Whitespace characters are encoded as
+``\es'' (space), ``\et'' (tab), and ``\en'' (new line).
+``#'' characters in file names are escaped by a preceding backslash (``\e'')
+to distinguish them from comments.
 .Pp
 Each of the keyword/value pairs consist of a keyword, followed by an
 equals sign (``=''), followed by the keyword's value, without
@@ -300,7 +252,7 @@
 for in that directory hierarchy.
 Which brings us to the last type of line in a specification: a line
 containing only the string
-.Dq Pa ..\&
+.Dq Nm \&..
 causes the current directory
 path to ascend one level.
 .Pp
@@ -311,47 +263,37 @@
 .Nm
 utility exits with a status of 0 on success, 1 if any error occurred,
 and 2 if the file hierarchy did not match the specification.
-A status of 2 is converted to a status of 0 if the
-.Fl U
-option is used.
-.Sh FILES
-.Bl -tag -width /etc/mtree -compact
-.It Pa /etc/mtree
-system specification directory
-.El
-.Sh EXIT STATUS
-.Ex -std
 .Sh EXAMPLES
 To detect system binaries that have been ``trojan horsed'', it is recommended
 that
 .Nm
-.Fl K
-.Cm sha256digest
 be run on the file systems, and a copy of the results stored on a different
 machine, or, at least, in encrypted form.
-The output file itself should be digested using the
-.Xr sha256 1
-utility.
+The seed for the
+.Fl s
+option should not be an obvious value and the final checksum should not be
+stored on-line under any circumstances!
 Then, periodically,
 .Nm
-and
-.Xr sha256 1
-should be run against the on-line specifications.
+should be run against the on-line specifications and the final checksum
+compared with the previous value.
 While it is possible for the bad guys to change the on-line specifications
-to conform to their modified binaries, it is believed to be
-impractical for them to create a modified specification which has
-the same SHA-256 digest as the original.
+to conform to their modified binaries, it shouldn't be possible for them
+to make it produce the same final checksum value.
+If the final checksum value changes, the off-line copies of the specification
+can be used to detect which of the binaries have actually been modified.
 .Pp
 The
 .Fl d
 and
 .Fl u
 options can be used in combination to create directory hierarchies
-for distributions and other such things; the files in
-.Pa /etc/mtree
-were used to create almost all directories in this
-.Fx
-distribution.
+for distributions and other such things.
+.Sh FILES
+.Bl -tag -width /etc/mtree -compact
+.It Pa /etc/mtree
+system specification directory
+.El
 .Sh SEE ALSO
 .Xr chflags 1 ,
 .Xr chgrp 1 ,
@@ -359,33 +301,11 @@
 .Xr cksum 1 ,
 .Xr md5 1 ,
 .Xr stat 2 ,
+.Xr strvis 3 ,
 .Xr fts 3 ,
-.Xr md5 3 ,
 .Xr chown 8
 .Sh HISTORY
 The
 .Nm
 utility appeared in
 .Bx 4.3 Reno .
-The
-.Tn MD5
-digest capability was added in
-.Fx 2.1 ,
-in response to the widespread use of programs which can spoof
-.Xr cksum 1 .
-The
-.Tn SHA-1
-and
-.Tn RIPEMD160
-digests were added in
-.Fx 4.0 ,
-as new attacks have demonstrated weaknesses in
-.Tn MD5 .
-The
-.Tn SHA-256
-digest was added in
-.Fx 6.0 .
-Support for file flags was added in
-.Fx 4.0 ,
-and mostly comes from
-.Nx .
diff -ru -ruN mtree/mtree.c mtree-linux/mtree.c
--- mtree/mtree.c	2004-06-04 21:29:28.000000000 +0200
+++ mtree-linux/mtree.c	2001-08-05 14:28:50.000000000 +0200
@@ -1,3 +1,5 @@
+/*	$NetBSD: mtree.c,v 1.14 1999/02/11 15:32:24 mrg Exp $	*/
+
 /*-
  * Copyright (c) 1989, 1990, 1993
  *	The Regents of the University of California.  All rights reserved.
@@ -10,7 +12,11 @@
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
  *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
  *
@@ -27,52 +33,51 @@
  * SUCH DAMAGE.
  */
 
-#if 0
+#include <sys/cdefs.h>
 #ifndef lint
-static const char copyright[] =
-"@(#) Copyright (c) 1989, 1990, 1993\n\
-	The Regents of the University of California.  All rights reserved.\n";
+__COPYRIGHT("@(#) Copyright (c) 1989, 1990, 1993\n\
+	The Regents of the University of California.  All rights reserved.\n");
 #endif /* not lint */
 
 #ifndef lint
+#if 0
 static char sccsid[] = "@(#)mtree.c	8.1 (Berkeley) 6/6/93";
-#endif /* not lint */
+#else
+__RCSID("$NetBSD: mtree.c,v 1.14 1999/02/11 15:32:24 mrg Exp $");
 #endif
-#include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/usr.sbin/mtree/mtree.c,v 1.29 2004/06/04 19:29:28 ru Exp $");
+#endif /* not lint */
 
 #include <sys/param.h>
 #include <sys/stat.h>
-#include <err.h>
 #include <errno.h>
-#include <fts.h>
-#include <stdio.h>
 #include <unistd.h>
+#include <stdio.h>
+#include <fts.h>
 #include "mtree.h"
 #include "extern.h"
 
+extern int crc_total;
+
 int ftsoptions = FTS_PHYSICAL;
-int cflag, dflag, eflag, iflag, nflag, qflag, rflag, sflag, uflag, Uflag, wflag;
-u_int keys;
+int cflag, dflag, eflag, iflag, mflag, rflag, sflag, tflag, uflag, Uflag;
+int keys;
 char fullpath[MAXPATHLEN];
 
-static void usage(void);
+	int	main __P((int, char **));
+static	void	usage __P((void));
 
 int
-main(int argc, char *argv[])
+main(argc, argv)
+	int argc;
+	char *argv[];
 {
 	int ch;
 	char *dir, *p;
 	int status;
-	FILE *spec1, *spec2;
 
 	dir = NULL;
 	keys = KEYDEFAULT;
-	init_excludes();
-	spec1 = stdin;
-	spec2 = NULL;
-
-	while ((ch = getopt(argc, argv, "cdef:iK:k:LnPp:qrs:UuwxX:")) != -1)
+	while ((ch = getopt(argc, argv, "cdef:iK:k:mp:rs:tUux")) != -1)
 		switch((char)ch) {
 		case 'c':
 			cflag = 1;
@@ -84,16 +89,8 @@
 			eflag = 1;
 			break;
 		case 'f':
-			if (spec1 == stdin) {
-				spec1 = fopen(optarg, "r");
-				if (spec1 == NULL)
-					err(1, "%s", optarg);
-			} else if (spec2 == NULL) {
-				spec2 = fopen(optarg, "r");
-				if (spec2 == NULL)
-					err(1, "%s", optarg);
-			} else
-				usage();
+			if (!(freopen(optarg, "r", stdin)))
+				mtree_err("%s: %s", optarg, strerror(errno));
 			break;
 		case 'i':
 			iflag = 1;
@@ -109,48 +106,33 @@
 				if (*p != '\0')
 					keys |= parsekey(p, NULL);
 			break;
-		case 'L':
-			ftsoptions &= ~FTS_PHYSICAL;
-			ftsoptions |= FTS_LOGICAL;
-			break;
-		case 'n':
-			nflag = 1;
-			break;
-		case 'P':
-			ftsoptions &= ~FTS_LOGICAL;
-			ftsoptions |= FTS_PHYSICAL;
+		case 'm':
+			mflag = 1;
 			break;
 		case 'p':
 			dir = optarg;
 			break;
-		case 'q':
-			qflag = 1;
-			break;
 		case 'r':
 			rflag = 1;
 			break;
 		case 's':
 			sflag = 1;
-			crc_total = ~strtoul(optarg, &p, 0);
+			crc_total = ~strtol(optarg, &p, 0);
 			if (*p)
-				errx(1, "illegal seed value -- %s", optarg);
+				mtree_err("illegal seed value -- %s", optarg);
+			break;
+		case 't':
+			tflag = 1;
 			break;
 		case 'U':
-			Uflag = 1;
-			uflag = 1;
+			Uflag = uflag = 1;
 			break;
 		case 'u':
 			uflag = 1;
 			break;
-		case 'w':
-			wflag = 1;
-			break;
 		case 'x':
 			ftsoptions |= FTS_XDEV;
 			break;
-		case 'X':
-			read_excludes_file(optarg);
-			break;
 		case '?':
 		default:
 			usage();
@@ -162,29 +144,29 @@
 		usage();
 
 	if (dir && chdir(dir))
-		err(1, "%s", dir);
+		mtree_err("%s: %s", dir, strerror(errno));
+
+	if ((cflag || sflag) && !getcwd(fullpath, MAXPATHLEN))
+		mtree_err("%s", strerror(errno));
 
-	if ((cflag || sflag) && !getwd(fullpath))
-		errx(1, "%s", fullpath);
+	if (iflag == 1 && mflag == 1)
+		mtree_err("-i and -m flags are mutually exclusive");
 
 	if (cflag) {
 		cwalk();
 		exit(0);
 	}
-	if (spec2 != NULL)
-		status = mtree_specspec(spec1, spec2);
-	else
-		status = mtree_verifyspec(spec1);
+	status = verify();
 	if (Uflag & (status == MISMATCHEXIT))
 		status = 0;
 	exit(status);
 }
 
 static void
-usage(void)
+usage()
 {
 	(void)fprintf(stderr,
-"usage: mtree [-LPUcdeinqruxw] [-f spec] [-f spec] [-K key] [-k key] [-p path] [-s seed]\n"
-"\t[-X excludes]\n");
+"usage: mtree [-cderUux] [-i|-m] [-f spec] [-K key] [-k key] [-p path]"
+    " [-s seed]\n");
 	exit(1);
 }
diff -ru -ruN mtree/mtree.h mtree-linux/mtree.h
--- mtree/mtree.h	2006-07-28 18:27:40.000000000 +0200
+++ mtree-linux/mtree.h	1999-02-11 16:32:24.000000000 +0100
@@ -1,3 +1,5 @@
+/*	$NetBSD: mtree.h,v 1.11 1999/02/11 15:32:24 mrg Exp $	*/
+
 /*-
  * Copyright (c) 1990, 1993
  *	The Regents of the University of California.  All rights reserved.
@@ -10,7 +12,11 @@
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
  *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
  *
@@ -27,11 +33,14 @@
  * SUCH DAMAGE.
  *
  *	@(#)mtree.h	8.1 (Berkeley) 6/6/93
- * $FreeBSD: src/usr.sbin/mtree/mtree.h,v 1.7.2.1 2006/07/28 16:27:40 maxim Exp $
  */
 
+#ifndef _MTREE_H_
+#define _MTREE_H_
+
 #include <string.h>
 #include <stdlib.h>
+#include <sys/time.h>
 
 #define	KEYDEFAULT \
 	(F_GID | F_MODE | F_NLINK | F_SIZE | F_SLINK | F_TIME | F_UID | F_FLAGS)
@@ -44,10 +53,6 @@
 	off_t	st_size;			/* size */
 	struct timespec	st_mtimespec;		/* last modification time */
 	u_long	cksum;				/* check sum */
-	char	*md5digest;			/* MD5 digest */
-	char	*sha1digest;			/* SHA-1 digest */
-	char	*sha256digest;			/* SHA-256 digest */
-	char	*rmd160digest;			/* RIPEMD160 digest */
 	char	*slink;				/* symbolic link reference */
 	uid_t	st_uid;				/* uid */
 	gid_t	st_gid;				/* gid */
@@ -55,31 +60,27 @@
 	mode_t	st_mode;			/* mode */
 	u_long	st_flags;			/* flags */
 	nlink_t	st_nlink;			/* link count */
+	char	*md5sum;			/* md5 checksum */
 
-#define	F_CKSUM	0x0001				/* check sum */
-#define	F_DONE	0x0002				/* directory done */
-#define	F_GID	0x0004				/* gid */
-#define	F_GNAME	0x0008				/* group name */
-#define	F_IGN	0x0010				/* ignore */
-#define	F_MAGIC	0x0020				/* name has magic chars */
-#define	F_MODE	0x0040				/* mode */
-#define	F_NLINK	0x0080				/* number of links */
-#define	F_SIZE	0x0100				/* size */
-#define	F_SLINK	0x0200				/* link count */
-#define	F_TIME	0x0400				/* modification time */
-#define	F_TYPE	0x0800				/* file type */
-#define	F_UID	0x1000				/* uid */
-#define	F_UNAME	0x2000				/* user name */
-#define	F_VISIT	0x4000				/* file visited */
-#define F_MD5	0x8000				/* MD5 digest */
-#define F_NOCHANGE 0x10000			/* If owner/mode "wrong", do */
-						/* not change */
-#define	F_SHA1	0x20000				/* SHA-1 digest */
-#define	F_RMD160 0x40000			/* RIPEMD160 digest */
-#define	F_FLAGS	0x80000				/* file flags */
-#define	F_SHA256	0x100000				/* SHA-256 digest */
-#define F_OPT	0x200000			/* existence optional */
-	u_int	flags;				/* items set */
+#define	F_CKSUM	0x00000001			/* check sum */
+#define	F_DONE	0x00000002			/* directory done */
+#define	F_GID	0x00000004			/* gid */
+#define	F_GNAME	0x00000008			/* group name */
+#define	F_IGN	0x00000010			/* ignore */
+#define	F_MAGIC	0x00000020			/* name has magic chars */
+#define	F_MODE	0x00000040			/* mode */
+#define	F_NLINK	0x00000080			/* number of links */
+#define	F_OPT	0x00000100			/* existence optional */
+#define	F_SIZE	0x00000200			/* size */
+#define	F_SLINK	0x00000400			/* link count */
+#define	F_TIME	0x00000800			/* modification time */
+#define	F_TYPE	0x00001000			/* file type */
+#define	F_UID	0x00002000			/* uid */
+#define	F_UNAME	0x00004000			/* user name */
+#define	F_VISIT	0x00008000			/* file visited */
+#define	F_FLAGS	0x00010000			/* file flags */
+#define F_MD5	0x00020000			/* md5 check sum */
+	int	flags;				/* items set */
 
 #define	F_BLOCK	0x001				/* block special */
 #define	F_CHAR	0x002				/* char special */
@@ -88,7 +89,7 @@
 #define	F_FILE	0x010				/* regular file */
 #define	F_LINK	0x020				/* symbolic link */
 #define	F_SOCK	0x040				/* socket */
-	u_char	type;				/* file type */
+	int	type;				/* file type */
 
 	char	name[1];			/* file name (must be last) */
 } NODE;
@@ -96,3 +97,13 @@
 #define	RP(p)	\
 	((p)->fts_path[0] == '.' && (p)->fts_path[1] == '/' ? \
 	    (p)->fts_path + 2 : (p)->fts_path)
+
+#define UF_MASK ((UF_NODUMP | UF_IMMUTABLE |   \
+                  UF_APPEND | UF_OPAQUE)       \
+                    & UF_SETTABLE)              /* user settable flags */
+#define SF_MASK ((SF_ARCHIVED | SF_IMMUTABLE | \
+                  SF_APPEND) & SF_SETTABLE)     /* root settable flags */
+#define CH_MASK  (UF_MASK | SF_MASK)            /* all settable flags */
+#define SP_FLGS  (SF_IMMUTABLE | SF_APPEND)     /* special flags */
+
+#endif /* _MTREE_H_ */
diff -ru -ruN mtree/setmode.3 mtree-linux/setmode.3
--- mtree/setmode.3	1970-01-01 01:00:00.000000000 +0100
+++ mtree-linux/setmode.3	1999-05-26 17:39:36.000000000 +0200
@@ -0,0 +1,110 @@
+.\"	$NetBSD: setmode.3,v 1.11 1999/05/26 15:39:36 kleink Exp $
+.\"
+.\" Copyright (c) 1989, 1991, 1993
+.\"	The Regents of the University of California.  All rights reserved.
+.\"
+.\" Redistribution and use in source and binary forms, with or without
+.\" modification, are permitted provided that the following conditions
+.\" are met:
+.\" 1. Redistributions of source code must retain the above copyright
+.\"    notice, this list of conditions and the following disclaimer.
+.\" 2. Redistributions in binary form must reproduce the above copyright
+.\"    notice, this list of conditions and the following disclaimer in the
+.\"    documentation and/or other materials provided with the distribution.
+.\" 3. All advertising materials mentioning features or use of this software
+.\"    must display the following acknowledgement:
+.\"	This product includes software developed by the University of
+.\"	California, Berkeley and its contributors.
+.\" 4. Neither the name of the University nor the names of its contributors
+.\"    may be used to endorse or promote products derived from this software
+.\"    without specific prior written permission.
+.\"
+.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+.\" SUCH DAMAGE.
+.\"
+.\"     @(#)setmode.3	8.2 (Berkeley) 4/28/95
+.\"
+.Dd April 28, 1995
+.Dt SETMODE 3
+.Os
+.Sh NAME
+.Nm getmode ,
+.Nm setmode
+.Nd modify mode bits
+.Sh LIBRARY
+.Lb libc
+.Sh SYNOPSIS
+.Fd #include <unistd.h>
+.Ft mode_t
+.Fn getmode "const void *set" "mode_t mode"
+.Ft void *
+.Fn setmode "const char *mode_str"
+.Sh DESCRIPTION
+The
+.Fn getmode
+function
+returns a copy of the file permission bits
+.Fa mode
+as altered by the values pointed to by
+.Fa set .
+While only the mode bits are altered, other parts of the file mode
+may be examined.
+.Pp
+The
+.Fn setmode
+function
+takes an absolute (octal) or symbolic value, as described in
+.Xr chmod 1 ,
+as an argument
+and returns a pointer to mode values to be supplied to
+.Fn getmode .
+Because some of the symbolic values are relative to the file
+creation mask,
+.Fn setmode
+may call
+.Xr umask 2 .
+If this occurs, the file creation mask will be restored before
+.Fn setmode
+returns.
+If the calling program changes the value of its file creation mask
+after calling
+.Fn setmode ,
+.Fn setmode
+must be called again if
+.Fn getmode
+is to modify future file modes correctly.
+.Pp
+If the mode passed to
+.Fn setmode
+is invalid,
+.Fn setmode
+returns
+.Dv NULL . 
+.Sh ERRORS
+The
+.Fn setmode
+function
+may fail and set errno for any of the errors specified for the library
+routine
+.Xr malloc 3 .
+.Sh SEE ALSO
+.Xr chmod 1 ,
+.Xr stat 2 ,
+.Xr umask 2 ,
+.Xr malloc 3
+.Sh HISTORY
+The
+.Fn getmode
+and
+.Fn setmode
+functions first appeared in
+.Bx 4.4 .
diff -ru -ruN mtree/setmode.c mtree-linux/setmode.c
--- mtree/setmode.c	1970-01-01 01:00:00.000000000 +0100
+++ mtree-linux/setmode.c	2001-08-06 10:07:10.000000000 +0200
@@ -0,0 +1,491 @@
+/*	$NetBSD: setmode.c,v 1.28 2000/01/25 15:43:43 enami Exp $	*/
+
+/*
+ * Copyright (c) 1989, 1993, 1994
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * Dave Borman at Cray Research, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+#if defined(LIBC_SCCS) && !defined(lint)
+#if 0
+static char sccsid[] = "@(#)setmode.c	8.2 (Berkeley) 3/25/94";
+#else
+__RCSID("$NetBSD: setmode.c,v 1.28 2000/01/25 15:43:43 enami Exp $");
+#endif
+#endif /* LIBC_SCCS and not lint */
+
+/*#include "namespace.h"*/
+#include <sys/types.h>
+#include <sys/stat.h>
+
+#include <assert.h>
+#include <ctype.h>
+#include <errno.h>
+#include <signal.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#ifdef SETMODE_DEBUG
+#include <stdio.h>
+#endif
+
+#ifndef _DIAGASSERT
+#define _DIAGASSERT(cond)	assert(cond)
+#endif
+
+#ifndef S_ISTXT
+#define S_ISTXT 0001000
+#endif
+
+#ifdef __weak_alias
+__weak_alias(getmode,_getmode)
+__weak_alias(setmode,_setmode)
+#endif
+
+#define	SET_LEN	6		/* initial # of bitcmd struct to malloc */
+#define	SET_LEN_INCR 4		/* # of bitcmd structs to add as needed */
+
+typedef struct bitcmd {
+	char	cmd;
+	char	cmd2;
+	mode_t	bits;
+} BITCMD;
+
+#define	CMD2_CLR	0x01
+#define	CMD2_SET	0x02
+#define	CMD2_GBITS	0x04
+#define	CMD2_OBITS	0x08
+#define	CMD2_UBITS	0x10
+
+static BITCMD	*addcmd __P((BITCMD *, int, int, int, u_int));
+static void	 compress_mode __P((BITCMD *));
+#ifdef SETMODE_DEBUG
+static void	 dumpmode __P((BITCMD *));
+#endif
+
+/*
+ * Given the old mode and an array of bitcmd structures, apply the operations
+ * described in the bitcmd structures to the old mode, and return the new mode.
+ * Note that there is no '=' command; a strict assignment is just a '-' (clear
+ * bits) followed by a '+' (set bits).
+ */
+mode_t
+getmode(bbox, omode)
+	const void *bbox;
+	mode_t omode;
+{
+	const BITCMD *set;
+	mode_t clrval, newmode, value;
+
+	_DIAGASSERT(bbox != NULL);
+
+	set = (const BITCMD *)bbox;
+	newmode = omode;
+	for (value = 0;; set++)
+		switch(set->cmd) {
+		/*
+		 * When copying the user, group or other bits around, we "know"
+		 * where the bits are in the mode so that we can do shifts to
+		 * copy them around.  If we don't use shifts, it gets real
+		 * grundgy with lots of single bit checks and bit sets.
+		 */
+		case 'u':
+			value = (newmode & S_IRWXU) >> 6;
+			goto common;
+
+		case 'g':
+			value = (newmode & S_IRWXG) >> 3;
+			goto common;
+
+		case 'o':
+			value = newmode & S_IRWXO;
+common:			if (set->cmd2 & CMD2_CLR) {
+				clrval =
+				    (set->cmd2 & CMD2_SET) ?  S_IRWXO : value;
+				if (set->cmd2 & CMD2_UBITS)
+					newmode &= ~((clrval<<6) & set->bits);
+				if (set->cmd2 & CMD2_GBITS)
+					newmode &= ~((clrval<<3) & set->bits);
+				if (set->cmd2 & CMD2_OBITS)
+					newmode &= ~(clrval & set->bits);
+			}
+			if (set->cmd2 & CMD2_SET) {
+				if (set->cmd2 & CMD2_UBITS)
+					newmode |= (value<<6) & set->bits;
+				if (set->cmd2 & CMD2_GBITS)
+					newmode |= (value<<3) & set->bits;
+				if (set->cmd2 & CMD2_OBITS)
+					newmode |= value & set->bits;
+			}
+			break;
+
+		case '+':
+			newmode |= set->bits;
+			break;
+
+		case '-':
+			newmode &= ~set->bits;
+			break;
+
+		case 'X':
+			if (omode & (S_IFDIR|S_IXUSR|S_IXGRP|S_IXOTH))
+				newmode |= set->bits;
+			break;
+
+		case '\0':
+		default:
+#ifdef SETMODE_DEBUG
+			(void)printf("getmode:%04o -> %04o\n", omode, newmode);
+#endif
+			return (newmode);
+		}
+}
+
+#define	ADDCMD(a, b, c, d) do {						\
+	if (set >= endset) {						\
+		BITCMD *newset;						\
+		setlen += SET_LEN_INCR;					\
+		newset = realloc(saveset, sizeof(BITCMD) * setlen);	\
+		if (newset == NULL) {					\
+			free(saveset);					\
+			return (NULL);					\
+		}							\
+		set = newset + (set - saveset);				\
+		saveset = newset;					\
+		endset = newset + (setlen - 2);				\
+	}								\
+	set = addcmd(set, (a), (b), (c), (d));				\
+} while (/*CONSTCOND*/0)
+
+#define	STANDARD_BITS	(S_ISUID|S_ISGID|S_IRWXU|S_IRWXG|S_IRWXO)
+
+void *
+setmode(p)
+	const char *p;
+{
+	int perm, who;
+	char op, *ep;
+	BITCMD *set, *saveset, *endset;
+	sigset_t sigset, sigoset;
+	mode_t mask;
+	int equalopdone = 0;	/* pacify gcc */
+	int permXbits, setlen;
+
+	if (!*p)
+		return (NULL);
+
+	/*
+	 * Get a copy of the mask for the permissions that are mask relative.
+	 * Flip the bits, we want what's not set.  Since it's possible that
+	 * the caller is opening files inside a signal handler, protect them
+	 * as best we can.
+	 */
+	sigfillset(&sigset);
+	(void)sigprocmask(SIG_BLOCK, &sigset, &sigoset);
+	(void)umask(mask = umask(0));
+	mask = ~mask;
+	(void)sigprocmask(SIG_SETMASK, &sigoset, NULL);
+
+	setlen = SET_LEN + 2;
+	
+	if ((set = malloc((u_int)(sizeof(BITCMD) * setlen))) == NULL)
+		return (NULL);
+	saveset = set;
+	endset = set + (setlen - 2);
+
+	/*
+	 * If an absolute number, get it and return; disallow non-octal digits
+	 * or illegal bits.
+	 */
+	if (isdigit((unsigned char)*p)) {
+		perm = (mode_t)strtol(p, &ep, 8);
+		if (*ep || perm & ~(STANDARD_BITS|S_ISTXT)) {
+			free(saveset);
+			return (NULL);
+		}
+		ADDCMD('=', (STANDARD_BITS|S_ISTXT), perm, mask);
+		set->cmd = 0;
+		return (saveset);
+	}
+
+	/*
+	 * Build list of structures to set/clear/copy bits as described by
+	 * each clause of the symbolic mode.
+	 */
+	for (;;) {
+		/* First, find out which bits might be modified. */
+		for (who = 0;; ++p) {
+			switch (*p) {
+			case 'a':
+				who |= STANDARD_BITS;
+				break;
+			case 'u':
+				who |= S_ISUID|S_IRWXU;
+				break;
+			case 'g':
+				who |= S_ISGID|S_IRWXG;
+				break;
+			case 'o':
+				who |= S_IRWXO;
+				break;
+			default:
+				goto getop;
+			}
+		}
+
+getop:		if ((op = *p++) != '+' && op != '-' && op != '=') {
+			free(saveset);
+			return (NULL);
+		}
+		if (op == '=')
+			equalopdone = 0;
+
+		who &= ~S_ISTXT;
+		for (perm = 0, permXbits = 0;; ++p) {
+			switch (*p) {
+			case 'r':
+				perm |= S_IRUSR|S_IRGRP|S_IROTH;
+				break;
+			case 's':
+				/*
+				 * If specific bits where requested and 
+				 * only "other" bits ignore set-id. 
+				 */
+				if (who == 0 || (who & ~S_IRWXO))
+					perm |= S_ISUID|S_ISGID;
+				break;
+			case 't':
+				/*
+				 * If specific bits where requested and 
+				 * only "other" bits ignore set-id. 
+				 */
+				if (who == 0 || (who & ~S_IRWXO)) {
+					who |= S_ISTXT;
+					perm |= S_ISTXT;
+				}
+				break;
+			case 'w':
+				perm |= S_IWUSR|S_IWGRP|S_IWOTH;
+				break;
+			case 'X':
+				permXbits = S_IXUSR|S_IXGRP|S_IXOTH;
+				break;
+			case 'x':
+				perm |= S_IXUSR|S_IXGRP|S_IXOTH;
+				break;
+			case 'u':
+			case 'g':
+			case 'o':
+				/*
+				 * When ever we hit 'u', 'g', or 'o', we have
+				 * to flush out any partial mode that we have,
+				 * and then do the copying of the mode bits.
+				 */
+				if (perm) {
+					ADDCMD(op, who, perm, mask);
+					perm = 0;
+				}
+				if (op == '=')
+					equalopdone = 1;
+				if (op == '+' && permXbits) {
+					ADDCMD('X', who, permXbits, mask);
+					permXbits = 0;
+				}
+				ADDCMD(*p, who, op, mask);
+				break;
+
+			default:
+				/*
+				 * Add any permissions that we haven't already
+				 * done.
+				 */
+				if (perm || (op == '=' && !equalopdone)) {
+					if (op == '=')
+						equalopdone = 1;
+					ADDCMD(op, who, perm, mask);
+					perm = 0;
+				}
+				if (permXbits) {
+					ADDCMD('X', who, permXbits, mask);
+					permXbits = 0;
+				}
+				goto apply;
+			}
+		}
+
+apply:		if (!*p)
+			break;
+		if (*p != ',')
+			goto getop;
+		++p;
+	}
+	set->cmd = 0;
+#ifdef SETMODE_DEBUG
+	(void)printf("Before compress_mode()\n");
+	dumpmode(saveset);
+#endif
+	compress_mode(saveset);
+#ifdef SETMODE_DEBUG
+	(void)printf("After compress_mode()\n");
+	dumpmode(saveset);
+#endif
+	return (saveset);
+}
+
+static BITCMD *
+addcmd(set, op, who, oparg, mask)
+	BITCMD *set;
+	int oparg, who;
+	int op;
+	u_int mask;
+{
+
+	_DIAGASSERT(set != NULL);
+
+	switch (op) {
+	case '=':
+		set->cmd = '-';
+		set->bits = who ? who : STANDARD_BITS;
+		set++;
+
+		op = '+';
+		/* FALLTHROUGH */
+	case '+':
+	case '-':
+	case 'X':
+		set->cmd = op;
+		set->bits = (who ? who : mask) & oparg;
+		break;
+
+	case 'u':
+	case 'g':
+	case 'o':
+		set->cmd = op;
+		if (who) {
+			set->cmd2 = ((who & S_IRUSR) ? CMD2_UBITS : 0) |
+				    ((who & S_IRGRP) ? CMD2_GBITS : 0) |
+				    ((who & S_IROTH) ? CMD2_OBITS : 0);
+			set->bits = (mode_t)~0;
+		} else {
+			set->cmd2 = CMD2_UBITS | CMD2_GBITS | CMD2_OBITS;
+			set->bits = mask;
+		}
+	
+		if (oparg == '+')
+			set->cmd2 |= CMD2_SET;
+		else if (oparg == '-')
+			set->cmd2 |= CMD2_CLR;
+		else if (oparg == '=')
+			set->cmd2 |= CMD2_SET|CMD2_CLR;
+		break;
+	}
+	return (set + 1);
+}
+
+#ifdef SETMODE_DEBUG
+static void
+dumpmode(set)
+	BITCMD *set;
+{
+
+	_DIAGASSERT(set != NULL);
+
+	for (; set->cmd; ++set)
+		(void)printf("cmd: '%c' bits %04o%s%s%s%s%s%s\n",
+		    set->cmd, set->bits, set->cmd2 ? " cmd2:" : "",
+		    set->cmd2 & CMD2_CLR ? " CLR" : "",
+		    set->cmd2 & CMD2_SET ? " SET" : "",
+		    set->cmd2 & CMD2_UBITS ? " UBITS" : "",
+		    set->cmd2 & CMD2_GBITS ? " GBITS" : "",
+		    set->cmd2 & CMD2_OBITS ? " OBITS" : "");
+}
+#endif
+
+/*
+ * Given an array of bitcmd structures, compress by compacting consecutive
+ * '+', '-' and 'X' commands into at most 3 commands, one of each.  The 'u',
+ * 'g' and 'o' commands continue to be separate.  They could probably be 
+ * compacted, but it's not worth the effort.
+ */
+static void
+compress_mode(set)
+	BITCMD *set;
+{
+	BITCMD *nset;
+	int setbits, clrbits, Xbits, op;
+
+	_DIAGASSERT(set != NULL);
+
+	for (nset = set;;) {
+		/* Copy over any 'u', 'g' and 'o' commands. */
+		while ((op = nset->cmd) != '+' && op != '-' && op != 'X') {
+			*set++ = *nset++;
+			if (!op)
+				return;
+		}
+
+		for (setbits = clrbits = Xbits = 0;; nset++) {
+			if ((op = nset->cmd) == '-') {
+				clrbits |= nset->bits;
+				setbits &= ~nset->bits;
+				Xbits &= ~nset->bits;
+			} else if (op == '+') {
+				setbits |= nset->bits;
+				clrbits &= ~nset->bits;
+				Xbits &= ~nset->bits;
+			} else if (op == 'X')
+				Xbits |= nset->bits & ~setbits;
+			else
+				break;
+		}
+		if (clrbits) {
+			set->cmd = '-';
+			set->cmd2 = 0;
+			set->bits = clrbits;
+			set++;
+		}
+		if (setbits) {
+			set->cmd = '+';
+			set->cmd2 = 0;
+			set->bits = setbits;
+			set++;
+		}
+		if (Xbits) {
+			set->cmd = 'X';
+			set->cmd2 = 0;
+			set->bits = Xbits;
+			set++;
+		}
+	}
+}
diff -ru -ruN mtree/setmode.c.orig mtree-linux/setmode.c.orig
--- mtree/setmode.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ mtree-linux/setmode.c.orig	2000-01-25 16:43:43.000000000 +0100
@@ -0,0 +1,483 @@
+/*	$NetBSD: setmode.c,v 1.28 2000/01/25 15:43:43 enami Exp $	*/
+
+/*
+ * Copyright (c) 1989, 1993, 1994
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * Dave Borman at Cray Research, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+#if defined(LIBC_SCCS) && !defined(lint)
+#if 0
+static char sccsid[] = "@(#)setmode.c	8.2 (Berkeley) 3/25/94";
+#else
+__RCSID("$NetBSD: setmode.c,v 1.28 2000/01/25 15:43:43 enami Exp $");
+#endif
+#endif /* LIBC_SCCS and not lint */
+
+#include "namespace.h"
+#include <sys/types.h>
+#include <sys/stat.h>
+
+#include <assert.h>
+#include <ctype.h>
+#include <errno.h>
+#include <signal.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#ifdef SETMODE_DEBUG
+#include <stdio.h>
+#endif
+
+#ifdef __weak_alias
+__weak_alias(getmode,_getmode)
+__weak_alias(setmode,_setmode)
+#endif
+
+#define	SET_LEN	6		/* initial # of bitcmd struct to malloc */
+#define	SET_LEN_INCR 4		/* # of bitcmd structs to add as needed */
+
+typedef struct bitcmd {
+	char	cmd;
+	char	cmd2;
+	mode_t	bits;
+} BITCMD;
+
+#define	CMD2_CLR	0x01
+#define	CMD2_SET	0x02
+#define	CMD2_GBITS	0x04
+#define	CMD2_OBITS	0x08
+#define	CMD2_UBITS	0x10
+
+static BITCMD	*addcmd __P((BITCMD *, int, int, int, u_int));
+static void	 compress_mode __P((BITCMD *));
+#ifdef SETMODE_DEBUG
+static void	 dumpmode __P((BITCMD *));
+#endif
+
+/*
+ * Given the old mode and an array of bitcmd structures, apply the operations
+ * described in the bitcmd structures to the old mode, and return the new mode.
+ * Note that there is no '=' command; a strict assignment is just a '-' (clear
+ * bits) followed by a '+' (set bits).
+ */
+mode_t
+getmode(bbox, omode)
+	const void *bbox;
+	mode_t omode;
+{
+	const BITCMD *set;
+	mode_t clrval, newmode, value;
+
+	_DIAGASSERT(bbox != NULL);
+
+	set = (const BITCMD *)bbox;
+	newmode = omode;
+	for (value = 0;; set++)
+		switch(set->cmd) {
+		/*
+		 * When copying the user, group or other bits around, we "know"
+		 * where the bits are in the mode so that we can do shifts to
+		 * copy them around.  If we don't use shifts, it gets real
+		 * grundgy with lots of single bit checks and bit sets.
+		 */
+		case 'u':
+			value = (newmode & S_IRWXU) >> 6;
+			goto common;
+
+		case 'g':
+			value = (newmode & S_IRWXG) >> 3;
+			goto common;
+
+		case 'o':
+			value = newmode & S_IRWXO;
+common:			if (set->cmd2 & CMD2_CLR) {
+				clrval =
+				    (set->cmd2 & CMD2_SET) ?  S_IRWXO : value;
+				if (set->cmd2 & CMD2_UBITS)
+					newmode &= ~((clrval<<6) & set->bits);
+				if (set->cmd2 & CMD2_GBITS)
+					newmode &= ~((clrval<<3) & set->bits);
+				if (set->cmd2 & CMD2_OBITS)
+					newmode &= ~(clrval & set->bits);
+			}
+			if (set->cmd2 & CMD2_SET) {
+				if (set->cmd2 & CMD2_UBITS)
+					newmode |= (value<<6) & set->bits;
+				if (set->cmd2 & CMD2_GBITS)
+					newmode |= (value<<3) & set->bits;
+				if (set->cmd2 & CMD2_OBITS)
+					newmode |= value & set->bits;
+			}
+			break;
+
+		case '+':
+			newmode |= set->bits;
+			break;
+
+		case '-':
+			newmode &= ~set->bits;
+			break;
+
+		case 'X':
+			if (omode & (S_IFDIR|S_IXUSR|S_IXGRP|S_IXOTH))
+				newmode |= set->bits;
+			break;
+
+		case '\0':
+		default:
+#ifdef SETMODE_DEBUG
+			(void)printf("getmode:%04o -> %04o\n", omode, newmode);
+#endif
+			return (newmode);
+		}
+}
+
+#define	ADDCMD(a, b, c, d) do {						\
+	if (set >= endset) {						\
+		BITCMD *newset;						\
+		setlen += SET_LEN_INCR;					\
+		newset = realloc(saveset, sizeof(BITCMD) * setlen);	\
+		if (newset == NULL) {					\
+			free(saveset);					\
+			return (NULL);					\
+		}							\
+		set = newset + (set - saveset);				\
+		saveset = newset;					\
+		endset = newset + (setlen - 2);				\
+	}								\
+	set = addcmd(set, (a), (b), (c), (d));				\
+} while (/*CONSTCOND*/0)
+
+#define	STANDARD_BITS	(S_ISUID|S_ISGID|S_IRWXU|S_IRWXG|S_IRWXO)
+
+void *
+setmode(p)
+	const char *p;
+{
+	int perm, who;
+	char op, *ep;
+	BITCMD *set, *saveset, *endset;
+	sigset_t sigset, sigoset;
+	mode_t mask;
+	int equalopdone = 0;	/* pacify gcc */
+	int permXbits, setlen;
+
+	if (!*p)
+		return (NULL);
+
+	/*
+	 * Get a copy of the mask for the permissions that are mask relative.
+	 * Flip the bits, we want what's not set.  Since it's possible that
+	 * the caller is opening files inside a signal handler, protect them
+	 * as best we can.
+	 */
+	sigfillset(&sigset);
+	(void)sigprocmask(SIG_BLOCK, &sigset, &sigoset);
+	(void)umask(mask = umask(0));
+	mask = ~mask;
+	(void)sigprocmask(SIG_SETMASK, &sigoset, NULL);
+
+	setlen = SET_LEN + 2;
+	
+	if ((set = malloc((u_int)(sizeof(BITCMD) * setlen))) == NULL)
+		return (NULL);
+	saveset = set;
+	endset = set + (setlen - 2);
+
+	/*
+	 * If an absolute number, get it and return; disallow non-octal digits
+	 * or illegal bits.
+	 */
+	if (isdigit((unsigned char)*p)) {
+		perm = (mode_t)strtol(p, &ep, 8);
+		if (*ep || perm & ~(STANDARD_BITS|S_ISTXT)) {
+			free(saveset);
+			return (NULL);
+		}
+		ADDCMD('=', (STANDARD_BITS|S_ISTXT), perm, mask);
+		set->cmd = 0;
+		return (saveset);
+	}
+
+	/*
+	 * Build list of structures to set/clear/copy bits as described by
+	 * each clause of the symbolic mode.
+	 */
+	for (;;) {
+		/* First, find out which bits might be modified. */
+		for (who = 0;; ++p) {
+			switch (*p) {
+			case 'a':
+				who |= STANDARD_BITS;
+				break;
+			case 'u':
+				who |= S_ISUID|S_IRWXU;
+				break;
+			case 'g':
+				who |= S_ISGID|S_IRWXG;
+				break;
+			case 'o':
+				who |= S_IRWXO;
+				break;
+			default:
+				goto getop;
+			}
+		}
+
+getop:		if ((op = *p++) != '+' && op != '-' && op != '=') {
+			free(saveset);
+			return (NULL);
+		}
+		if (op == '=')
+			equalopdone = 0;
+
+		who &= ~S_ISTXT;
+		for (perm = 0, permXbits = 0;; ++p) {
+			switch (*p) {
+			case 'r':
+				perm |= S_IRUSR|S_IRGRP|S_IROTH;
+				break;
+			case 's':
+				/*
+				 * If specific bits where requested and 
+				 * only "other" bits ignore set-id. 
+				 */
+				if (who == 0 || (who & ~S_IRWXO))
+					perm |= S_ISUID|S_ISGID;
+				break;
+			case 't':
+				/*
+				 * If specific bits where requested and 
+				 * only "other" bits ignore set-id. 
+				 */
+				if (who == 0 || (who & ~S_IRWXO)) {
+					who |= S_ISTXT;
+					perm |= S_ISTXT;
+				}
+				break;
+			case 'w':
+				perm |= S_IWUSR|S_IWGRP|S_IWOTH;
+				break;
+			case 'X':
+				permXbits = S_IXUSR|S_IXGRP|S_IXOTH;
+				break;
+			case 'x':
+				perm |= S_IXUSR|S_IXGRP|S_IXOTH;
+				break;
+			case 'u':
+			case 'g':
+			case 'o':
+				/*
+				 * When ever we hit 'u', 'g', or 'o', we have
+				 * to flush out any partial mode that we have,
+				 * and then do the copying of the mode bits.
+				 */
+				if (perm) {
+					ADDCMD(op, who, perm, mask);
+					perm = 0;
+				}
+				if (op == '=')
+					equalopdone = 1;
+				if (op == '+' && permXbits) {
+					ADDCMD('X', who, permXbits, mask);
+					permXbits = 0;
+				}
+				ADDCMD(*p, who, op, mask);
+				break;
+
+			default:
+				/*
+				 * Add any permissions that we haven't already
+				 * done.
+				 */
+				if (perm || (op == '=' && !equalopdone)) {
+					if (op == '=')
+						equalopdone = 1;
+					ADDCMD(op, who, perm, mask);
+					perm = 0;
+				}
+				if (permXbits) {
+					ADDCMD('X', who, permXbits, mask);
+					permXbits = 0;
+				}
+				goto apply;
+			}
+		}
+
+apply:		if (!*p)
+			break;
+		if (*p != ',')
+			goto getop;
+		++p;
+	}
+	set->cmd = 0;
+#ifdef SETMODE_DEBUG
+	(void)printf("Before compress_mode()\n");
+	dumpmode(saveset);
+#endif
+	compress_mode(saveset);
+#ifdef SETMODE_DEBUG
+	(void)printf("After compress_mode()\n");
+	dumpmode(saveset);
+#endif
+	return (saveset);
+}
+
+static BITCMD *
+addcmd(set, op, who, oparg, mask)
+	BITCMD *set;
+	int oparg, who;
+	int op;
+	u_int mask;
+{
+
+	_DIAGASSERT(set != NULL);
+
+	switch (op) {
+	case '=':
+		set->cmd = '-';
+		set->bits = who ? who : STANDARD_BITS;
+		set++;
+
+		op = '+';
+		/* FALLTHROUGH */
+	case '+':
+	case '-':
+	case 'X':
+		set->cmd = op;
+		set->bits = (who ? who : mask) & oparg;
+		break;
+
+	case 'u':
+	case 'g':
+	case 'o':
+		set->cmd = op;
+		if (who) {
+			set->cmd2 = ((who & S_IRUSR) ? CMD2_UBITS : 0) |
+				    ((who & S_IRGRP) ? CMD2_GBITS : 0) |
+				    ((who & S_IROTH) ? CMD2_OBITS : 0);
+			set->bits = (mode_t)~0;
+		} else {
+			set->cmd2 = CMD2_UBITS | CMD2_GBITS | CMD2_OBITS;
+			set->bits = mask;
+		}
+	
+		if (oparg == '+')
+			set->cmd2 |= CMD2_SET;
+		else if (oparg == '-')
+			set->cmd2 |= CMD2_CLR;
+		else if (oparg == '=')
+			set->cmd2 |= CMD2_SET|CMD2_CLR;
+		break;
+	}
+	return (set + 1);
+}
+
+#ifdef SETMODE_DEBUG
+static void
+dumpmode(set)
+	BITCMD *set;
+{
+
+	_DIAGASSERT(set != NULL);
+
+	for (; set->cmd; ++set)
+		(void)printf("cmd: '%c' bits %04o%s%s%s%s%s%s\n",
+		    set->cmd, set->bits, set->cmd2 ? " cmd2:" : "",
+		    set->cmd2 & CMD2_CLR ? " CLR" : "",
+		    set->cmd2 & CMD2_SET ? " SET" : "",
+		    set->cmd2 & CMD2_UBITS ? " UBITS" : "",
+		    set->cmd2 & CMD2_GBITS ? " GBITS" : "",
+		    set->cmd2 & CMD2_OBITS ? " OBITS" : "");
+}
+#endif
+
+/*
+ * Given an array of bitcmd structures, compress by compacting consecutive
+ * '+', '-' and 'X' commands into at most 3 commands, one of each.  The 'u',
+ * 'g' and 'o' commands continue to be separate.  They could probably be 
+ * compacted, but it's not worth the effort.
+ */
+static void
+compress_mode(set)
+	BITCMD *set;
+{
+	BITCMD *nset;
+	int setbits, clrbits, Xbits, op;
+
+	_DIAGASSERT(set != NULL);
+
+	for (nset = set;;) {
+		/* Copy over any 'u', 'g' and 'o' commands. */
+		while ((op = nset->cmd) != '+' && op != '-' && op != 'X') {
+			*set++ = *nset++;
+			if (!op)
+				return;
+		}
+
+		for (setbits = clrbits = Xbits = 0;; nset++) {
+			if ((op = nset->cmd) == '-') {
+				clrbits |= nset->bits;
+				setbits &= ~nset->bits;
+				Xbits &= ~nset->bits;
+			} else if (op == '+') {
+				setbits |= nset->bits;
+				clrbits &= ~nset->bits;
+				Xbits &= ~nset->bits;
+			} else if (op == 'X')
+				Xbits |= nset->bits & ~setbits;
+			else
+				break;
+		}
+		if (clrbits) {
+			set->cmd = '-';
+			set->cmd2 = 0;
+			set->bits = clrbits;
+			set++;
+		}
+		if (setbits) {
+			set->cmd = '+';
+			set->cmd2 = 0;
+			set->bits = setbits;
+			set++;
+		}
+		if (Xbits) {
+			set->cmd = 'X';
+			set->cmd2 = 0;
+			set->bits = Xbits;
+			set++;
+		}
+	}
+}
diff -ru -ruN mtree/spec.c mtree-linux/spec.c
--- mtree/spec.c	2006-07-28 18:27:40.000000000 +0200
+++ mtree-linux/spec.c	2001-08-06 10:15:28.000000000 +0200
@@ -1,3 +1,5 @@
+/*	$NetBSD: spec.c,v 1.18 1999/12/01 22:14:46 wennmach Exp $	*/
+
 /*-
  * Copyright (c) 1989, 1993
  *	The Regents of the University of California.  All rights reserved.
@@ -10,7 +12,11 @@
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
  *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
  *
@@ -27,35 +33,37 @@
  * SUCH DAMAGE.
  */
 
-#if 0
+#include <sys/cdefs.h>
 #ifndef lint
-static char sccsid[] = "@(#)spec.c	8.1 (Berkeley) 6/6/93";
-#endif /* not lint */
+#if 0
+static char sccsid[] = "@(#)spec.c	8.2 (Berkeley) 4/28/95";
+#else
+__RCSID("$NetBSD: spec.c,v 1.18 1999/12/01 22:14:46 wennmach Exp $");
 #endif
-#include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/usr.sbin/mtree/spec.c,v 1.22.2.1 2006/07/28 16:27:40 maxim Exp $");
+#endif /* not lint */
 
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <ctype.h>
-#include <err.h>
 #include <errno.h>
 #include <fts.h>
 #include <grp.h>
 #include <pwd.h>
 #include <stdio.h>
+#include <string.h>
 #include <unistd.h>
 #include <vis.h>
+
 #include "mtree.h"
 #include "extern.h"
 
 int lineno;				/* Current spec line number. */
 
-static void	 set(char *, NODE *);
-static void	 unset(char *, NODE *);
+static void	 set __P((char *, NODE *));
+static void	 unset __P((char *, NODE *));
 
 NODE *
-mtree_readspec(FILE *fi)
+spec()
 {
 	NODE *centry, *last;
 	char *p;
@@ -63,18 +71,19 @@
 	int c_cur, c_next;
 	char buf[2048];
 
-	centry = last = root = NULL;
-	bzero(&ginfo, sizeof(ginfo));
+	root = NULL;
+	centry = last = NULL;
+	memset(&ginfo, 0, sizeof(ginfo));
 	c_cur = c_next = 0;
-	for (lineno = 1; fgets(buf, sizeof(buf), fi);
+	for (lineno = 1; fgets(buf, sizeof(buf), stdin);
 	    ++lineno, c_cur = c_next, c_next = 0) {
 		/* Skip empty lines. */
 		if (buf[0] == '\n')
 			continue;
 
 		/* Find end of line. */
-		if ((p = index(buf, '\n')) == NULL)
-			errx(1, "line %d too long", lineno);
+		if ((p = strchr(buf, '\n')) == NULL)
+			mtree_err("line %d too long", lineno);
 
 		/* See if next line is continuation line. */
 		if (p[-1] == '\\') {
@@ -86,7 +95,7 @@
 		*p = '\0';
 
 		/* Skip leading whitespace. */
-		for (p = buf; *p && isspace(*p); ++p);
+		for (p = buf; *p && isspace((unsigned char)*p); ++p);
 
 		/* If nothing but whitespace or comment char, continue. */
 		if (!*p || *p == '#')
@@ -99,10 +108,10 @@
 			set(p, centry);
 			continue;
 		}
-
+			
 		/* Grab file name, "$", "set", or "unset". */
 		if ((p = strtok(p, "\n\t ")) == NULL)
-			errx(1, "line %d: missing field", lineno);
+			mtree_err("missing field");
 
 		if (p[0] == '/')
 			switch(p[1]) {
@@ -118,9 +127,8 @@
 				continue;
 			}
 
-		if (index(p, '/'))
-			errx(1, "line %d: slash character in file name",
-			lineno);
+		if (strchr(p, '/'))
+			mtree_err("slash character in file name");
 
 		if (!strcmp(p, "..")) {
 			/* Don't go up, if haven't gone down. */
@@ -134,17 +142,17 @@
 			last->flags |= F_DONE;
 			continue;
 
-noparent:		errx(1, "line %d: no parent node", lineno);
+noparent:		mtree_err("no parent node");
 		}
 
 		if ((centry = calloc(1, sizeof(NODE) + strlen(p))) == NULL)
-			errx(1, "calloc");
+			mtree_err("%s", strerror(errno));
 		*centry = ginfo;
+                if (strunvis(centry->name, p) == -1)
+			mtree_err("strunvis failed on %s", p);
 #define	MAGIC	"?*["
 		if (strpbrk(p, MAGIC))
 			centry->flags |= F_MAGIC;
-		if (strunvis(centry->name, p) == -1)
-			errx(1, "filename %s is ill-encoded", p);
 		set(NULL, centry);
 
 		if (!root) {
@@ -163,105 +171,94 @@
 }
 
 static void
-set(char *t, NODE *ip)
+set(t, ip)
+	char *t;
+	NODE *ip;
 {
 	int type;
-	char *kw, *val = NULL;
+	char *kw, *val, *md;
 	struct group *gr;
 	struct passwd *pw;
 	mode_t *m;
 	int value;
 	char *ep;
 
-	for (; (kw = strtok(t, "= \t\n")); t = NULL) {
+	val = NULL;
+	for (; (kw = strtok(t, "= \t\n")) != NULL; t = NULL) {
 		ip->flags |= type = parsekey(kw, &value);
 		if (value && (val = strtok(NULL, " \t\n")) == NULL)
-			errx(1, "line %d: missing value", lineno);
+			mtree_err("missing value");
 		switch(type) {
 		case F_CKSUM:
 			ip->cksum = strtoul(val, &ep, 10);
 			if (*ep)
-				errx(1, "line %d: invalid checksum %s",
-				lineno, val);
-			break;
-		case F_MD5:
-			ip->md5digest = strdup(val);
-			if(!ip->md5digest)
-				errx(1, "strdup");
-			break;
-		case F_SHA1:
-			ip->sha1digest = strdup(val);
-			if(!ip->sha1digest)
-				errx(1, "strdup");
-			break;
-		case F_SHA256:
-			ip->sha256digest = strdup(val);
-			if(!ip->sha256digest)
-				errx(1, "strdup");
-			break;
-		case F_RMD160:
-			ip->rmd160digest = strdup(val);
-			if(!ip->rmd160digest)
-				errx(1, "strdup");
+				mtree_err("invalid checksum %s", val);
 			break;
 		case F_FLAGS:
 			if (strcmp("none", val) == 0)
 				ip->st_flags = 0;
-			else if (strtofflags(&val, &ip->st_flags, NULL) != 0)
-				errx(1, "line %d: invalid flag %s",lineno, val);
- 			break;
+			else if (string_to_flags(&val, &ip->st_flags, NULL) != 0)
+				mtree_err("invalid flag %s", val);
+			break;
 		case F_GID:
-			ip->st_gid = strtoul(val, &ep, 10);
+			ip->st_gid = (gid_t)strtoul(val, &ep, 10);
 			if (*ep)
-				errx(1, "line %d: invalid gid %s", lineno, val);
+				mtree_err("invalid gid %s", val);
 			break;
 		case F_GNAME:
 			if ((gr = getgrnam(val)) == NULL)
-			    errx(1, "line %d: unknown group %s", lineno, val);
+			    mtree_err("unknown group %s", val);
 			ip->st_gid = gr->gr_gid;
 			break;
 		case F_IGN:
 			/* just set flag bit */
 			break;
+		case F_MD5:
+			if (val[0]=='0' && val[1]=='x')
+				md=&val[2];
+			else
+				md=val;
+			if ((ip->md5sum = strdup(md)) == NULL)
+				mtree_err("memory allocation error");
+			break;
 		case F_MODE:
 			if ((m = setmode(val)) == NULL)
-				errx(1, "line %d: invalid file mode %s",
-				lineno, val);
+				mtree_err("invalid file mode %s", val);
 			ip->st_mode = getmode(m, 0);
 			free(m);
 			break;
 		case F_NLINK:
-			ip->st_nlink = strtoul(val, &ep, 10);
+			ip->st_nlink = (nlink_t)strtoul(val, &ep, 10);
 			if (*ep)
-				errx(1, "line %d: invalid link count %s",
-				lineno,  val);
-			break;
-		case F_OPT:
-			/* just set flag bit */
+				mtree_err("invalid link count %s", val);
 			break;
 		case F_SIZE:
-			ip->st_size = strtoq(val, &ep, 10);
+			ip->st_size = (off_t)strtoq(val, &ep, 10);
 			if (*ep)
-				errx(1, "line %d: invalid size %s",
-				lineno, val);
+				mtree_err("invalid size %s", val);
 			break;
 		case F_SLINK:
-			ip->slink = malloc(strlen(val) + 1);
-			if (ip->slink == NULL)
-				errx(1, "malloc");
-			if (strunvis(ip->slink, val) == -1)
-				errx(1, "symlink %s is ill-encoded", val);
+			if ((ip->slink = strdup(val)) == NULL)
+				mtree_err("memory allocation error");
 			break;
 		case F_TIME:
-			ip->st_mtimespec.tv_sec = strtoul(val, &ep, 10);
+#ifndef __APPLE__
+			ip->st_mtimespec.tv_sec =
+			    (time_t)strtoul(val, &ep, 10);
+#else
+			ip->st_mtimespec.ts_sec =
+			    (time_t)strtoul(val, &ep, 10);
+#endif
 			if (*ep != '.')
-				errx(1, "line %d: invalid time %s",
-				lineno, val);
+				mtree_err("invalid time %s", val);
 			val = ep + 1;
-			ip->st_mtimespec.tv_nsec = strtoul(val, &ep, 10);
+#ifndef __APPLE__
+			ip->st_mtimespec.tv_nsec = strtol(val, &ep, 10);
+#else
+			ip->st_mtimespec.ts_nsec = strtol(val, &ep, 10);
+#endif
 			if (*ep)
-				errx(1, "line %d: invalid time %s",
-				lineno, val);
+				mtree_err("invalid time %s", val);
 			break;
 		case F_TYPE:
 			switch(*val) {
@@ -292,18 +289,17 @@
 					ip->type = F_SOCK;
 				break;
 			default:
-				errx(1, "line %d: unknown file type %s",
-				lineno, val);
+				mtree_err("unknown file type %s", val);
 			}
 			break;
 		case F_UID:
-			ip->st_uid = strtoul(val, &ep, 10);
+			ip->st_uid = (uid_t)strtoul(val, &ep, 10);
 			if (*ep)
-				errx(1, "line %d: invalid uid %s", lineno, val);
+				mtree_err("invalid uid %s", val);
 			break;
 		case F_UNAME:
 			if ((pw = getpwnam(val)) == NULL)
-			    errx(1, "line %d: unknown user %s", lineno, val);
+			    mtree_err("unknown user %s", val);
 			ip->st_uid = pw->pw_uid;
 			break;
 		}
@@ -311,10 +307,12 @@
 }
 
 static void
-unset(char *t, NODE *ip)
+unset(t, ip)
+	char *t;
+	NODE *ip;
 {
 	char *p;
 
-	while ((p = strtok(t, "\n\t ")))
+	while ((p = strtok(t, "\n\t ")) != NULL)
 		ip->flags &= ~parsekey(p, NULL);
 }
diff -ru -ruN mtree/specspec.c mtree-linux/specspec.c
--- mtree/specspec.c	2005-03-29 13:44:17.000000000 +0200
+++ mtree-linux/specspec.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,256 +0,0 @@
-/*-
- * Copyright (c) 2003 Poul-Henning Kamp
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/usr.sbin/mtree/specspec.c,v 1.6 2005/03/29 11:44:17 tobez Exp $");
-
-#include <err.h>
-#include <grp.h>
-#include <pwd.h>
-#include <stdio.h>
-#include <stdint.h>
-#include <unistd.h>
-#include "mtree.h"
-#include "extern.h"
-
-#define FF(a, b, c, d) \
-	(((a)->flags & (c)) && ((b)->flags & (c)) && ((a)->d) != ((b)->d))
-#define FS(a, b, c, d) \
-	(((a)->flags & (c)) && ((b)->flags & (c)) && strcmp((a)->d,(b)->d))
-#define FM(a, b, c, d) \
-	(((a)->flags & (c)) && ((b)->flags & (c)) && memcmp(&(a)->d,&(b)->d, sizeof (a)->d))
-
-static void
-shownode(NODE *n, int f, char const *path)
-{
-	struct group *gr;
-	struct passwd *pw;
-
-	printf("%s%s %s", path, n->name, ftype(n->type));
-	if (f & F_CKSUM)
-		printf(" cksum=%lu", n->cksum);
-	if (f & F_GID)
-		printf(" gid=%d", n->st_gid);
-	if (f & F_GNAME) {
-		gr = getgrgid(n->st_gid);
-		if (gr == NULL)
-			printf(" gid=%d", n->st_gid);
-		else
-			printf(" gname=%s", gr->gr_name);
-	}
-	if (f & F_MODE)
-		printf(" mode=%o", n->st_mode);
-	if (f & F_NLINK)
-		printf(" nlink=%d", n->st_nlink);
-	if (f & F_SIZE)
-		printf(" size=%jd", (intmax_t)n->st_size);
-	if (f & F_UID)
-		printf(" uid=%d", n->st_uid);
-	if (f & F_UNAME) {
-		pw = getpwuid(n->st_uid);
-		if (pw == NULL)
-			printf(" uid=%d", n->st_uid);
-		else
-			printf(" uname=%s", pw->pw_name);
-	}
-	if (f & F_MD5)
-		printf(" md5digest=%s", n->md5digest);
-	if (f & F_SHA1)
-		printf(" sha1digest=%s", n->sha1digest);
-	if (f & F_RMD160)
-		printf(" rmd160digest=%s", n->rmd160digest);
-	if (f & F_SHA256)
-		printf(" sha256digest=%s", n->sha256digest);
-	if (f & F_FLAGS)
-		printf(" flags=%s", flags_to_string(n->st_flags));
-	printf("\n");
-}
-
-static int
-mismatch(NODE *n1, NODE *n2, int differ, char const *path)
-{
-
-	if (n2 == NULL) {
-		shownode(n1, differ, path);
-		return (1);
-	}
-	if (n1 == NULL) {
-		printf("\t");
-		shownode(n2, differ, path);
-		return (1);
-	}
-	if (!(differ & keys))
-		return(0);
-	printf("\t\t");
-	shownode(n1, differ, path);
-	printf("\t\t");
-	shownode(n2, differ, path);
-	return (1);
-}
-
-static int
-compare_nodes(NODE *n1, NODE *n2, char const *path)
-{
-	int differs;
-	
-	if (n1 != NULL && n1->type == F_LINK)
-		n1->flags &= ~F_MODE;
-	if (n2 != NULL && n2->type == F_LINK)
-		n2->flags &= ~F_MODE;
-	differs = 0;
-	if (n1 == NULL && n2 != NULL) {
-		differs = n2->flags;
-		mismatch(n1, n2, differs, path);
-		return (1);
-	}
-	if (n1 != NULL && n2 == NULL) {
-		differs = n1->flags;
-		mismatch(n1, n2, differs, path);
-		return (1);
-	}
-	if (n1->type != n2->type) {
-		differs = 0;
-		mismatch(n1, n2, differs, path);
-		return (1);
-	}
-	if (FF(n1, n2, F_CKSUM, cksum))
-		differs |= F_CKSUM;
-	if (FF(n1, n2, F_GID, st_gid))
-		differs |= F_GID;
-	if (FF(n1, n2, F_GNAME, st_gid))
-		differs |= F_GNAME;
-	if (FF(n1, n2, F_MODE, st_mode))
-		differs |= F_MODE;
-	if (FF(n1, n2, F_NLINK, st_nlink))
-		differs |= F_NLINK;
-	if (FF(n1, n2, F_SIZE, st_size))
-		differs |= F_SIZE;
-	if (FS(n1, n2, F_SLINK, slink))
-		differs |= F_SLINK;
-	if (FM(n1, n2, F_TIME, st_mtimespec))
-		differs |= F_TIME;
-	if (FF(n1, n2, F_UID, st_uid))
-		differs |= F_UID;
-	if (FF(n1, n2, F_UNAME, st_uid))
-		differs |= F_UNAME;
-	if (FS(n1, n2, F_MD5, md5digest))
-		differs |= F_MD5;
-	if (FS(n1, n2, F_SHA1, sha1digest))
-		differs |= F_SHA1;
-	if (FS(n1, n2, F_RMD160, rmd160digest))
-		differs |= F_RMD160;
-	if (FS(n1, n2, F_SHA256, sha256digest))
-		differs |= F_SHA256;
-	if (FF(n1, n2, F_FLAGS, st_flags))
-		differs |= F_FLAGS;
-	if (differs) {
-		mismatch(n1, n2, differs, path);
-		return (1);
-	}
-	return (0);	
-}
-static int
-walk_in_the_forest(NODE *t1, NODE *t2, char const *path)
-{
-	int r, i;
-	NODE *c1, *c2, *n1, *n2;
-	char *np;
-
-	r = 0;
-
-	if (t1 != NULL)
-		c1 = t1->child;
-	else
-		c1 = NULL;
-	if (t2 != NULL)
-		c2 = t2->child;
-	else
-		c2 = NULL;
-	while (c1 != NULL || c2 != NULL) {
-		n1 = n2 = NULL;
-		if (c1 != NULL)
-			n1 = c1->next;
-		if (c2 != NULL)
-			n2 = c2->next;
-		if (c1 != NULL && c2 != NULL) {
-			if (c1->type != F_DIR && c2->type == F_DIR) {
-				n2 = c2;
-				c2 = NULL;
-			} else if (c1->type == F_DIR && c2->type != F_DIR) {
-				n1 = c1;
-				c1 = NULL;
-			} else {
-				i = strcmp(c1->name, c2->name);
-				if (i > 0) {
-					n1 = c1;
-					c1 = NULL;
-				} else if (i < 0) {
-					n2 = c2;
-					c2 = NULL;
-				}
-			}
-		}
-		if (c1 == NULL && c2->type == F_DIR) {
-			asprintf(&np, "%s%s/", path, c2->name);
-			i = walk_in_the_forest(c1, c2, np);
-			free(np);
-			i += compare_nodes(c1, c2, path);
-		} else if (c2 == NULL && c1->type == F_DIR) {
-			asprintf(&np, "%s%s/", path, c1->name);
-			i = walk_in_the_forest(c1, c2, np);
-			free(np);
-			i += compare_nodes(c1, c2, path);
-		} else if (c1 == NULL || c2 == NULL) {
-			i = compare_nodes(c1, c2, path);
-		} else if (c1->type == F_DIR && c2->type == F_DIR) {
-			asprintf(&np, "%s%s/", path, c1->name);
-			i = walk_in_the_forest(c1, c2, np);
-			free(np);
-			i += compare_nodes(c1, c2, path);
-		} else {
-			i = compare_nodes(c1, c2, path);
-		}
-		r += i;
-		c1 = n1;
-		c2 = n2;
-	}
-	return (r);	
-}
-
-int
-mtree_specspec(FILE *fi, FILE *fj)
-{
-	int rval;
-	NODE *root1, *root2;
-
-	root1 = mtree_readspec(fi);
-	root2 = mtree_readspec(fj);
-	rval = walk_in_the_forest(root1, root2, "");
-	rval += compare_nodes(root1, root2, "");
-	if (rval > 0)
-		return (MISMATCHEXIT);
-	return (0);
-}
diff -ru -ruN mtree/stat_flags.c mtree-linux/stat_flags.c
--- mtree/stat_flags.c	1970-01-01 01:00:00.000000000 +0100
+++ mtree-linux/stat_flags.c	1999-01-03 02:30:10.000000000 +0100
@@ -0,0 +1,170 @@
+/*	$NetBSD: stat_flags.c,v 1.7 1999/01/03 01:30:10 lukem Exp $	*/
+
+/*-
+ * Copyright (c) 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+#ifndef lint
+#if 0
+static char sccsid[] = "@(#)stat_flags.c	8.2 (Berkeley) 7/28/94";
+#else
+__RCSID("$NetBSD: stat_flags.c,v 1.7 1999/01/03 01:30:10 lukem Exp $");
+#endif
+#endif /* not lint */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+
+#include <stddef.h>
+#include <string.h>
+#include <fts.h>
+
+#include "stat_flags.h"
+
+#define	SAPPEND(s) {							\
+	if (prefix != NULL)						\
+		(void)strcat(string, prefix);				\
+	(void)strcat(string, s);					\
+	prefix = ",";							\
+}
+
+/*
+ * flags_to_string --
+ *	Convert stat flags to a comma-separated string.  If no flags
+ *	are set, return the default string.
+ */
+char *
+flags_to_string(flags, def)
+	u_long flags;
+	char *def;
+{
+	static char string[128];
+	char *prefix;
+
+	string[0] = '\0';
+	prefix = NULL;
+	if (flags & UF_APPEND)
+		SAPPEND("uappnd");
+	if (flags & UF_IMMUTABLE)
+		SAPPEND("uchg");
+	if (flags & UF_NODUMP)
+		SAPPEND("nodump");
+	if (flags & UF_OPAQUE)
+		SAPPEND("opaque");
+	if (flags & SF_APPEND)
+		SAPPEND("sappnd");
+	if (flags & SF_ARCHIVED)
+		SAPPEND("arch");
+	if (flags & SF_IMMUTABLE)
+		SAPPEND("schg");
+	return (prefix == NULL && def != NULL ? def : string);
+}
+
+#define	TEST(a, b, f) {							\
+	if (!memcmp(a, b, sizeof(b))) {					\
+		if (clear) {						\
+			if (clrp)					\
+				*clrp |= (f);				\
+		} else if (setp)					\
+			*setp |= (f);					\
+		break;							\
+	}								\
+}
+
+/*
+ * string_to_flags --
+ *	Take string of arguments and return stat flags.  Return 0 on
+ *	success, 1 on failure.  On failure, stringp is set to point
+ *	to the offending token.
+ */
+int
+string_to_flags(stringp, setp, clrp)
+	char **stringp;
+	u_long *setp, *clrp;
+{
+	int clear;
+	char *string, *p;
+
+	clear = 0;
+	if (setp)
+		*setp = 0;
+	if (clrp)
+		*clrp = 0;
+	string = *stringp;
+	while ((p = strsep(&string, "\t ,")) != NULL) {
+		*stringp = p;
+		if (*p == '\0')
+			continue;
+		if (p[0] == 'n' && p[1] == 'o') {
+			clear = 1;
+			p += 2;
+		}
+		switch (p[0]) {
+		case 'a':
+			TEST(p, "arch", SF_ARCHIVED);
+			TEST(p, "archived", SF_ARCHIVED);
+			return (1);
+		case 'd':
+			clear = !clear;
+			TEST(p, "dump", UF_NODUMP);
+			return (1);
+		case 'n':
+				/*
+				 * Support `nonodump'. Note that
+				 * the state of clear is not changed.
+				 */
+			TEST(p, "nodump", UF_NODUMP);
+			return (1);
+		case 'o':
+			TEST(p, "opaque", UF_OPAQUE);
+			return (1);
+		case 's':
+			TEST(p, "sappnd", SF_APPEND);
+			TEST(p, "sappend", SF_APPEND);
+			TEST(p, "schg", SF_IMMUTABLE);
+			TEST(p, "schange", SF_IMMUTABLE);
+			TEST(p, "simmutable", SF_IMMUTABLE);
+			return (1);
+		case 'u':
+			TEST(p, "uappnd", UF_APPEND);
+			TEST(p, "uappend", UF_APPEND);
+			TEST(p, "uchg", UF_IMMUTABLE);
+			TEST(p, "uchange", UF_IMMUTABLE);
+			TEST(p, "uimmutable", UF_IMMUTABLE);
+			return (1);
+		default:
+			return (1);
+		}
+	}
+	return (0);
+}
diff -ru -ruN mtree/stat_flags.h mtree-linux/stat_flags.h
--- mtree/stat_flags.h	1970-01-01 01:00:00.000000000 +0100
+++ mtree-linux/stat_flags.h	2001-08-05 13:43:29.000000000 +0200
@@ -0,0 +1,71 @@
+/*	$NetBSD: stat_flags.h,v 1.1 1998/10/10 07:38:22 mrg Exp $	*/
+
+/*-
+ * Copyright (c) 1991, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)extern.h	8.1 (Berkeley) 5/31/93
+ */
+
+#ifdef linux
+
+# if !defined UF_NODUMP
+#  define UF_NODUMP 0
+# endif
+# if !defined UF_IMMUTABLE
+#  define UF_IMMUTABLE 0
+# endif
+# if !defined UF_APPEND
+#  define UF_APPEND 0
+# endif
+# if !defined UF_OPAQUE
+#  define UF_OPAQUE 0
+# endif
+# if !defined UF_NOUNLINK
+#  define UF_NOUNLINK 0
+# endif
+# if !defined SF_ARCHIVED
+#  define SF_ARCHIVED 0
+# endif
+# if !defined SF_IMMUTABLE
+#  define SF_IMMUTABLE 0
+# endif
+# if !defined SF_APPEND
+#  define SF_APPEND 0
+# endif
+# if !defined SF_NOUNLINK
+#  define SF_NOUNLINK 0
+# endif
+
+#endif /* linux */
+
+char	*flags_to_string __P((u_long, char *));
+int	 string_to_flags __P((char **, u_long *, u_long *));
diff -ru -ruN mtree/stat_flags.h.orig mtree-linux/stat_flags.h.orig
--- mtree/stat_flags.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ mtree-linux/stat_flags.h.orig	1998-10-10 09:38:22.000000000 +0200
@@ -0,0 +1,39 @@
+/*	$NetBSD: stat_flags.h,v 1.1 1998/10/10 07:38:22 mrg Exp $	*/
+
+/*-
+ * Copyright (c) 1991, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)extern.h	8.1 (Berkeley) 5/31/93
+ */
+
+char	*flags_to_string __P((u_long, char *));
+int	 string_to_flags __P((char **, u_long *, u_long *));
diff -ru -ruN mtree/test/test00.sh mtree-linux/test/test00.sh
--- mtree/test/test00.sh	2003-11-05 23:26:08.000000000 +0100
+++ mtree-linux/test/test00.sh	1970-01-01 01:00:00.000000000 +0100
@@ -1,67 +0,0 @@
-#!/bin/sh
-#
-# Copyright (c) 2003 Poul-Henning Kamp
-# All rights reserved.
-#
-# Please see src/share/examples/etc/bsd-style-copyright.
-#
-# $FreeBSD: src/usr.sbin/mtree/test/test00.sh,v 1.3 2003/11/05 22:26:08 phk Exp $
-#
-
-set -e
-
-TMP=/tmp/mtree.$$
-
-rm -rf ${TMP}
-mkdir -p ${TMP} ${TMP}/mr ${TMP}/mt
-
-
-mkdir ${TMP}/mt/foo
-mkdir ${TMP}/mr/\*
-mtree -c -p ${TMP}/mr | mtree -U -r -p ${TMP}/mt > /dev/null 2>&1
-if [ -d ${TMP}/mt/foo ] ; then
-	echo "ERROR Mtree create fell for filename with '*' char" 1>&2
-	rm -rf ${TMP}
-	exit 1
-fi
-rmdir ${TMP}/mr/\*
-
-mkdir -p ${TMP}/mt/foo
-mkdir ${TMP}/mr/\[f\]oo
-mtree -c -p ${TMP}/mr | mtree -U -r -p ${TMP}/mt > /dev/null 2>&1
-if [ -d ${TMP}/mt/foo ] ; then
-	echo "ERROR Mtree create fell for filename with '[' char" 1>&2
-	rm -rf ${TMP}
-	exit 1
-fi
-rmdir ${TMP}/mr/\[f\]oo
-
-mkdir -p ${TMP}/mt/foo
-mkdir ${TMP}/mr/\?oo
-mtree -c -p ${TMP}/mr | mtree -U -r -p ${TMP}/mt > /dev/null 2>&1
-if [ -d ${TMP}/mt/foo ] ; then
-	echo "ERROR Mtree create fell for filename with '?' char" 1>&2
-	rm -rf ${TMP}
-	exit 1
-fi
-rmdir ${TMP}/mr/\?oo
-
-mkdir ${TMP}/mr/\#
-mtree -c -p ${TMP}/mr > ${TMP}/_
-if mtree -U -r -p ${TMP}/mt < ${TMP}/_ > /dev/null 2>&1 ; then
-	true
-else
-	echo "ERROR Mtree create fell for filename with '#' char" 1>&2
-	rm -rf ${TMP}
-	exit 1
-fi
-	
-if [ ! -d ${TMP}/mt/\# ] ; then
-	echo "ERROR Mtree update failed to create name with '#' char" 1>&2
-	rm -rf ${TMP}
-	exit 1
-fi
-rmdir ${TMP}/mr/\#
-
-rm -rf ${TMP}
-exit 0
diff -ru -ruN mtree/test/test01.sh mtree-linux/test/test01.sh
--- mtree/test/test01.sh	2003-10-30 13:01:32.000000000 +0100
+++ mtree-linux/test/test01.sh	1970-01-01 01:00:00.000000000 +0100
@@ -1,40 +0,0 @@
-#!/bin/sh
-#
-# Copyright (c) 2003 Poul-Henning Kamp
-# All rights reserved.
-#
-# Please see src/share/examples/etc/bsd-style-copyright.
-#
-# $FreeBSD: src/usr.sbin/mtree/test/test01.sh,v 1.1 2003/10/30 12:01:32 phk Exp $
-#
-
-set -e
-
-TMP=/tmp/mtree.$$
-
-rm -rf ${TMP}
-mkdir -p ${TMP} ${TMP}/mr ${TMP}/mt
-
-
-ln -s "xx this=is=wrong" ${TMP}/mr/foo
-mtree -c -p ${TMP}/mr > ${TMP}/_
-
-if mtree -U -r -p ${TMP}/mt < ${TMP}/_ > /dev/null 2>&1 ; then
-	true
-else
-	echo "ERROR Mtree failed on symlink with space char" 1>&2
-	rm -rf ${TMP}
-	exit 1
-fi
-
-x=x`(cd ${TMP}/mr ; ls -l foo 2>&1) || true`
-y=x`(cd ${TMP}/mt ; ls -l foo 2>&1) || true`
-
-if [ "$x" != "$y" ] ; then
-	echo "ERROR Recreation of spaced symlink failed" 1>&2
-	rm -rf ${TMP}
-	exit 1
-fi
-
-rm -rf ${TMP}
-exit 0
diff -ru -ruN mtree/test/test02.sh mtree-linux/test/test02.sh
--- mtree/test/test02.sh	2003-10-31 14:39:19.000000000 +0100
+++ mtree-linux/test/test02.sh	1970-01-01 01:00:00.000000000 +0100
@@ -1,36 +0,0 @@
-#!/bin/sh
-#
-# Copyright (c) 2003 Dan Nelson
-# All rights reserved.
-#
-# Please see src/share/examples/etc/bsd-style-copyright.
-#
-# $FreeBSD: src/usr.sbin/mtree/test/test02.sh,v 1.1 2003/10/31 13:39:19 phk Exp $
-#
-
-set -e
-
-TMP=/tmp/mtree.$$
-
-rm -rf ${TMP}
-mkdir -p ${TMP} ${TMP}/mr ${TMP}/mt
-
-touch -t 199901020304 ${TMP}/mr/oldfile
-touch ${TMP}/mt/oldfile
-
-mtree -c -p ${TMP}/mr > ${TMP}/_ 
-
-mtree -U -r -p ${TMP}/mt < ${TMP}/_ > /dev/null
-
-x=x`(cd ${TMP}/mr ; ls -l 2>&1) || true`
-y=x`(cd ${TMP}/mt ; ls -l 2>&1) || true`
-
-if [ "$x" != "$y" ] ; then
-	echo "ERROR Update of mtime failed" 1>&2
-	rm -rf ${TMP}
-	exit 1
-fi
-
-rm -rf ${TMP}
-exit 0
-
diff -ru -ruN mtree/test/test03.sh mtree-linux/test/test03.sh
--- mtree/test/test03.sh	2005-03-29 13:44:17.000000000 +0200
+++ mtree-linux/test/test03.sh	1970-01-01 01:00:00.000000000 +0100
@@ -1,60 +0,0 @@
-#!/bin/sh
-#
-# Copyright (c) 2003 Poul-Henning Kamp
-# All rights reserved.
-#
-# Please see src/share/examples/etc/bsd-style-copyright.
-#
-# $FreeBSD: src/usr.sbin/mtree/test/test03.sh,v 1.2 2005/03/29 11:44:17 tobez Exp $
-#
-
-set -e
-
-TMP=/tmp/mtree.$$
-
-rm -rf ${TMP}
-mkdir -p ${TMP}
-
-K=uid,uname,gid,gname,flags,md5digest,size,ripemd160digest,sha1digest,sha256digest,cksum
-
-rm -rf _FOO
-mkdir _FOO
-touch _FOO/_uid
-touch _FOO/_size
-touch _FOO/zztype
-
-touch _FOO/_bar
-mtree -c -K $K -p .. > ${TMP}/_r
-mtree -c -K $K -p .. > ${TMP}/_r2
-rm -rf _FOO/_bar 
-
-rm -rf _FOO/zztype
-mkdir _FOO/zztype
-
-date > _FOO/_size
-
-chown nobody _FOO/_uid
-
-touch _FOO/_foo
-mtree -c -K $K -p .. > ${TMP}/_t
-
-rm -fr _FOO
-
-if mtree -f ${TMP}/_r -f ${TMP}/_r2 ; then
-	true
-else
-	echo "ERROR Compare identical failed" 1>&2
-	exit 1
-fi
-	
-if mtree -f ${TMP}/_r -f ${TMP}/_t > ${TMP}/_ ; then
-	echo "ERROR Compare different succeeded" 1>&2
-	exit 1
-fi
-
-if [ `wc -l  < ${TMP}/_` -ne 10 ] ; then
-	echo "ERROR wrong number of lines: `wc -l  ${TMP}/_`" 1>&2
-	exit 1
-fi
-	
-exit 0
diff -ru -ruN mtree/test/test04.sh mtree-linux/test/test04.sh
--- mtree/test/test04.sh	2003-11-13 12:02:57.000000000 +0100
+++ mtree-linux/test/test04.sh	1970-01-01 01:00:00.000000000 +0100
@@ -1,51 +0,0 @@
-#!/bin/sh
-#
-# Copyright (c) 2003 Dan Nelson
-# All rights reserved.
-#
-# Please see src/share/examples/etc/bsd-style-copyright.
-#
-# $FreeBSD: src/usr.sbin/mtree/test/test04.sh,v 1.1 2003/11/13 11:02:57 phk Exp $
-#
-
-set -e
-
-TMP=/tmp/mtree.$$
-
-rm -rf ${TMP}
-mkdir -p ${TMP} ${TMP}/mr ${TMP}/mt
-
-mkdir ${TMP}/mr/a
-mkdir ${TMP}/mr/b
-mkdir ${TMP}/mt/a
-mkdir ${TMP}/mt/b
-touch ${TMP}/mt/z
-
-mtree -c -p ${TMP}/mr > ${TMP}/_r
-mtree -c -p ${TMP}/mt > ${TMP}/_t
-
-if mtree -f ${TMP}/_r -f ${TMP}/_t > ${TMP}/_ ; then
-	echo "ERROR wrong exit on difference" 1>&2
-	exit 1
-fi
-
-if [ `wc -l < ${TMP}/_` -ne 1 ] ; then
-	echo "ERROR spec/spec compare generated wrong output" 1>&2
-	rm -rf ${TMP}
-	exit 1
-fi
-
-if mtree -f ${TMP}/_t -f ${TMP}/_r > ${TMP}/_ ; then
-	echo "ERROR wrong exit on difference" 1>&2
-	exit 1
-fi
-
-if [ `wc -l < ${TMP}/_` -ne 1 ] ; then
-	echo "ERROR spec/spec compare generated wrong output" 1>&2
-	rm -rf ${TMP}
-	exit 1
-fi
-
-rm -rf ${TMP}
-exit 0
-
diff -ru -ruN mtree/test/test05.sh mtree-linux/test/test05.sh
--- mtree/test/test05.sh	2006-07-28 18:27:40.000000000 +0200
+++ mtree-linux/test/test05.sh	1970-01-01 01:00:00.000000000 +0100
@@ -1,25 +0,0 @@
-#!/bin/sh
-#
-# $FreeBSD: src/usr.sbin/mtree/test/test05.sh,v 1.1.2.1 2006/07/28 16:27:40 maxim Exp $
-#
-# Test for 'optional' keyword.
-#
-
-TMP=`mktemp -d /tmp/mtree.XXXXXX`
-mkdir -p ${TMP}/mr ${TMP}/mr/optional-dir ${TMP}/mr/some-dir
-touch ${TMP}/mr/optional-file ${TMP}/mr/some-file
-
-mtree -c -p ${TMP}/mr > ${TMP}/_
-rm -rf ${TMP}/mr/optional-file ${TMP}/mr/optional-dir
-mtree -p ${TMP}/mr -K optional < ${TMP}/_ > /dev/null
-
-res=$?
-
-if [ $res -ne 0 ] ; then
-	echo "ERROR 'optional' keyword failed" 1>&2
-	rm -rf ${TMP}
-	exit 1
-fi
-
-rm -rf ${TMP}
-exit 0
diff -ru -ruN mtree/unvis.3 mtree-linux/unvis.3
--- mtree/unvis.3	1970-01-01 01:00:00.000000000 +0100
+++ mtree-linux/unvis.3	1998-04-28 22:11:36.000000000 +0200
@@ -0,0 +1,170 @@
+.\"	$NetBSD: unvis.3,v 1.9 1998/04/28 20:11:36 fair Exp $
+.\"
+.\" Copyright (c) 1989, 1991, 1993
+.\"	The Regents of the University of California.  All rights reserved.
+.\"
+.\" Redistribution and use in source and binary forms, with or without
+.\" modification, are permitted provided that the following conditions
+.\" are met:
+.\" 1. Redistributions of source code must retain the above copyright
+.\"    notice, this list of conditions and the following disclaimer.
+.\" 2. Redistributions in binary form must reproduce the above copyright
+.\"    notice, this list of conditions and the following disclaimer in the
+.\"    documentation and/or other materials provided with the distribution.
+.\" 3. All advertising materials mentioning features or use of this software
+.\"    must display the following acknowledgement:
+.\"	This product includes software developed by the University of
+.\"	California, Berkeley and its contributors.
+.\" 4. Neither the name of the University nor the names of its contributors
+.\"    may be used to endorse or promote products derived from this software
+.\"    without specific prior written permission.
+.\"
+.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+.\" SUCH DAMAGE.
+.\"
+.\"     @(#)unvis.3	8.2 (Berkeley) 12/11/93
+.\"
+.Dd December 11, 1993
+.Dt UNVIS 3
+.Os
+.Sh NAME
+.Nm unvis ,
+.Nm strunvis
+.Nd decode a visual representation of characters
+.Sh LIBRARY
+.Lb libc
+.Sh SYNOPSIS
+.Fd #include <vis.h>
+.Ft int
+.Fn unvis "char *cp" "char c" "int *astate" "int flag"
+.Ft int
+.Fn strunvis "char *dst" "char *src"
+.Sh DESCRIPTION
+The
+.Fn unvis
+and
+.Fn strunvis
+functions
+are used to decode a visual representation of characters, as produced
+by the
+.Xr vis 3
+function, back into
+the original form.
+.Pp
+The
+.Fn unvis
+function is called with successive characters in
+.Ar c
+until a valid sequence is recognized, at which time the decoded
+character is available at the character pointed to by
+.Ar cp .
+.Pp
+The
+.Fn strunvis
+function decodes the characters pointed to by
+.Ar src
+into the buffer pointed to by
+.Ar dst .
+The
+.Fn strunvis
+function simply copies
+.Ar src
+to
+.Ar dst ,
+decoding any escape sequences along the way,
+and returns the number of characters placed into
+.Ar dst ,
+or \-1 if an
+invalid escape sequence was detected.
+The size of
+.Ar dst
+should be equal to the size of
+.Ar src
+(that is, no expansion takes place during decoding).
+.Pp
+The
+.Fn unvis
+function implements a state machine that can be used to decode an
+arbitrary stream of bytes.
+All state associated with the bytes being decoded is stored outside the
+.Fn unvis
+function (that is, a pointer to the state is passed in), so
+calls decoding different streams can be freely intermixed.
+To start decoding a stream of bytes, first initialize an integer to zero.
+Call
+.Fn unvis
+with each successive byte, along with a pointer
+to this integer, and a pointer to a destination character.
+The
+.Fn unvis
+function has several return codes that must be handled properly.
+They are:
+.Bl -tag -width UNVIS_VALIDPUSH
+.It Li \&0 (zero)
+Another character is necessary; nothing has been recognized yet.
+.It Dv UNVIS_VALID	
+A valid character has been recognized and is available at the location
+pointed to by cp.
+.It Dv UNVIS_VALIDPUSH
+A valid character has been recognized and is available at the location
+pointed to by cp; however, the character currently passed in should
+be passed in again.
+.It Dv UNVIS_NOCHAR
+A valid sequence was detected, but no character was produced.
+This return code is necessary to indicate a logical break between characters.
+.It Dv UNVIS_SYNBAD
+An invalid escape sequence was detected, or the decoder is in an unknown state.
+The decoder is placed into the starting state.
+.El
+.Pp
+When all bytes in the stream have been processed, call
+.Fn unvis
+one more time with flag set to
+.Dv UNVIS_END
+to extract any remaining character (the character passed in is ignored).
+.Pp
+The following code fragment illustrates a proper use of
+.Fn unvis .
+.Bd -literal -offset indent
+int state = 0;
+char out;
+
+while ((ch = getchar()) != EOF) {
+again:
+	switch(unvis(&out, ch, &state, 0)) {
+	case 0:
+	case UNVIS_NOCHAR:
+		break;
+	case UNVIS_VALID:
+		(void) putchar(out);
+		break;
+	case UNVIS_VALIDPUSH:
+		(void) putchar(out);
+		goto again;
+	case UNVIS_SYNBAD:
+		(void)fprintf(stderr, "bad sequence!\n");
+	exit(1);
+	}
+}
+if (unvis(&out, (char)0, &state, UNVIS_END) == UNVIS_VALID)
+	(void) putchar(out);
+.Ed
+.Sh SEE ALSO
+.Xr vis 1 ,
+.Xr unvis 1 ,
+.Xr vis 3
+.Sh HISTORY
+The
+.Fn unvis
+function
+first appeared in
+.Bx 4.4 .
diff -ru -ruN mtree/unvis.c mtree-linux/unvis.c
--- mtree/unvis.c	1970-01-01 01:00:00.000000000 +0100
+++ mtree-linux/unvis.c	2001-08-05 14:10:21.000000000 +0200
@@ -0,0 +1,291 @@
+/*	$NetBSD: unvis.c,v 1.19 2000/01/22 22:19:13 mycroft Exp $	*/
+
+/*-
+ * Copyright (c) 1989, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+#if defined(LIBC_SCCS) && !defined(lint)
+#if 0
+static char sccsid[] = "@(#)unvis.c	8.1 (Berkeley) 6/4/93";
+#else
+__RCSID("$NetBSD: unvis.c,v 1.19 2000/01/22 22:19:13 mycroft Exp $");
+#endif
+#endif /* LIBC_SCCS and not lint */
+
+#define __LIBC12_SOURCE__
+
+/* #include "namespace.h" */
+#include <sys/types.h>
+
+#include <assert.h>
+#include <ctype.h>
+#include <stdio.h>
+#include <vis.h>
+
+#ifndef _DIAGASSERT
+#define _DIAGASSERT(cond)	assert(cond)
+#endif
+
+#ifdef __weak_alias
+__weak_alias(strunvis,_strunvis)
+__weak_alias(unvis,_unvis)
+#endif
+
+#ifndef linux
+__warn_references(unvis,
+    "warning: reference to compatibility unvis(); include <vis.h> for correct reference")
+#endif
+
+/*
+ * decode driven by state machine
+ */
+#define	S_GROUND	0	/* haven't seen escape char */
+#define	S_START		1	/* start decoding special sequence */
+#define	S_META		2	/* metachar started (M) */
+#define	S_META1		3	/* metachar more, regular char (-) */
+#define	S_CTRL		4	/* control char started (^) */
+#define	S_OCTAL2	5	/* octal digit 2 */
+#define	S_OCTAL3	6	/* octal digit 3 */
+
+#define	isoctal(c)	(((u_char)(c)) >= '0' && ((u_char)(c)) <= '7')
+
+int
+unvis(cp, c, astate, flag)
+	char *cp;
+	int c;
+	int *astate, flag;
+{
+	return __unvis13(cp, (int)c, astate, flag);
+}
+
+/*
+ * unvis - decode characters previously encoded by vis
+ */
+int
+__unvis13(cp, c, astate, flag)
+	char *cp;
+	int c;
+	int *astate, flag;
+{
+
+	_DIAGASSERT(cp != NULL);
+	_DIAGASSERT(astate != NULL);
+
+	if (flag & UNVIS_END) {
+		if (*astate == S_OCTAL2 || *astate == S_OCTAL3) {
+			*astate = S_GROUND;
+			return (UNVIS_VALID);
+		} 
+		return (*astate == S_GROUND ? UNVIS_NOCHAR : UNVIS_SYNBAD);
+	}
+
+	switch (*astate) {
+
+	case S_GROUND:
+		*cp = 0;
+		if (c == '\\') {
+			*astate = S_START;
+			return (0);
+		} 
+		*cp = c;
+		return (UNVIS_VALID);
+
+	case S_START:
+		switch(c) {
+		case '\\':
+			*cp = c;
+			*astate = S_GROUND;
+			return (UNVIS_VALID);
+		case '0': case '1': case '2': case '3':
+		case '4': case '5': case '6': case '7':
+			*cp = (c - '0');
+			*astate = S_OCTAL2;
+			return (0);
+		case 'M':
+			*cp = (char)0200;
+			*astate = S_META;
+			return (0);
+		case '^':
+			*astate = S_CTRL;
+			return (0);
+		case 'n':
+			*cp = '\n';
+			*astate = S_GROUND;
+			return (UNVIS_VALID);
+		case 'r':
+			*cp = '\r';
+			*astate = S_GROUND;
+			return (UNVIS_VALID);
+		case 'b':
+			*cp = '\b';
+			*astate = S_GROUND;
+			return (UNVIS_VALID);
+		case 'a':
+			*cp = '\007';
+			*astate = S_GROUND;
+			return (UNVIS_VALID);
+		case 'v':
+			*cp = '\v';
+			*astate = S_GROUND;
+			return (UNVIS_VALID);
+		case 't':
+			*cp = '\t';
+			*astate = S_GROUND;
+			return (UNVIS_VALID);
+		case 'f':
+			*cp = '\f';
+			*astate = S_GROUND;
+			return (UNVIS_VALID);
+		case 's':
+			*cp = ' ';
+			*astate = S_GROUND;
+			return (UNVIS_VALID);
+		case 'E':
+			*cp = '\033';
+			*astate = S_GROUND;
+			return (UNVIS_VALID);
+		case '\n':
+			/*
+			 * hidden newline
+			 */
+			*astate = S_GROUND;
+			return (UNVIS_NOCHAR);
+		case '$':
+			/*
+			 * hidden marker
+			 */
+			*astate = S_GROUND;
+			return (UNVIS_NOCHAR);
+		}
+		*astate = S_GROUND;
+		return (UNVIS_SYNBAD);
+		 
+	case S_META:
+		if (c == '-')
+			*astate = S_META1;
+		else if (c == '^')
+			*astate = S_CTRL;
+		else {
+			*astate = S_GROUND;
+			return (UNVIS_SYNBAD);
+		}
+		return (0);
+		 
+	case S_META1:
+		*astate = S_GROUND;
+		*cp |= c;
+		return (UNVIS_VALID);
+		 
+	case S_CTRL:
+		if (c == '?')
+			*cp |= 0177;
+		else
+			*cp |= c & 037;
+		*astate = S_GROUND;
+		return (UNVIS_VALID);
+
+	case S_OCTAL2:	/* second possible octal digit */
+		if (isoctal(c)) {
+			/* 
+			 * yes - and maybe a third 
+			 */
+			*cp = (*cp << 3) + (c - '0');
+			*astate = S_OCTAL3;	
+			return (0);
+		} 
+		/* 
+		 * no - done with current sequence, push back passed char 
+		 */
+		*astate = S_GROUND;
+		return (UNVIS_VALIDPUSH);
+
+	case S_OCTAL3:	/* third possible octal digit */
+		*astate = S_GROUND;
+		if (isoctal(c)) {
+			*cp = (*cp << 3) + (c - '0');
+			return (UNVIS_VALID);
+		}
+		/*
+		 * we were done, push back passed char
+		 */
+		return (UNVIS_VALIDPUSH);
+			
+	default:	
+		/* 
+		 * decoder in unknown state - (probably uninitialized) 
+		 */
+		*astate = S_GROUND;
+		return (UNVIS_SYNBAD);
+	}
+}
+
+/*
+ * strunvis - decode src into dst 
+ *
+ *	Number of chars decoded into dst is returned, -1 on error.
+ *	Dst is null terminated.
+ */
+
+int
+strunvis(dst, src)
+	char *dst;
+	const char *src;
+{
+	char c;
+	char *start = dst;
+	int state = 0;
+
+	_DIAGASSERT(src != NULL);
+	_DIAGASSERT(dst != NULL);
+
+	while ((c = *src++) != '\0') {
+	again:
+		switch (__unvis13(dst, c, &state, 0)) {
+		case UNVIS_VALID:
+			dst++;
+			break;
+		case UNVIS_VALIDPUSH:
+			dst++;
+			goto again;
+		case 0:
+		case UNVIS_NOCHAR:
+			break;
+		default:
+			return (-1);
+		}
+	}
+	if (__unvis13(dst, c, &state, UNVIS_END) == UNVIS_VALID)
+		dst++;
+	*dst = '\0';
+	return (dst - start);
+}
diff -ru -ruN mtree/unvis.c.orig mtree-linux/unvis.c.orig
--- mtree/unvis.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ mtree-linux/unvis.c.orig	2000-01-22 23:19:13.000000000 +0100
@@ -0,0 +1,285 @@
+/*	$NetBSD: unvis.c,v 1.19 2000/01/22 22:19:13 mycroft Exp $	*/
+
+/*-
+ * Copyright (c) 1989, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+#if defined(LIBC_SCCS) && !defined(lint)
+#if 0
+static char sccsid[] = "@(#)unvis.c	8.1 (Berkeley) 6/4/93";
+#else
+__RCSID("$NetBSD: unvis.c,v 1.19 2000/01/22 22:19:13 mycroft Exp $");
+#endif
+#endif /* LIBC_SCCS and not lint */
+
+#define __LIBC12_SOURCE__
+
+#include "namespace.h"
+#include <sys/types.h>
+
+#include <assert.h>
+#include <ctype.h>
+#include <stdio.h>
+#include <vis.h>
+
+#ifdef __weak_alias
+__weak_alias(strunvis,_strunvis)
+__weak_alias(unvis,_unvis)
+#endif
+
+__warn_references(unvis,
+    "warning: reference to compatibility unvis(); include <vis.h> for correct reference")
+
+/*
+ * decode driven by state machine
+ */
+#define	S_GROUND	0	/* haven't seen escape char */
+#define	S_START		1	/* start decoding special sequence */
+#define	S_META		2	/* metachar started (M) */
+#define	S_META1		3	/* metachar more, regular char (-) */
+#define	S_CTRL		4	/* control char started (^) */
+#define	S_OCTAL2	5	/* octal digit 2 */
+#define	S_OCTAL3	6	/* octal digit 3 */
+
+#define	isoctal(c)	(((u_char)(c)) >= '0' && ((u_char)(c)) <= '7')
+
+int
+unvis(cp, c, astate, flag)
+	char *cp;
+	int c;
+	int *astate, flag;
+{
+	return __unvis13(cp, (int)c, astate, flag);
+}
+
+/*
+ * unvis - decode characters previously encoded by vis
+ */
+int
+__unvis13(cp, c, astate, flag)
+	char *cp;
+	int c;
+	int *astate, flag;
+{
+
+	_DIAGASSERT(cp != NULL);
+	_DIAGASSERT(astate != NULL);
+
+	if (flag & UNVIS_END) {
+		if (*astate == S_OCTAL2 || *astate == S_OCTAL3) {
+			*astate = S_GROUND;
+			return (UNVIS_VALID);
+		} 
+		return (*astate == S_GROUND ? UNVIS_NOCHAR : UNVIS_SYNBAD);
+	}
+
+	switch (*astate) {
+
+	case S_GROUND:
+		*cp = 0;
+		if (c == '\\') {
+			*astate = S_START;
+			return (0);
+		} 
+		*cp = c;
+		return (UNVIS_VALID);
+
+	case S_START:
+		switch(c) {
+		case '\\':
+			*cp = c;
+			*astate = S_GROUND;
+			return (UNVIS_VALID);
+		case '0': case '1': case '2': case '3':
+		case '4': case '5': case '6': case '7':
+			*cp = (c - '0');
+			*astate = S_OCTAL2;
+			return (0);
+		case 'M':
+			*cp = (char)0200;
+			*astate = S_META;
+			return (0);
+		case '^':
+			*astate = S_CTRL;
+			return (0);
+		case 'n':
+			*cp = '\n';
+			*astate = S_GROUND;
+			return (UNVIS_VALID);
+		case 'r':
+			*cp = '\r';
+			*astate = S_GROUND;
+			return (UNVIS_VALID);
+		case 'b':
+			*cp = '\b';
+			*astate = S_GROUND;
+			return (UNVIS_VALID);
+		case 'a':
+			*cp = '\007';
+			*astate = S_GROUND;
+			return (UNVIS_VALID);
+		case 'v':
+			*cp = '\v';
+			*astate = S_GROUND;
+			return (UNVIS_VALID);
+		case 't':
+			*cp = '\t';
+			*astate = S_GROUND;
+			return (UNVIS_VALID);
+		case 'f':
+			*cp = '\f';
+			*astate = S_GROUND;
+			return (UNVIS_VALID);
+		case 's':
+			*cp = ' ';
+			*astate = S_GROUND;
+			return (UNVIS_VALID);
+		case 'E':
+			*cp = '\033';
+			*astate = S_GROUND;
+			return (UNVIS_VALID);
+		case '\n':
+			/*
+			 * hidden newline
+			 */
+			*astate = S_GROUND;
+			return (UNVIS_NOCHAR);
+		case '$':
+			/*
+			 * hidden marker
+			 */
+			*astate = S_GROUND;
+			return (UNVIS_NOCHAR);
+		}
+		*astate = S_GROUND;
+		return (UNVIS_SYNBAD);
+		 
+	case S_META:
+		if (c == '-')
+			*astate = S_META1;
+		else if (c == '^')
+			*astate = S_CTRL;
+		else {
+			*astate = S_GROUND;
+			return (UNVIS_SYNBAD);
+		}
+		return (0);
+		 
+	case S_META1:
+		*astate = S_GROUND;
+		*cp |= c;
+		return (UNVIS_VALID);
+		 
+	case S_CTRL:
+		if (c == '?')
+			*cp |= 0177;
+		else
+			*cp |= c & 037;
+		*astate = S_GROUND;
+		return (UNVIS_VALID);
+
+	case S_OCTAL2:	/* second possible octal digit */
+		if (isoctal(c)) {
+			/* 
+			 * yes - and maybe a third 
+			 */
+			*cp = (*cp << 3) + (c - '0');
+			*astate = S_OCTAL3;	
+			return (0);
+		} 
+		/* 
+		 * no - done with current sequence, push back passed char 
+		 */
+		*astate = S_GROUND;
+		return (UNVIS_VALIDPUSH);
+
+	case S_OCTAL3:	/* third possible octal digit */
+		*astate = S_GROUND;
+		if (isoctal(c)) {
+			*cp = (*cp << 3) + (c - '0');
+			return (UNVIS_VALID);
+		}
+		/*
+		 * we were done, push back passed char
+		 */
+		return (UNVIS_VALIDPUSH);
+			
+	default:	
+		/* 
+		 * decoder in unknown state - (probably uninitialized) 
+		 */
+		*astate = S_GROUND;
+		return (UNVIS_SYNBAD);
+	}
+}
+
+/*
+ * strunvis - decode src into dst 
+ *
+ *	Number of chars decoded into dst is returned, -1 on error.
+ *	Dst is null terminated.
+ */
+
+int
+strunvis(dst, src)
+	char *dst;
+	const char *src;
+{
+	char c;
+	char *start = dst;
+	int state = 0;
+
+	_DIAGASSERT(src != NULL);
+	_DIAGASSERT(dst != NULL);
+
+	while ((c = *src++) != '\0') {
+	again:
+		switch (__unvis13(dst, c, &state, 0)) {
+		case UNVIS_VALID:
+			dst++;
+			break;
+		case UNVIS_VALIDPUSH:
+			dst++;
+			goto again;
+		case 0:
+		case UNVIS_NOCHAR:
+			break;
+		default:
+			return (-1);
+		}
+	}
+	if (__unvis13(dst, c, &state, UNVIS_END) == UNVIS_VALID)
+		dst++;
+	*dst = '\0';
+	return (dst - start);
+}
diff -ru -ruN mtree/verify.c mtree-linux/verify.c
--- mtree/verify.c	2006-07-28 18:27:40.000000000 +0200
+++ mtree-linux/verify.c	1999-02-11 16:32:24.000000000 +0100
@@ -1,3 +1,5 @@
+/*	$NetBSD: verify.c,v 1.17 1999/02/11 15:32:24 mrg Exp $	*/
+
 /*-
  * Copyright (c) 1990, 1993
  *	The Regents of the University of California.  All rights reserved.
@@ -10,7 +12,11 @@
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
  *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
  *
@@ -27,113 +33,109 @@
  * SUCH DAMAGE.
  */
 
-#if 0
+#include <sys/cdefs.h>
 #ifndef lint
+#if 0
 static char sccsid[] = "@(#)verify.c	8.1 (Berkeley) 6/6/93";
-#endif /* not lint */
+#else
+__RCSID("$NetBSD: verify.c,v 1.17 1999/02/11 15:32:24 mrg Exp $");
 #endif
-#include <sys/cdefs.h>
-__FBSDID("$FreeBSD: src/usr.sbin/mtree/verify.c,v 1.23.8.2 2006/07/28 16:27:40 maxim Exp $");
+#endif /* not lint */
 
 #include <sys/param.h>
 #include <sys/stat.h>
 #include <dirent.h>
-#include <err.h>
-#include <errno.h>
 #include <fts.h>
 #include <fnmatch.h>
-#include <stdio.h>
 #include <unistd.h>
+#include <errno.h>
+#include <stdio.h>
 #include "mtree.h"
 #include "extern.h"
 
+extern int crc_total, ftsoptions;
+extern int dflag, eflag, iflag, rflag, sflag, uflag;
+extern char fullpath[MAXPATHLEN];
+
 static NODE *root;
 static char path[MAXPATHLEN];
 
-static void	miss(NODE *, char *);
-static int	vwalk(void);
+static void	miss __P((NODE *, char *));
+static int	vwalk __P((void));
 
 int
-mtree_verifyspec(FILE *fi)
+verify()
 {
 	int rval;
 
-	root = mtree_readspec(fi);
+	root = spec();
 	rval = vwalk();
 	miss(root, path);
 	return (rval);
 }
 
 static int
-vwalk(void)
+vwalk()
 {
 	FTS *t;
 	FTSENT *p;
 	NODE *ep, *level;
-	int specdepth, rval;
+	int ftsdepth, specdepth, rval;
 	char *argv[2];
-	char dot[] = ".";
 
-	argv[0] = dot;
+	argv[0] = ".";
 	argv[1] = NULL;
 	if ((t = fts_open(argv, ftsoptions, NULL)) == NULL)
-		err(1, "line %d: fts_open", lineno);
+		mtree_err("fts_open: %s", strerror(errno));
 	level = root;
-	specdepth = rval = 0;
-	while ((p = fts_read(t))) {
-		if (check_excludes(p->fts_name, p->fts_path)) {
-			fts_set(t, p, FTS_SKIP);
-			continue;
-		}
+	ftsdepth = specdepth = rval = 0;
+	while ((p = fts_read(t)) != NULL) {
 		switch(p->fts_info) {
 		case FTS_D:
-		case FTS_SL:
+			++ftsdepth; 
 			break;
 		case FTS_DP:
-			if (specdepth > p->fts_level) {
+			--ftsdepth; 
+			if (specdepth > ftsdepth) {
 				for (level = level->parent; level->prev;
-				      level = level->prev);
+				      level = level->prev);  
 				--specdepth;
 			}
 			continue;
 		case FTS_DNR:
 		case FTS_ERR:
 		case FTS_NS:
-			warnx("%s: %s", RP(p), strerror(p->fts_errno));
+			(void)fprintf(stderr, "mtree: %s: %s\n",
+			    RP(p), strerror(errno));
 			continue;
 		default:
 			if (dflag)
 				continue;
 		}
 
-		if (specdepth != p->fts_level)
-			goto extra;
 		for (ep = level; ep; ep = ep->next)
 			if ((ep->flags & F_MAGIC &&
 			    !fnmatch(ep->name, p->fts_name, FNM_PATHNAME)) ||
 			    !strcmp(ep->name, p->fts_name)) {
 				ep->flags |= F_VISIT;
-				if ((ep->flags & F_NOCHANGE) == 0 &&
-				    compare(ep->name, ep, p))
+				if (compare(ep->name, ep, p))
 					rval = MISMATCHEXIT;
-				if (ep->flags & F_IGN)
-					(void)fts_set(t, p, FTS_SKIP);
-				else if (ep->child && ep->type == F_DIR &&
+				if (!(ep->flags & F_IGN) &&
+				    ep->child && ep->type == F_DIR &&
 				    p->fts_info == FTS_D) {
 					level = ep->child;
 					++specdepth;
-				}
+				} else
+					(void)fts_set(t, p, FTS_SKIP);
 				break;
 			}
 
 		if (ep)
 			continue;
-extra:
 		if (!eflag) {
-			(void)printf("%s extra", RP(p));
+			(void)printf("extra: %s", RP(p));
 			if (rflag) {
-				if ((S_ISDIR(p->fts_statp->st_mode)
-				    ? rmdir : unlink)(p->fts_accpath)) {
+				if (unlink(p->fts_accpath)) {
 					(void)printf(", not removed: %s",
 					    strerror(errno));
 				} else
@@ -145,17 +147,19 @@
 	}
 	(void)fts_close(t);
 	if (sflag)
-		warnx("%s checksum: %lu", fullpath, (unsigned long)crc_total);
+		(void)fprintf(stderr,
+		    "mtree: %s checksum: %u\n", fullpath, crc_total);
 	return (rval);
 }
 
 static void
-miss(NODE *p, char *tail)
+miss(p, tail)
+	NODE *p;
+	char *tail;
 {
 	int create;
 	char *tp;
-	const char *type, *what;
-	int serr;
+	u_int32_t flags;
 
 	for (; p; p = p->next) {
 		if (p->flags & F_OPT && !(p->flags & F_VISIT))
@@ -163,56 +167,23 @@
 		if (p->type != F_DIR && (dflag || p->flags & F_VISIT))
 			continue;
 		(void)strcpy(tail, p->name);
-		if (!(p->flags & F_VISIT)) {
-			/* Don't print missing message if file exists as a
-			   symbolic link and the -q flag is set. */
-			struct stat statbuf;
-
-			if (qflag && stat(path, &statbuf) == 0)
-				p->flags |= F_VISIT;
-			else
-				(void)printf("%s missing", path);
-		}
-		if (p->type != F_DIR && p->type != F_LINK) {
+		if (!(p->flags & F_VISIT))
+			(void)printf("missing: %s", path);
+		if (p->type != F_DIR) {
 			putchar('\n');
 			continue;
 		}
 
 		create = 0;
-		if (p->type == F_LINK)
-			type = "symlink";
-		else
-			type = "directory";
 		if (!(p->flags & F_VISIT) && uflag) {
 			if (!(p->flags & (F_UID | F_UNAME)))
-				(void)printf(" (%s not created: user not specified)", type);
+			    (void)printf(" (not created: user not specified)");
 			else if (!(p->flags & (F_GID | F_GNAME)))
-				(void)printf(" (%s not created: group not specified)", type);
-			else if (p->type == F_LINK) {
-				if (symlink(p->slink, path))
-					(void)printf(" (symlink not created: %s)\n",
-					    strerror(errno));
-				else
-					(void)printf(" (created)\n");
-				if (lchown(path, p->st_uid, p->st_gid) == -1) {
-					serr = errno;
-					if (p->st_uid == (uid_t)-1)
-						what = "group";
-					else if (lchown(path, (uid_t)-1,
-					    p->st_gid) == -1)
-						what = "user & group";
-					else {
-						what = "user";
-						errno = serr;
-					}
-					(void)printf("%s: %s not modified: %s"
-					    "\n", path, what, strerror(errno));
-				}
-				continue;
-			} else if (!(p->flags & F_MODE))
-			    (void)printf(" (directory not created: mode not specified)");
+			    (void)printf(" (not created: group not specified)");
+			else if (!(p->flags & F_MODE))
+			    (void)printf(" (not created: mode not specified)");
 			else if (mkdir(path, S_IRWXU))
-				(void)printf(" (directory not created: %s)",
+				(void)printf(" (not created: %s)",
 				    strerror(errno));
 			else {
 				create = 1;
@@ -222,32 +193,32 @@
 		if (!(p->flags & F_VISIT))
 			(void)putchar('\n');
 
-		for (tp = tail; *tp; ++tp);
+		for (tp = tail; *tp; ++tp)
+			;
 		*tp = '/';
 		miss(p->child, tp + 1);
 		*tp = '\0';
 
 		if (!create)
 			continue;
-		if (chown(path, p->st_uid, p->st_gid) == -1) {
-			serr = errno;
-			if (p->st_uid == (uid_t)-1)
-				what = "group";
-			else if (chown(path, (uid_t)-1, p->st_gid) == -1)
-				what = "user & group";
-			else {
-				what = "user";
-				errno = serr;
-			}
-			(void)printf("%s: %s not modified: %s\n",
-			    path, what, strerror(errno));
+		if (chown(path, p->st_uid, p->st_gid)) {
+			(void)printf("%s: user/group/mode not modified: %s\n",
+			    path, strerror(errno));
+			(void)printf("%s: warning: file mode %snot set\n", path,
+			    (p->flags & F_FLAGS) ? "and file flags " : "");
+			continue;
 		}
 		if (chmod(path, p->st_mode))
 			(void)printf("%s: permissions not set: %s\n",
 			    path, strerror(errno));
-		if ((p->flags & F_FLAGS) && p->st_flags &&
-		    chflags(path, p->st_flags))
-			(void)printf("%s: file flags not set: %s\n",
-			    path, strerror(errno));
+		if ((p->flags & F_FLAGS) && p->st_flags) {
+			if (iflag)
+				flags = p->st_flags;
+			else
+				flags = p->st_flags & ~SP_FLGS;
+			if (chflags(path, flags))
+				(void)printf("%s: file flags not set: %s\n",
+				    path, strerror(errno));
+		}
 	}
 }
diff -ru -ruN mtree/vis.3 mtree-linux/vis.3
--- mtree/vis.3	1970-01-01 01:00:00.000000000 +0100
+++ mtree-linux/vis.3	1999-11-25 17:52:29.000000000 +0100
@@ -0,0 +1,327 @@
+.\"	$NetBSD: vis.3,v 1.12 1999/11/25 16:52:29 wennmach Exp $
+.\"
+.\" Copyright (c) 1989, 1991, 1993
+.\"	The Regents of the University of California.  All rights reserved.
+.\"
+.\" Redistribution and use in source and binary forms, with or without
+.\" modification, are permitted provided that the following conditions
+.\" are met:
+.\" 1. Redistributions of source code must retain the above copyright
+.\"    notice, this list of conditions and the following disclaimer.
+.\" 2. Redistributions in binary form must reproduce the above copyright
+.\"    notice, this list of conditions and the following disclaimer in the
+.\"    documentation and/or other materials provided with the distribution.
+.\" 3. All advertising materials mentioning features or use of this software
+.\"    must display the following acknowledgement:
+.\"	This product includes software developed by the University of
+.\"	California, Berkeley and its contributors.
+.\" 4. Neither the name of the University nor the names of its contributors
+.\"    may be used to endorse or promote products derived from this software
+.\"    without specific prior written permission.
+.\"
+.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+.\" SUCH DAMAGE.
+.\"
+.\"     @(#)vis.3	8.1 (Berkeley) 6/9/93
+.\"
+.Dd June 9, 1993
+.Dt VIS 3
+.Os
+.Sh NAME
+.Nm vis ,
+.Nm strvis ,
+.Nm strvisx ,
+.Nm svis ,
+.Nm strsvis ,
+.Nm strsvisx
+.Nd visually encode characters
+.Sh LIBRARY
+.Lb libc
+.Sh SYNOPSIS
+.Fd #include <vis.h>
+.Ft char *
+.Fn vis "char *dst" "int c" "int flag" "int nextc"
+.Ft int 
+.Fn strvis "char *dst" "const char *src" "int flag"
+.Ft int 
+.Fn strvisx "char *dst" "const char *src" "size_t len" "int flag"
+.Ft char *
+.Fn svis "char *dst" "int c" "int flag" "int nextc" "const char *extra"
+.Ft int 
+.Fn strsvis "char *dst" "const char *src" "int flag" "const char *extra"
+.Ft int 
+.Fn strsvisx "char *dst" "const char *src" "size_t len" "int flag" "const char *extra"
+.Sh DESCRIPTION
+The
+.Fn vis
+function
+copies into
+.Fa dst
+a string which represents the character
+.Fa c .
+If
+.Fa c
+needs no encoding, it is copied in unaltered.  The string is
+null terminated, and a pointer to the end of the string is
+returned.  The maximum length of any encoding is four
+characters (not including the trailing
+.Dv NUL ) ; 
+thus, when
+encoding a set of characters into a buffer, the size of the buffer should
+be four times the number of characters encoded, plus one for the trailing
+.Dv NUL . 
+The flag parameter is used for altering the default range of
+characters considered for encoding and for altering the visual
+representation.
+The additional character,
+.Fa nextc ,
+is only used when selecting the
+.Dv VIS_CSTYLE
+encoding format (explained below).
+.Pp
+The
+.Fn strvis
+and
+.Fn strvisx
+functions copy into
+.Fa dst
+a visual representation of
+the string
+.Fa src .
+The
+.Fn strvis
+function encodes characters from
+.Fa src
+up to the
+first
+.Dv NUL . 
+The
+.Fn strvisx
+function encodes exactly
+.Fa len
+characters from
+.Fa src
+(this
+is useful for encoding a block of data that may contain
+.Dv NUL Ns 's).
+Both forms
+.Dv NUL
+terminate
+.Fa dst .
+The size of
+.Fa dst
+must be four times the number
+of characters encoded from
+.Fa src
+(plus one for the
+.Dv NUL ) . 
+Both
+forms return the number of characters in dst (not including
+the trailing
+.Dv NUL ) . 
+.Pp
+The functions
+.Fn svis ,
+.Fn strsvis ,
+and
+.Fn strsvisx 
+correspond to
+.Fn vis ,
+.Fn strvis ,
+and
+.Fn strvisx 
+but have an additional argument
+.Fa extra ,
+pointing to a
+.Dv NUL
+terminated list of characters. These characters will be copied encoded or
+backslash-escaped into
+.Fa dst .
+These functions are useful e. g. to remove the special meaning
+of certain characters to shells.
+.Pp
+The encoding is a unique, invertible representation composed entirely of
+graphic characters; it can be decoded back into the original form using 
+the
+.Xr unvis 3
+or
+.Xr strunvis 3
+functions.
+.Pp
+There are two parameters that can be controlled: the range of
+characters that are encoded (applies only to
+.Fn vis ,
+.Fn strvis ,
+and
+.Fn strvisx ) ,
+and the type of representation used.  
+By default, all non-graphic characters,
+except space, tab, and newline are encoded.
+(See
+.Xr isgraph 3 . )
+The following flags
+alter this:
+.Bl -tag -width VIS_WHITEX
+.It Dv VIS_SP
+Also encode space.
+.It Dv VIS_TAB		
+Also encode tab.
+.It Dv VIS_NL
+Also encode newline.
+.It Dv VIS_WHITE	
+Synonym for
+.Dv VIS_SP
+\&|
+.Dv VIS_TAB
+\&|
+.Dv VIS_NL .
+.It Dv VIS_SAFE	
+Only encode "unsafe" characters.  Unsafe means control
+characters which may cause common terminals to perform
+unexpected functions.  Currently this form allows space,
+tab, newline, backspace, bell, and return - in addition
+to all graphic characters - unencoded. 
+.El
+.Pp
+(The above flags have no effect for
+.Fn svis ,
+.Fn strsvis ,
+and
+.Fn strsvisx .
+When using these functions, place all graphic characters to be
+encoded in an array pointed to by
+.Fa extra .
+In general, the backslash character should be included in this array, see the
+warning on the use of the
+.Dv VIS_NOSLASH
+flag below).
+.Pp
+There are three forms of encoding.
+All forms use the backslash character
+.Ql \e
+to introduce a special
+sequence; two backslashes are used to represent a real backslash.
+These are the visual formats:
+.Bl -tag -width VIS_CSTYLE
+.It (default)
+Use an
+.Ql M
+to represent meta characters (characters with the 8th
+bit set), and use caret
+.Ql ^
+to represent control characters see
+.Pf ( Xr iscntrl 3 ) .
+The following formats are used:
+.Bl -tag -width xxxxx
+.It Dv \e^C
+Represents the control character
+.Ql C .
+Spans characters
+.Ql \e000
+through
+.Ql \e037 ,
+and
+.Ql \e177
+(as
+.Ql \e^? ) .
+.It Dv \eM-C
+Represents character
+.Ql C
+with the 8th bit set.
+Spans characters
+.Ql \e241
+through
+.Ql \e376 .
+.It Dv \eM^C
+Represents control character
+.Ql C
+with the 8th bit set.
+Spans characters
+.Ql \e200
+through
+.Ql \e237 ,
+and
+.Ql \e377
+(as
+.Ql \eM^? ) .
+.It Dv \e040
+Represents
+.Tn ASCII
+space.
+.It Dv \e240
+Represents Meta-space.
+.El
+.Pp
+.It Dv VIS_CSTYLE
+Use C-style backslash sequences to represent standard non-printable
+characters.
+The following sequences are used to represent the indicated characters:
+.Bd -unfilled -offset indent
+.Li \ea Tn  - BEL No (007)
+.Li \eb Tn  - BS No (010)
+.Li \ef Tn  - NP No (014)
+.Li \en Tn  - NL No (012)
+.Li \er Tn  - CR No (015)
+.Li \et Tn  - HT No (011)
+.Li \ev Tn  - VT No (013)
+.Li \e0 Tn  - NUL No (000)
+.Ed
+.Pp
+When using this format, the nextc parameter is looked at to determine
+if a
+.Dv NUL
+character can be encoded as
+.Ql \e0
+instead of
+.Ql \e000 .
+If
+.Fa nextc
+is an octal digit, the latter representation is used to
+avoid ambiguity.
+.It Dv VIS_OCTAL
+Use a three digit octal sequence.  The form is
+.Ql \eddd
+where
+.Em d
+represents an octal digit.
+.El
+.Pp
+There is one additional flag,
+.Dv VIS_NOSLASH ,
+which inhibits the
+doubling of backslashes and the backslash before the default
+format (that is, control characters are represented by
+.Ql ^C
+and
+meta characters as
+.Ql M-C ) .
+With this flag set, the encoding is
+ambiguous and non-invertible.
+.Sh SEE ALSO
+.Xr vis 1 ,
+.Xr unvis 1 ,
+.Xr unvis 3
+.Sh HISTORY
+The
+.Fa vis ,
+.Fa strvis ,
+and
+.Fa strvisx
+functions first appeared in
+.Bx 4.4 .
+The
+.Fa svis ,
+.Fa strsvis ,
+and
+.Fa strsvisx
+functions appeared in NetBSD 1.5.
+
diff -ru -ruN mtree/vis.c mtree-linux/vis.c
--- mtree/vis.c	1970-01-01 01:00:00.000000000 +0100
+++ mtree-linux/vis.c	2001-08-06 10:23:55.000000000 +0200
@@ -0,0 +1,300 @@
+/*	$NetBSD: vis.c,v 1.19 2000/01/22 22:42:45 mycroft Exp $	*/
+
+/*-
+ * Copyright (c) 1999 The NetBSD Foundation, Inc.
+ * Copyright (c) 1989, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+
+#include <sys/cdefs.h>
+#if !defined(lint)
+__RCSID("$NetBSD: vis.c,v 1.19 2000/01/22 22:42:45 mycroft Exp $");
+#endif /* not lint */
+
+/*#include "namespace.h"*/
+#include <sys/types.h>
+
+#include <assert.h>
+#include <ctype.h>
+#include <limits.h>
+#include <stdio.h>
+#include <string.h>
+#include <vis.h>
+
+#ifndef _DIAGASSERT
+#define _DIAGASSERT(cond)	assert(cond)
+#endif
+
+#ifdef __weak_alias
+__weak_alias(strsvis,_strsvis)
+__weak_alias(strsvisx,_strsvisx)
+__weak_alias(strvis,_strvis)
+__weak_alias(strvisx,_strvisx)
+__weak_alias(svis,_svis)
+__weak_alias(vis,_vis)
+#endif
+
+#undef BELL
+#if defined(__STDC__)
+#define BELL '\a'
+#else
+#define BELL '\007'
+#endif
+
+#define isoctal(c)	(((u_char)(c)) >= '0' && ((u_char)(c)) <= '7')
+#define iswhite(c)	(c == ' ' || c == '\t' || c == '\n')
+#define issafe(c)	(c == '\b' || c == BELL || c == '\r')
+
+#define MAXEXTRAS       5
+
+
+#define MAKEEXTRALIST(flag, extra)					      \
+do {									      \
+	char *pextra = extra;						      \
+	if (flag & VIS_SP) *pextra++ = ' ';				      \
+	if (flag & VIS_TAB) *pextra++ = '\t';				      \
+	if (flag & VIS_NL) *pextra++ = '\n';				      \
+	if ((flag & VIS_NOSLASH) == 0) *pextra++ = '\\';		      \
+	*pextra = '\0';							      \
+} while (/*CONSTCOND*/0)
+
+/*
+ * This is SVIS, the central macro of vis.
+ * dst:	      Pointer to the destination buffer
+ * c:	      Character to encode
+ * flag:      Flag word
+ * nextc:     The character following 'c'
+ * extra:     Pointer to the list of extra characters to be
+ *	      backslash-protected.
+ */
+#define SVIS(dst, c, flag, nextc, extra)				      \
+do {									      \
+	int isextra, isc;						      \
+	isextra = strchr(extra, c) != NULL;				      \
+	if (!isextra && isascii(c) && (isgraph(c) || iswhite(c) ||	      \
+	    ((flag & VIS_SAFE) && issafe(c)))) {			      \
+		*dst++ = c;						      \
+		break;							      \
+	}								      \
+	isc = 0;							      \
+	if (flag & VIS_CSTYLE) {					      \
+		switch (c) {						      \
+		case '\n':						      \
+			isc = 1; *dst++ = '\\'; *dst++ = 'n';		      \
+			break;						      \
+		case '\r':						      \
+			isc = 1; *dst++ = '\\'; *dst++ = 'r';		      \
+			break;						      \
+		case '\b':						      \
+			isc = 1; *dst++ = '\\'; *dst++ = 'b';		      \
+			break;						      \
+		case BELL:						      \
+			isc = 1; *dst++ = '\\'; *dst++ = 'a';		      \
+			break;						      \
+		case '\v':						      \
+			isc = 1; *dst++ = '\\'; *dst++ = 'v';		      \
+			break;						      \
+		case '\t':						      \
+			isc = 1; *dst++ = '\\'; *dst++ = 't';		      \
+			break;						      \
+		case '\f':						      \
+			isc = 1; *dst++ = '\\'; *dst++ = 'f';		      \
+			break;						      \
+		case ' ':						      \
+			isc = 1; *dst++ = '\\'; *dst++ = 's';		      \
+			break;						      \
+		case '\0':						      \
+			isc = 1; *dst++ = '\\'; *dst++ = '0';		      \
+			if (isoctal(nextc)) {				      \
+				*dst++ = '0';				      \
+				*dst++ = '0';				      \
+			}						      \
+		}							      \
+	}								      \
+	if (isc) break;							      \
+	if (isextra || ((c & 0177) == ' ') || (flag & VIS_OCTAL)) {	      \
+		*dst++ = '\\';						      \
+		*dst++ = (u_char)(((u_int32_t)(u_char)c >> 6) & 03) + '0';    \
+		*dst++ = (u_char)(((u_int32_t)(u_char)c >> 3) & 07) + '0';    \
+		*dst++ =			     (c	      & 07) + '0';    \
+	} else {							      \
+		if ((flag & VIS_NOSLASH) == 0) *dst++ = '\\';		      \
+		if (c & 0200) {						      \
+			c &= 0177; *dst++ = 'M';			      \
+		}							      \
+		if (iscntrl(c)) {					      \
+			*dst++ = '^';					      \
+			if (c == 0177)					      \
+				*dst++ = '?';				      \
+			else						      \
+				*dst++ = c + '@';			      \
+		} else {						      \
+			*dst++ = '-'; *dst++ = c;			      \
+		}							      \
+	}								      \
+} while (/*CONSTCOND*/0)
+
+
+/*
+ * svis - visually encode characters, also encoding the characters
+ * 	  pointed to by `extra'
+ */
+char *
+svis(dst, c, flag, nextc, extra)
+	char *dst;
+	int c, flag, nextc;
+	const char *extra;
+{
+	_DIAGASSERT(dst != NULL);
+	_DIAGASSERT(extra != NULL);
+
+	SVIS(dst, c, flag, nextc, extra);
+	*dst = '\0';
+	return(dst);
+}
+
+
+/*
+ * strsvis, strsvisx - visually encode characters from src into dst
+ *
+ *	Extra is a pointer to a \0-terminated list of characters to
+ *	be encoded, too. These functions are useful e. g. to
+ *	encode strings in such a way so that they are not interpreted
+ *	by a shell.
+ *	
+ *	Dst must be 4 times the size of src to account for possible
+ *	expansion.  The length of dst, not including the trailing NULL,
+ *	is returned. 
+ *
+ *	Strsvisx encodes exactly len bytes from src into dst.
+ *	This is useful for encoding a block of data.
+ */
+int
+strsvis(dst, src, flag, extra)
+	char *dst;
+	const char *src;
+	int flag;
+	const char *extra;
+{
+	char c;
+	char *start;
+
+	_DIAGASSERT(dst != NULL);
+	_DIAGASSERT(src != NULL);
+	_DIAGASSERT(extra != NULL);
+
+	for (start = dst; (c = *src++) != '\0'; /* empty */)
+	    SVIS(dst, c, flag, *src, extra);
+	*dst = '\0';
+	return (dst - start);
+}
+
+
+int
+strsvisx(dst, src, len, flag, extra)
+	char *dst;
+	const char *src;
+	size_t len;
+	int flag;
+	const char *extra;
+{
+	char c;
+	char *start;
+
+	_DIAGASSERT(dst != NULL);
+	_DIAGASSERT(src != NULL);
+	_DIAGASSERT(extra != NULL);
+
+	for (start = dst; len > 0; len--) {
+		c = *src++;
+		SVIS(dst, c, flag, len ? *src : '\0', extra);
+	}
+	*dst = '\0';
+	return (dst - start);
+}
+
+
+/*
+ * vis - visually encode characters
+ */
+char *
+vis(dst, c, flag, nextc)
+	char *dst;
+	int c, flag, nextc;
+	
+{
+	char extra[MAXEXTRAS];
+
+	_DIAGASSERT(dst != NULL);
+
+	MAKEEXTRALIST(flag, extra);
+	SVIS(dst, c, flag, nextc, extra);
+	*dst = '\0';
+	return (dst);
+}
+
+
+/*
+ * strvis, strvisx - visually encode characters from src into dst
+ *	
+ *	Dst must be 4 times the size of src to account for possible
+ *	expansion.  The length of dst, not including the trailing NULL,
+ *	is returned. 
+ *
+ *	Strvisx encodes exactly len bytes from src into dst.
+ *	This is useful for encoding a block of data.
+ */
+int
+strvis(dst, src, flag)
+	char *dst;
+	const char *src;
+	int flag;
+{
+	char extra[MAXEXTRAS];
+
+	MAKEEXTRALIST(flag, extra);
+	return (strsvis(dst, src, flag, extra));
+}
+
+
+int
+strvisx(dst, src, len, flag)
+	char *dst;
+	const char *src;
+	size_t len;
+	int flag;
+{
+	char extra[MAXEXTRAS];
+
+	MAKEEXTRALIST(flag, extra);
+	return (strsvisx(dst, src, len, flag, extra));
+}
diff -ru -ruN mtree/vis.c.orig mtree-linux/vis.c.orig
--- mtree/vis.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ mtree-linux/vis.c.orig	2000-01-22 23:42:45.000000000 +0100
@@ -0,0 +1,296 @@
+/*	$NetBSD: vis.c,v 1.19 2000/01/22 22:42:45 mycroft Exp $	*/
+
+/*-
+ * Copyright (c) 1999 The NetBSD Foundation, Inc.
+ * Copyright (c) 1989, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+
+#include <sys/cdefs.h>
+#if !defined(lint)
+__RCSID("$NetBSD: vis.c,v 1.19 2000/01/22 22:42:45 mycroft Exp $");
+#endif /* not lint */
+
+#include "namespace.h"
+#include <sys/types.h>
+
+#include <assert.h>
+#include <ctype.h>
+#include <limits.h>
+#include <stdio.h>
+#include <string.h>
+#include <vis.h>
+
+#ifdef __weak_alias
+__weak_alias(strsvis,_strsvis)
+__weak_alias(strsvisx,_strsvisx)
+__weak_alias(strvis,_strvis)
+__weak_alias(strvisx,_strvisx)
+__weak_alias(svis,_svis)
+__weak_alias(vis,_vis)
+#endif
+
+#undef BELL
+#if defined(__STDC__)
+#define BELL '\a'
+#else
+#define BELL '\007'
+#endif
+
+#define isoctal(c)	(((u_char)(c)) >= '0' && ((u_char)(c)) <= '7')
+#define iswhite(c)	(c == ' ' || c == '\t' || c == '\n')
+#define issafe(c)	(c == '\b' || c == BELL || c == '\r')
+
+#define MAXEXTRAS       5
+
+
+#define MAKEEXTRALIST(flag, extra)					      \
+do {									      \
+	char *pextra = extra;						      \
+	if (flag & VIS_SP) *pextra++ = ' ';				      \
+	if (flag & VIS_TAB) *pextra++ = '\t';				      \
+	if (flag & VIS_NL) *pextra++ = '\n';				      \
+	if ((flag & VIS_NOSLASH) == 0) *pextra++ = '\\';		      \
+	*pextra = '\0';							      \
+} while (/*CONSTCOND*/0)
+
+/*
+ * This is SVIS, the central macro of vis.
+ * dst:	      Pointer to the destination buffer
+ * c:	      Character to encode
+ * flag:      Flag word
+ * nextc:     The character following 'c'
+ * extra:     Pointer to the list of extra characters to be
+ *	      backslash-protected.
+ */
+#define SVIS(dst, c, flag, nextc, extra)				      \
+do {									      \
+	int isextra, isc;						      \
+	isextra = strchr(extra, c) != NULL;				      \
+	if (!isextra && isascii(c) && (isgraph(c) || iswhite(c) ||	      \
+	    ((flag & VIS_SAFE) && issafe(c)))) {			      \
+		*dst++ = c;						      \
+		break;							      \
+	}								      \
+	isc = 0;							      \
+	if (flag & VIS_CSTYLE) {					      \
+		switch (c) {						      \
+		case '\n':						      \
+			isc = 1; *dst++ = '\\'; *dst++ = 'n';		      \
+			break;						      \
+		case '\r':						      \
+			isc = 1; *dst++ = '\\'; *dst++ = 'r';		      \
+			break;						      \
+		case '\b':						      \
+			isc = 1; *dst++ = '\\'; *dst++ = 'b';		      \
+			break;						      \
+		case BELL:						      \
+			isc = 1; *dst++ = '\\'; *dst++ = 'a';		      \
+			break;						      \
+		case '\v':						      \
+			isc = 1; *dst++ = '\\'; *dst++ = 'v';		      \
+			break;						      \
+		case '\t':						      \
+			isc = 1; *dst++ = '\\'; *dst++ = 't';		      \
+			break;						      \
+		case '\f':						      \
+			isc = 1; *dst++ = '\\'; *dst++ = 'f';		      \
+			break;						      \
+		case ' ':						      \
+			isc = 1; *dst++ = '\\'; *dst++ = 's';		      \
+			break;						      \
+		case '\0':						      \
+			isc = 1; *dst++ = '\\'; *dst++ = '0';		      \
+			if (isoctal(nextc)) {				      \
+				*dst++ = '0';				      \
+				*dst++ = '0';				      \
+			}						      \
+		}							      \
+	}								      \
+	if (isc) break;							      \
+	if (isextra || ((c & 0177) == ' ') || (flag & VIS_OCTAL)) {	      \
+		*dst++ = '\\';						      \
+		*dst++ = (u_char)(((u_int32_t)(u_char)c >> 6) & 03) + '0';    \
+		*dst++ = (u_char)(((u_int32_t)(u_char)c >> 3) & 07) + '0';    \
+		*dst++ =			     (c	      & 07) + '0';    \
+	} else {							      \
+		if ((flag & VIS_NOSLASH) == 0) *dst++ = '\\';		      \
+		if (c & 0200) {						      \
+			c &= 0177; *dst++ = 'M';			      \
+		}							      \
+		if (iscntrl(c)) {					      \
+			*dst++ = '^';					      \
+			if (c == 0177)					      \
+				*dst++ = '?';				      \
+			else						      \
+				*dst++ = c + '@';			      \
+		} else {						      \
+			*dst++ = '-'; *dst++ = c;			      \
+		}							      \
+	}								      \
+} while (/*CONSTCOND*/0)
+
+
+/*
+ * svis - visually encode characters, also encoding the characters
+ * 	  pointed to by `extra'
+ */
+char *
+svis(dst, c, flag, nextc, extra)
+	char *dst;
+	int c, flag, nextc;
+	const char *extra;
+{
+	_DIAGASSERT(dst != NULL);
+	_DIAGASSERT(extra != NULL);
+
+	SVIS(dst, c, flag, nextc, extra);
+	*dst = '\0';
+	return(dst);
+}
+
+
+/*
+ * strsvis, strsvisx - visually encode characters from src into dst
+ *
+ *	Extra is a pointer to a \0-terminated list of characters to
+ *	be encoded, too. These functions are useful e. g. to
+ *	encode strings in such a way so that they are not interpreted
+ *	by a shell.
+ *	
+ *	Dst must be 4 times the size of src to account for possible
+ *	expansion.  The length of dst, not including the trailing NULL,
+ *	is returned. 
+ *
+ *	Strsvisx encodes exactly len bytes from src into dst.
+ *	This is useful for encoding a block of data.
+ */
+int
+strsvis(dst, src, flag, extra)
+	char *dst;
+	const char *src;
+	int flag;
+	const char *extra;
+{
+	char c;
+	char *start;
+
+	_DIAGASSERT(dst != NULL);
+	_DIAGASSERT(src != NULL);
+	_DIAGASSERT(extra != NULL);
+
+	for (start = dst; (c = *src++) != '\0'; /* empty */)
+	    SVIS(dst, c, flag, *src, extra);
+	*dst = '\0';
+	return (dst - start);
+}
+
+
+int
+strsvisx(dst, src, len, flag, extra)
+	char *dst;
+	const char *src;
+	size_t len;
+	int flag;
+	const char *extra;
+{
+	char c;
+	char *start;
+
+	_DIAGASSERT(dst != NULL);
+	_DIAGASSERT(src != NULL);
+	_DIAGASSERT(extra != NULL);
+
+	for (start = dst; len > 0; len--) {
+		c = *src++;
+		SVIS(dst, c, flag, len ? *src : '\0', extra);
+	}
+	*dst = '\0';
+	return (dst - start);
+}
+
+
+/*
+ * vis - visually encode characters
+ */
+char *
+vis(dst, c, flag, nextc)
+	char *dst;
+	int c, flag, nextc;
+	
+{
+	char extra[MAXEXTRAS];
+
+	_DIAGASSERT(dst != NULL);
+
+	MAKEEXTRALIST(flag, extra);
+	SVIS(dst, c, flag, nextc, extra);
+	*dst = '\0';
+	return (dst);
+}
+
+
+/*
+ * strvis, strvisx - visually encode characters from src into dst
+ *	
+ *	Dst must be 4 times the size of src to account for possible
+ *	expansion.  The length of dst, not including the trailing NULL,
+ *	is returned. 
+ *
+ *	Strvisx encodes exactly len bytes from src into dst.
+ *	This is useful for encoding a block of data.
+ */
+int
+strvis(dst, src, flag)
+	char *dst;
+	const char *src;
+	int flag;
+{
+	char extra[MAXEXTRAS];
+
+	MAKEEXTRALIST(flag, extra);
+	return (strsvis(dst, src, flag, extra));
+}
+
+
+int
+strvisx(dst, src, len, flag)
+	char *dst;
+	const char *src;
+	size_t len;
+	int flag;
+{
+	char extra[MAXEXTRAS];
+
+	MAKEEXTRALIST(flag, extra);
+	return (strsvisx(dst, src, len, flag, extra));
+}
diff -ru -ruN mtree/vis.h mtree-linux/vis.h
--- mtree/vis.h	1970-01-01 01:00:00.000000000 +0100
+++ mtree-linux/vis.h	1999-11-25 17:55:50.000000000 +0100
@@ -0,0 +1,94 @@
+/*	$NetBSD: vis.h,v 1.11 1999/11/25 16:55:50 wennmach Exp $	*/
+
+/*-
+ * Copyright (c) 1990, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)vis.h	8.1 (Berkeley) 6/2/93
+ */
+
+#ifndef _VIS_H_
+#define	_VIS_H_
+
+/*
+ * to select alternate encoding format
+ */
+#define	VIS_OCTAL	0x01	/* use octal \ddd format */
+#define	VIS_CSTYLE	0x02	/* use \[nrft0..] where appropiate */
+
+/*
+ * to alter set of characters encoded (default is to encode all
+ * non-graphic except space, tab, and newline).
+ */
+#define	VIS_SP		0x04	/* also encode space */
+#define	VIS_TAB		0x08	/* also encode tab */
+#define	VIS_NL		0x10	/* also encode newline */
+#define	VIS_WHITE	(VIS_SP | VIS_TAB | VIS_NL)
+#define	VIS_SAFE	0x20	/* only encode "unsafe" characters */
+
+/*
+ * other
+ */
+#define	VIS_NOSLASH	0x40	/* inhibit printing '\' */
+
+/*
+ * unvis return codes
+ */
+#define	UNVIS_VALID	 1	/* character valid */
+#define	UNVIS_VALIDPUSH	 2	/* character valid, push back passed char */
+#define	UNVIS_NOCHAR	 3	/* valid sequence, no character produced */
+#define	UNVIS_SYNBAD	-1	/* unrecognized escape sequence */
+#define	UNVIS_ERROR	-2	/* decoder in unknown state (unrecoverable) */
+
+/*
+ * unvis flags
+ */
+#define	UNVIS_END	1	/* no more characters */
+
+#include <sys/cdefs.h>
+
+__BEGIN_DECLS
+char	*vis __P((char *, int, int, int));
+char	*svis __P((char *, int, int, int, const char *));
+int	strvis __P((char *, const char *, int));
+int	strsvis __P((char *, const char *, int, const char *));
+int	strvisx __P((char *, const char *, size_t, int));
+int	strsvisx __P((char *, const char *, size_t, int, const char *));
+int	strunvis __P((char *, const char *));
+#ifdef __LIBC12_SOURCE__
+int	unvis __P((char *, int, int *, int));
+int	__unvis13 __P((char *, int, int *, int));
+#else
+int	unvis __P((char *, int, int *, int))	__RENAME(__unvis13);
+#endif
+__END_DECLS
+
+#endif /* !_VIS_H_ */
diff -ru -ru mtree-linux_orig/Makefile mtree-linux/Makefile
--- mtree-linux_orig/Makefile	2006-10-09 17:25:07.000000000 +0200
+++ mtree-linux/Makefile	2006-10-09 17:26:14.000000000 +0200
@@ -2,7 +2,7 @@
           setmode.o spec.o stat_flags.o unvis.o verify.o vis.o
 
 CFLAGS  = -g -I. -Wall -Dlint -D__LIBC12_SOURCE__ -Dlinux -DHAVE_FCNTL_H \
-          -DHAVE_ERRNO_H -DHAVE_UNISTD_H
+          -DHAVE_ERRNO_H -DHAVE_UNISTD_H -D__USE_GNU
 
 all: $(OBJS) mtree
 
@@ -13,4 +13,4 @@
 	@-rm -f *.o mtree
 
 .c.o:
-	gcc $(CFLAGS) -c -o $@ $<
\ No newline at end of file
+	gcc $(CFLAGS) -c -o $@ $<
diff -ru -ru mtree-linux_orig/compare.c mtree-linux/compare.c
--- mtree-linux_orig/compare.c	2006-10-09 17:25:07.000000000 +0200
+++ mtree-linux/compare.c	2006-10-09 17:27:18.000000000 +0200
@@ -51,6 +51,15 @@
 #include <md5.h>
 #include <stdio.h>
 #include <time.h>
+#include <sys/time.h>
+
+#ifndef TIMESPEC_TO_TIMEVAL
+# define TIMESPEC_TO_TIMEVAL(tv, ts) {                                   \
+        (tv)->tv_sec = (ts)->tv_sec;                                    \
+        (tv)->tv_usec = (ts)->tv_nsec / 1000;                           \
+}
+#endif
+
 #include <unistd.h>
 #include "mtree.h"
 #include "extern.h"
