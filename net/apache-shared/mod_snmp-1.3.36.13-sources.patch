diff -ru -ruN apache_1.3.34_orig/README.SNMP apache_1.3.34/README.SNMP
--- apache_1.3.34_orig/README.SNMP	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/README.SNMP	2006-05-18 16:49:19.294763952 +0200
@@ -0,0 +1,102 @@
+The SNMP-agent module for the Apache HTTP server
+
+Version: 	1.3.14.13
+                (1.3.x.y where '1.3' stands for Apache HTTP version 1.3
+		and 'x' stands for teh lowest release version of Apache
+                with which it is compatible.
+                For example, 1.3.14.y works from Apache 1.3.14.
+		and 'y' stands for the module relaese version y.
+Date:    	June 20, 2002
+
+
+INSTALLATION INSTRUCTIONS:
+
+1) Unzip and untar the module within the Apache directory.
+
+    prompt$ cd apache_1.3.x
+    prompt$ tar zxvf mod_snmp_1.3.x.y.tar.gz
+    README.SNMP
+    WARNING-SNMP.TXT
+    config.snmp
+    src/modules/snmp_agt/
+    src/modules/snmp_agt/src_snmp/
+    src/modules/snmp_agt/src_snmp/agt_mib.c
+    src/modules/snmp_agt/src_snmp/agt_mib.h
+    src/modules/snmp_agt/src_snmp/agt_engine.c
+    src/modules/snmp_agt/src_snmp/agt_engine.h
+    src/modules/snmp_agt/src_snmp/asn1.c
+    src/modules/snmp_agt/src_snmp/asn1.h
+    src/modules/snmp_agt/src_snmp/snmp.h
+    src/modules/snmp_agt/src_snmp/snmp_community.c
+    src/modules/snmp_agt/src_snmp/snmp_community.h
+    src/modules/snmp_agt/Makefile.libdir
+    src/modules/snmp_agt/Makefile.tmpl
+    src/modules/snmp_agt/apache-mib.c
+    src/modules/snmp_agt/apache-mib.h
+    src/modules/snmp_agt/config-mib.c
+    src/modules/snmp_agt/config-mib.h
+    src/modules/snmp_agt/mod_snmp.c
+    src/modules/snmp_agt/mod_snmp.h
+    src/modules/snmp_agt/mod_snmp.patch
+    src/modules/snmp_agt/snmpv2-conf.h
+    src/modules/snmp_agt/snmpv2-mib.c
+    src/modules/snmp_agt/snmpv2-mib.h
+    src/modules/snmp_agt/snmpv2-smi.h
+    src/modules/snmp_agt/snmpv2-tc.c
+    src/modules/snmp_agt/snmpv2-tc.h
+    src/modules/snmp_agt/www-mib.c
+    src/modules/snmp_agt/www-mib.h
+    src/modules/snmp_agt/group_select
+    src/modules/snmp_agt/remake_status
+    src/support/snmp/
+    src/support/snmp/get_ext_status
+    src/support/snmp/set_ext_status
+    src/support/snmp/parameters.plib
+    src/support/snmp/get_max_spare_servers
+    src/support/snmp/set_max_spare_servers
+    src/support/snmp/get_min_spare_servers
+    src/support/snmp/set_min_spare_servers
+    src/support/snmp/get_limit_servers
+    src/support/snmp/set_limit_servers
+    htdocs/manual/mod/mod_snmp.html
+    htdocs/manual/snmp_agt/
+    htdocs/manual/snmp_agt/index.html
+    htdocs/manual/snmp_agt/www-mib.txt
+    htdocs/manual/snmp_agt/snmpv2-mib.txt
+    htdocs/manual/snmp_agt/apache-mib.txt
+    htdocs/manual/snmp_agt/config-mib.txt
+
+
+The files above should be added to the Apache HTTP Server source tree.
+
+2) Apply the mod_snmp patch that embeds the SNMP agent in the core of the 
+Apache HTTP Server.
+
+    prompt$ patch -p0 < src/modules/snmp_agt/mod_snmp.patch
+
+3) Reconfigure the source code. If you already had an existing
+configuration you have to add at least:
+    1)  the SNMP-define (CFLAGS="-DSNMP -DUSE_DB"),
+    2)  activate the snmp module (--activate-module=src/modules/snmp_agt/libsnmp_agt.a).
+ 
+    prompt$ CFLAGS="-DSNMP -DUSE_DB" \
+    ./configure \
+    --activate-module=src/modules/snmp_agt/libsnmp_agt.a
+
+You could do this with the premade 'config.snmp' script.
+    
+    prompt$ ./config.snmp 
+
+4) Make the new binaries and install them.
+
+    prompt$ make 
+    prompt$ make install
+
+5) Then you have to add an SNMP-section to configure the SNMP agent.
+For more information is referred to the 'htdocs/manual/mod/mod_snmp.html'.
+
+This should do it, to add the SNMP agent to the Apache HTTP Server.
+If it breaks keep the pieces. :-))
+Have fun with it,
+
+Harrie
diff -ru -ruN apache_1.3.34_orig/conf/snmp.conf-dist apache_1.3.34/conf/snmp.conf-dist
--- apache_1.3.34_orig/conf/snmp.conf-dist	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/conf/snmp.conf-dist	2006-05-18 16:49:19.291764408 +0200
@@ -0,0 +1,44 @@
+# SNMP Configuration; only to be used if the SNMP agent is included
+# see src/modules/snmp for more information.
+# Directive to start the SNMP-configuration section and to define
+# the UDP port to listen on; the default is the IANA registered port 161.
+#
+<SNMP 161>
+#
+# 'community' string(s) multiple entries are possible;
+# essentially set to 'public' or to some secret password like string.
+#
+SNMPcommunity public
+#
+# The directory where the SNMP-moduledoes its administration for the
+# buckets. These buckets are temporary files of the GNU-DBM used.
+# If not prepended with '/' it prefixes the 'ServerRoot'.
+#
+SNMPbuckets var/run
+#
+# System-group SNMPv2-MIB
+#
+# Description of the installation, i.e. the machine, physical location
+# and responsible admin; often _NOT_ the same as the webmasters details
+# or the details of the server administrator; i.e. really SYSTEM
+# specific. See for more information RFC 1907 (SNMPv2-MIB)
+#
+# The 'sysDescr' has a compiled in sensible default which reflects
+# the various version/protocol support flags and other details.
+#
+# sysDescr Apache #.## HTTP/1.1 - SNMP module version #.##
+#
+# The 'sysContact' should contain information on how to contact
+# the responsible for the system. Not neccesarily the webmaster 
+# or server administrator.
+#
+sysContact Admins@email.address
+#
+# The 'sysLocation' should contain information of the physical
+# location of the system.
+#
+sysLocation     your-place.your-country.your-earth.your-universe
+#
+# Directive to close the SNMP section.
+</SNMP>
+
diff -ru -ruN apache_1.3.34_orig/config.snmp apache_1.3.34/config.snmp
--- apache_1.3.34_orig/config.snmp	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/config.snmp	2006-05-18 16:49:19.291764408 +0200
@@ -0,0 +1,12 @@
+#!/bin/sh
+##
+##  config.status -- APACI auto-generated configuration restore script
+##
+##  Use this shell script to re-run the APACI configure script for
+##  restoring your configuration. Additional parameters can be supplied.
+##
+
+CFLAGS="-ggdb -DSNMP -DUSE_DB" \
+./configure \
+"--activate-module=src/modules/snmp_agt/libsnmp_agt.a" \
+"$@"
diff -ru -ruN apache_1.3.34_orig/htdocs/manual/mod/mod_snmp.html apache_1.3.34/htdocs/manual/mod/mod_snmp.html
--- apache_1.3.34_orig/htdocs/manual/mod/mod_snmp.html	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/htdocs/manual/mod/mod_snmp.html	2006-05-18 16:49:19.292764256 +0200
@@ -0,0 +1,227 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
+<HTML>
+<HEAD>
+   <TITLE>Apache module mod_snmp</TITLE>
+   <META NAME="GENERATOR" CONTENT="Mozilla/3.01Gold (X11; I; SunOS 5.6 sun4u) [Netscape]">
+</HEAD>
+<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#FF0000">
+
+<P><IMG SRC="../images/sub.gif" ALT="[APACHE DOCUMENTATION]" HEIGHT=62 WIDTH=500>
+</P>
+
+<H1>Module mod_snmp</H1>
+
+<P>This module is contained in the modules/snmp directory and is not compiled
+in by default. It provides an SNMP management extension for the Apache
+server via the SNMP framework. The SNMP agent implements the SNMPv2-MIB
+(RFC 1907), WWW-MIB (RFC 2594) and some extra Apache specific MIB-modules.</P>
+
+<UL>
+<LI><A HREF="#SNMP">SNMP</A></LI>
+
+<LI><A HREF="#SNMPbuckets">SNMPbuckets</A></LI>
+
+<LI><A HREF="#SNMPcommunity">SNMPcommunity</A></LI>
+
+<LI><A HREF="#sysDescr">sysDescr</A></LI>
+
+<LI><A HREF="#sysContact">sysContact</A></LI>
+
+<LI><A HREF="#sysLocation">sysLocation</A></LI>
+</UL>
+
+<P>
+<HR></P>
+
+<H2><A NAME="SNMP"></A>&lt;SNMP&gt; directive</H2>
+
+<P><B>Syntax:</B>&lt;SNMP <I>[ipaddress:]number</I>&gt;...&lt;/SNMP&gt;<BR>
+<B>Context:</B> snmp config<BR>
+<B>Status:</B> Extension<BR>
+<B>Module:</B> mod_snmp</P>
+
+<P>The <I>[ipaddress:]number</I> sets the binding ipaddress and network port
+on which the SNMP agent will listen.
+<I>The network port</I> is a number from 0 to 65635; some port numbers
+(especially below 1024) are reserved for particular protocols.
+See also /etc/services for a list of some defined ports; the standard
+port for the SNMP protocol is <B>161</B>.
+If the ipaddress is not given it will bind to all IP addresses of the system.</P>
+
+<P>Port 161 is one of Unix's special ports. All ports numbered below 1024
+are reserved for system use, i.e. regular (non-root) users cannot make
+use of them; instead they can only use higher port numbers. To use port
+161, you must start the server from the root account.</P>
+
+<P>If you cannot use port 161, choose any other unused port. Non-root users
+will have to choose a port number higher than 1023, such as 8000.</P>
+
+<P>Example: </P>
+
+<UL>
+<P>&lt;SNMP 161&gt;<BR>
+SNMPbuckets logs<BR>
+SNMPcommunity public<BR>
+sysContact Admins@email.address<BR>
+sysLocation your-place.your-country.your-earth.your-universe <BR>
+&lt;/SNMP&gt;</P>
+</UL>
+
+<P>See also <A HREF="#SNMPbuckets">SNMPbuckets</A>, <A HREF="#SNMPcommunity">SNMPcommunity</A>,
+<A HREF="#sysDescr">sysDescr</A>, <A HREF="#sysContact">sysContact </A>and
+<A HREF="#sysLocation">sysLocation</A>.</P>
+
+<P>
+<HR WIDTH="100%"></P>
+
+<H2><A NAME="SNMPbuckets"></A>SNMPbuckets directive</H2>
+
+<P><B>Syntax: </B>SNMP <I>director</I>y<BR>
+<B>Context:</B> snmp config<BR>
+<B>Status:</B> Extension<BR>
+<B>Module:</B> mod_snmp</P>
+
+<P>The SNMPbuckets directives specifies the directory where you want the
+buckets (used for the WWW_Docuement group) want to be stored. These bucket
+are storage for the GNU-DBM to provide document statistics in SNMP. For
+precise working and usage of the see the <A HREF="../snmp_agt/www-mib.txt">WWW-MIB</A>.</P>
+
+<P>Example:</P>
+
+<UL>
+<P>SNMPbuckets logs</P>
+</UL>
+
+<P>
+<HR></P>
+
+<H2><A NAME="SNMPcommunity"></A>SNMPcommunity directive</H2>
+
+<P><B>Syntax: </B>SNMPcommunity <I>string<BR>
+</I><B>Default: </B>community public<BR>
+<B>Context:</B> snmp config<BR>
+<B>Status:</B> Extension<BR>
+<B>Module:</B> mod_snmp</P>
+
+<P>The community is used to define communities with which the SNMP agent
+is accessible. In SNMP version 1 and version 2C the community is used for
+'security'. Only valid communities have access to the information of the
+SNMP agent.</P>
+
+<P>The most common known community is 'public'. A&nbsp;lot of people use
+this, but is not required. If there is no community given the default community
+will be used. At most 10 communities can be defined and the string length
+maybe at most 64 characters.</P>
+
+<P>SECURITY: if you do not want the information from the SNMP agent available
+for others. You must use well-known names or words from the dictionary.</P>
+
+<P>Example:</P>
+
+<UL>
+<P>SNMPcommunity public</P>
+</UL>
+
+<P>
+<HR></P>
+
+<H2><A NAME="sysDescr"></A>sysDescr directive</H2>
+
+<P><B>Syntax:</B> sysDescr <I>string<BR>
+</I><B>Default:</B>a compiled in default reflecting the various version/protocol
+flags and other details.<BR>
+<B>Context:</B> snmp config<BR>
+<B>Status:</B> Extension<BR>
+<B>Module:</B> mod_snmp</P>
+
+<P>The sysDescr directive is used to define the system description of the
+host on which the SNMP agent (thus server) is running taht is used for
+the the sysDescr object instance of <A HREF="../snmp_agt/snmpv2-mib.txt">SNMPv2-MIB</A>
+(also known as part of MIB-II). </P>
+
+<P>The definition says:</P>
+
+<UL>
+<P>&quot;A textual description of the entity. This value should include
+the full name and version identification of the system's hardware type,
+software operating-system, and networking software.&quot;</P>
+</UL>
+
+<P>Example:</P>
+
+<UL>
+<P>sysDescr Apache HTTP/1.1 with SNMP</P>
+</UL>
+
+<P>See also <A HREF="#sysContact">sysContact </A>and <A HREF="#sysLocation">sysLocation</A>.</P>
+
+<P>
+<HR></P>
+
+<H2><A NAME="sysContact"></A>sysContact directive</H2>
+
+<P>&gt;<B>Syntax:</B> sysContact <I>string<BR>
+</I><B>Context:</B> snmp config<BR>
+<B>Status:</B> Extension<BR>
+<B>Module:</B> mod_snmp</P>
+
+<P>The sysContact directive is used to define the contact address for the
+system that is used for the sysContact object instance of <A HREF="../snmp_agt/snmpv2.mib.txt">SNMPv2-MIB</A>
+(also known as part of MIB-II). </P>
+
+<P>The definition says:</P>
+
+<UL>
+<P>&quot;The textual identification of the contact person for this managed
+node, together with information on how to contact this person. If no contact
+information is known, the value is the zero-length string.&quot; </P>
+</UL>
+
+<P>Example:</P>
+
+<UL>
+<P>sysContact Admins@email.address <BR>
+</P>
+</UL>
+
+<P>See also <A HREF="#sysDescr">sysDescr</A>, and <A HREF="#sysLocation">sysLocation</A>.</P>
+
+<P>
+<HR></P>
+
+<H2><A NAME="sysLocation"></A>sysLocation directive</H2>
+
+<P><!--%plaintext &lt;?INDEX {\tt AuthDBUserFile} directive&gt; --><B>Syntax:</B>
+sysLocation <I>string<BR>
+</I><B>Context:</B> snmp config<BR>
+<B>Status:</B> Extension<BR>
+<B>Module:</B> mod_snmp</P>
+
+<P>The sysLocation directive is used to define the location of the host
+on which the SNMP agent (thus the server) is running and is used for the
+sysLocation object instance of the <A HREF="../snmp_agt/snmpv2-mib.txt">SNMPv2-MIB</A>
+(also known as part of MIB-II).</P>
+
+<P>The definition says:</P>
+
+<UL>
+<P>&quot;The physical location of this node (e.g., `telephone closet, 3rd
+floor'). If the location is unknown, the value is the zero-length string.&quot;
+</P>
+</UL>
+
+<P>Example:</P>
+
+<UL>
+<P>sysLocation Bottom Floor of bulding, room 44</P>
+</UL>
+
+<P>See also <A HREF="#sysDescr">sysDescr </A>and <A HREF="#sysContact">sysContact</A>.</P>
+
+<P>
+<HR><A HREF="./"><IMG SRC="../images/index.gif" ALT="Index" HEIGHT=32 WIDTH=100></A>
+<A HREF="../"><IMG SRC="../images/home.gif" ALT="Home" HEIGHT=32 WIDTH=100></A>
+</P>
+
+</BODY>
+</HTML>
diff -ru -ruN apache_1.3.34_orig/htdocs/manual/snmp_agt/apache-config-mib.txt apache_1.3.34/htdocs/manual/snmp_agt/apache-config-mib.txt
--- apache_1.3.34_orig/htdocs/manual/snmp_agt/apache-config-mib.txt	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/htdocs/manual/snmp_agt/apache-config-mib.txt	2006-05-18 16:49:19.294763952 +0200
@@ -0,0 +1,254 @@
+APACHE-CONFIG-MIB DEFINITIONS ::= BEGIN
+	-- the imports
+	IMPORTS ;
+
+	-- The assignments
+
+    apacheConfigMIB MODULE-IDENTITY
+        LAST-UPDATED "9904015000Z"
+        ORGANIZATION "Harrie hazewinkel"
+        CONTACT-INFO
+                "Harrie Hazewinkel
+
+                email: harrie.hazewinkel@jrc.it"
+        DESCRIPTION
+                "This APACHE-MIB module contains application specific
+                managed objects for configuringthe Apache HTTP-server."
+        ::= { jrcMIBs 5 }
+
+    --jointResearchCentre OBJECT IDENTIFIER ::= { enterprises 1847 }
+    --jrcMIBs OBJECT IDENTIFIER ::= { jointResearchCentre 1 }
+
+    acMIBObjects OBJECT IDENTIFIER ::= { apacheConfigMIB 1 }
+
+    acExtendedStatus OBJECT-TYPE
+        SYNTAX          INTEGER {
+				enable(1),
+				disable(2)
+			}
+        MAX-ACCESS      read-write
+        STATUS          current
+        DESCRIPTION
+                "The acExtendedStatus provides a mean to switch 
+		the extended status logging in the scoreboard.
+
+		This variable could be used to reduce the load
+		when it is turned off."
+        ::= { acMIBObjects 1 }
+
+    acKeepAliveSwitch OBJECT-TYPE
+        SYNTAX          INTEGER {
+				enable(1),
+				disable(2)
+			}
+	MAX-ACCESS	read-write
+	STATUS		current
+	DESCRIPTION
+		"The acKeepAliveSwitch enables/disables the
+		persistent connections."
+	::= { acMIBObjects 2 }
+
+    acKeepAliveRequests OBJECT-TYPE
+	SYNTAX		Integer32 (1..2147483647)
+	MAX-ACCESS	read-write
+	STATUS		current
+	DESCRIPTION
+		"The maximum number of requests the apache server will
+		serve via 1 persistent connection.
+		If 'acKeepAlive is disabled only 1 request
+		per connection will be served.
+
+		Server performance can be gained if this value is 
+		kept high."
+	::= { acMIBObjects 3 }
+
+    acKeepAliveTimeout OBJECT-TYPE
+	SYNTAX		Integer32 (1..2147483647)
+	MAX-ACCESS	read-write
+	STATUS		current
+	DESCRIPTION
+		"The number of seconds the Apache server will wait
+		for a subsequent request before closing the connection.
+
+		If 'acKeepAlive' is disabled the connection will
+		be terminated directly after serving the 
+		first request."
+	::= { acMIBObjects 4 }
+
+    acMaxServers OBJECT-TYPE
+	SYNTAX		Integer32 (1..2147483647)
+	MAX-ACCESS	read-write
+	STATUS		current
+	DESCRIPTION
+		"The acMaxServerss sets the limit on the number of simultaneous
+		requests that can be supported; not more than this number
+		of child server processes will be created.
+		The maximum number is limited by the implementation, 
+		the value 'HARD_SERVER_LIMIT'
+
+		Any connection attempts over the limit will
+		normally be queued, up to a number based on the
+		ListenBacklog directive."
+	::= { acMIBObjects 5}
+
+    acMinSpareServers OBJECT-TYPE
+	SYNTAX		Integer32 (1..2147483647)
+	MAX-ACCESS	read-write
+	STATUS		current
+	DESCRIPTION
+		"The acMinSpareServers sets the desired minimum number of
+		idle child server processes. An idle process is one which is
+		not handling a request. If there are fewer than
+		MinSpareServers idle, then the parent process creates new
+		children at a maximum rate of 1 per second.
+
+		Tuning of this parameter should only be necessary on
+		very busy sites. Setting this parameter to a large number
+		is almost always a bad idea.
+
+		This variable has no effect on Microsoft Windows. "
+	::= { acMIBObjects 6 }
+
+    acMaxSpareServers OBJECT-TYPE
+	SYNTAX		Integer32 (1..2147483647)
+	MAX-ACCESS	read-write
+	STATUS		current
+	DESCRIPTION
+		"The acMaxSpareServers sets the desired maximum number
+		of idle child server processes. An idle process is one
+		which is not handling a request. If there are more than
+		MaxSpareServers idle, then the parent process will kill
+		off the excess processes.
+
+		Tuning of this parameter should only be necessary on
+		very busy sites. Setting this parameter to a large
+		number is almost always a bad idea.
+
+		This variable has no effect when used with the Apache
+		Web server on a Microsoft Windows platform."
+	::= { acMIBObjects 7 }
+
+    acMaxRequestsPerChild OBJECT-TYPE
+	SYNTAX		Integer32 (1..2147483647)
+	MAX-ACCESS	read-write
+	STATUS		current
+	DESCRIPTION
+		"The MaxRequestsPerChild directive sets the limit on
+		the number of requests that an individual child server
+		process will handle.
+		After acMaxRequestsPerChild requests, the child process
+		will die. If MaxRequestsPerChild is 0, then the process
+		will never expire.
+
+		Setting acMaxRequestsPerChild to a non-zero limit has
+		two beneficial effects: 
+
+		it limits the amount of memory that process can
+		consume by (accidental) memory leakage; 
+		by giving processes a finite lifetime, it helps
+		reduce the number of processes when the server
+		load reduces. 
+
+		This directive has no effect on Win32. "
+	::= { acMIBObjects 8 }
+
+    acHostNameLookup OBJECT-TYPE
+	SYNTAX		INTEGER {
+				on(1),
+				off(2),
+				double(3)
+			}
+	MAX-ACCESS	read-write
+	STATUS		current
+	DESCRIPTION
+		"This variable enables DNS lookups so that host names can
+		be logged (and passed to CGIs/SSIs in REMOTE_HOST).
+		on: A forward lookup will be done to acquire the hostname.
+		off: No forward lookup will be done.
+		double: A double DNS lookup will be done. First the reverse 
+			lookup will be done and on tat result a forward
+			lookup will be done and at least one of the ip
+			addresses in the forward lookup must match the
+			original address. (In 'tcpwrapper' terminology
+			this is called PARANOID.)
+
+		Regardless of the setting, when mod_access is used for
+		controlling access by hostname, a double reverse lookup
+		will be performed. This is necessary for security.
+		Note that the result of this double-reverse isn't
+		generally available unless you set HostnameLookups double.
+		For example, if only HostnameLookups on and a request
+		is made to an object that is protected by hostname
+		restrictions, regardless of whether the double-reverse
+		fails or not, CGIs will still be passed the
+		single-reverse result in REMOTE_HOST."
+	::= { acMIBObjects 9 }
+
+    acLogLevel OBJECT-TYPE
+	SYNTAX		INTEGER {
+				emerg(1),
+				alert(2),
+				crit(3),
+				error(4),
+				warn(5),
+				notice(6),
+				info(7),
+				debug(8) }
+	MAX-ACCESS	read-write
+	STATUS		current
+	DESCRIPTION
+		"LogLevel adjusts the verbosity of the messages recorded
+		in the error logs.
+		The following levels are available, in order of
+		decreasing significance: 
+		emerg: Emergencies - system is unusable. 
+			'Child cannot open lock file. Exiting'
+		alert: Action must be taken immediately. 
+			'getpwuid: couldn't determine user name from uid'
+		crit: Critical Conditions. 
+			'socket: Failed to get a socket, exiting child'
+		error: Error conditions. 
+			'Premature end of script headers'
+		warn: Warning conditions. 
+			'child process 1234 did not exit, sending
+			another SIGHUP' 
+		notice: Normal but significant condition. 
+			'httpd: caught SIGBUS, attempting to dump core in ...' 
+		info: Informational. 
+			'Server seems busy, (you may need to increase
+			StartServers, or Min/MaxSpareServers)...' 
+		debug: Debug-level messages 
+			'Opening config file ...'
+
+		When a particular level is specified, messages from all
+		other levels of higher significance will be reported as
+		well. E.g., when LogLevel info is specified, then
+		messages with log levels of notice and warn will
+		also be posted. 
+		Using a level of at least crit is recommended."
+	::= { acMIBObjects 10 }
+
+
+    acMIBConformance OBJECT IDENTIFIER ::= { apacheConfigMIB 2 }
+    acMIBCompliances OBJECT IDENTIFIER ::= { acMIBConformance 1 }
+    acMIBGroups OBJECT IDENTIFIER ::= { acMIBConformance 2 }
+
+    acConfigGroup OBJECT-GROUP
+        OBJECTS {
+                acExtendedStatus,
+		acKeepAliveSwitch,
+		acKeepAliveRequests,
+		acKeepAliveTimeout,
+		acMaxServers,
+		acMinSpareServers,
+		acMaxSpareServers,
+		acMaxRequestsPerChild,
+		acHostNameLookup,
+		acLogLevel
+        }
+	STATUS      current
+	DESCRIPTION
+        	""
+	::= { acMIBGroups 1 }
+
+END
diff -ru -ruN apache_1.3.34_orig/htdocs/manual/snmp_agt/apache-scoreboard-mib.txt apache_1.3.34/htdocs/manual/snmp_agt/apache-scoreboard-mib.txt
--- apache_1.3.34_orig/htdocs/manual/snmp_agt/apache-scoreboard-mib.txt	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/htdocs/manual/snmp_agt/apache-scoreboard-mib.txt	2006-05-18 16:49:19.292764256 +0200
@@ -0,0 +1,162 @@
+APACHE-MIB DEFINITIONS ::= BEGIN
+	-- the imports
+	IMPORTS ;
+
+	-- The assignments
+
+    apacheMIB MODULE-IDENTITY
+        LAST-UPDATED "9810010000Z"
+        ORGANIZATION "Harrie hazewinkel"
+        CONTACT-INFO
+                "Harrie Hazewinkel
+
+                email: harrie.hazewinkel@jrc.it"
+        DESCRIPTION
+                "This APACHE-MIB module contains application specific
+                managed objects for the Apache HTTP-server."
+        REVISION "9810010000Z"
+        DESCRIPTION
+                "The intial version."
+        ::= { enterprises 4 }
+
+jointResearchCentre OBJECT IDENTIFIER ::= { enterprises 1847 }
+jrcMIBs OBJECT IDENTIFIER ::= { jointResearchCentre 1 }
+
+    ApacheServerStatusType ::= TEXTUAL-CONVENTION
+        STATUS  current
+        DESCRIPTION
+                "The ApacheServerStatusType defines the types
+                for a server."
+        SYNTAX  INTEGER {
+                        dead(1), starting(2), ready(3), read(4),
+                        write(5), keepalive(6), log(7), dns(8), graceful(9)
+                }
+
+
+apacheMIBObjects OBJECT IDENTIFIER ::= { apacheMIB 1 }
+
+    apScoreBoardTable OBJECT-TYPE
+        SYNTAX          SEQUENCE OF ApScoreBoardEntry
+        MAX-ACCESS      not-accessible
+        STATUS          current
+        DESCRIPTION
+                "This table maintains managed objects for
+                the scoreboard."
+        ::= { apacheMIBObjects 1 }
+
+    apScoreBoardEntry OBJECT-TYPE
+        SYNTAX          ApScoreBoardEntry
+        MAX-ACCESS      not-accessible
+        STATUS          current
+        DESCRIPTION
+                "The ApScoreBoardEntry."
+        INDEX { apScoreBoardIndex }
+        ::= { apScoreBoardTable 1 }
+
+    ApScoreBoardEntry ::=
+        SEQUENCE {
+                apScoreBoardIndex       Unsigned32,
+                apScoreBoardProcessId   Unsigned32,
+                apScoreBoardStatus      ApacheServerStatusType,
+                apScoreBoardStartTime   TimeStamp,
+                apScoreBoardAccessCount Unsigned32,
+                apScoreBoardAccessBytes Unsigned32,
+                apScoreBoardClient      DisplayString,
+                apScoreBoardRequest     DisplayString,
+                apScoreBoardVirtualHost Unsigned32
+        }
+
+    apScoreBoardIndex OBJECT-TYPE
+        SYNTAX          Unsigned32
+        MAX-ACCESS      not-accessible
+        STATUS          current
+        DESCRIPTION
+                "The scoreboard index of the servers maintained
+                in this running Apache HTTP-server."
+        ::= { apScoreBoardEntry 1 }
+
+    apScoreBoardProcessId OBJECT-TYPE
+        SYNTAX          Unsigned32
+        MAX-ACCESS      read-only
+        STATUS          current
+        DESCRIPTION
+                "The ProcessID of the server."
+        ::= { apScoreBoardEntry 2 }
+
+    apScoreBoardStatus OBJECT-TYPE
+        SYNTAX          ApacheServerStatusType
+        MAX-ACCESS      read-only
+        STATUS          current
+        DESCRIPTION
+                "The status of the server."
+        ::= { apScoreBoardEntry 3 }
+
+    apScoreBoardStartTime OBJECT-TYPE
+        SYNTAX          TimeStamp
+        MAX-ACCESS      read-only
+        STATUS          current
+        DESCRIPTION
+                "The timestamp of when this server became active."
+        ::= { apScoreBoardEntry 4 }
+
+    apScoreBoardAccessCount OBJECT-TYPE
+        SYNTAX          Unsigned32
+        MAX-ACCESS      read-only
+        STATUS          current
+        DESCRIPTION
+                "The number of accesses handled by this server."
+        ::= { apScoreBoardEntry 5 }
+
+    apScoreBoardAccessBytes OBJECT-TYPE
+        SYNTAX          Unsigned32
+        MAX-ACCESS      read-only
+        STATUS          current
+        DESCRIPTION
+                "The number of bytes responded by this server."
+        ::= { apScoreBoardEntry 6 }
+
+    apScoreBoardClient OBJECT-TYPE
+        SYNTAX          DisplayString
+        MAX-ACCESS      read-only
+        STATUS          current
+        DESCRIPTION
+                "The client that is connected to the server."
+        ::= { apScoreBoardEntry 7 }
+
+    apScoreBoardRequest OBJECT-TYPE
+        SYNTAX          DisplayString
+        MAX-ACCESS      read-only
+        STATUS          current
+        DESCRIPTION
+                "The request that the client did."
+        ::= { apScoreBoardEntry 8 }
+
+    apScoreBoardVirtualHost OBJECT-TYPE
+        SYNTAX          Unsigned32
+        MAX-ACCESS      read-only
+        STATUS          current
+        DESCRIPTION
+                "The virtual host being access at the server."
+        ::= { apScoreBoardEntry 9 }
+
+    apMIBConformance OBJECT IDENTIFIER ::= { apacheMIB 2 }
+    apMIBCompliances OBJECT IDENTIFIER ::= { apMIBConformance 1 }
+    apMIBGroups OBJECT IDENTIFIER ::= { apMIBConformance 2 }
+
+    apScoreBoardGroup OBJECT-GROUP
+        OBJECTS {
+                apScoreBoardProcessId,
+                apScoreBoardStatus,
+                apScoreBoardStartTime,
+                apScoreBoardAccessCount,
+                apScoreBoardAccessBytes,
+                apScoreBoardClient,
+                apScoreBoardRequest,
+                apScoreBoardVirtualHost
+        }
+       STATUS      current
+       DESCRIPTION
+                ""
+       ::= { apMIBGroups 1 }
+
+END
diff -ru -ruN apache_1.3.34_orig/htdocs/manual/snmp_agt/index.html apache_1.3.34/htdocs/manual/snmp_agt/index.html
--- apache_1.3.34_orig/htdocs/manual/snmp_agt/index.html	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/htdocs/manual/snmp_agt/index.html	2006-05-18 16:49:19.292764256 +0200
@@ -0,0 +1,172 @@
+<HTML>
+<HEAD>
+   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
+   <TITLE>SNMP Agent Module</TITLE>
+</HEAD>
+<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000FF" VLINK="#000080" ALINK="#FF0000">
+
+<CENTER><IMG SRC="../images/sub.gif" ALT="[APACHE DOCUMENTATION]" NOSAVE HEIGHT=62 WIDTH=500></CENTER>
+
+<CENTER>
+<H3>
+Apache HTTP Server Version 1.3</H3></CENTER>
+
+<CENTER>
+<H1>
+SNMP Agent</H1></CENTER>
+
+<H2>
+General Information</H2>
+The SNMP module is an extension with which the status of the Apache HTTP
+Server can be retrieved via the <I><FONT COLOR="#FF0000">S</FONT>imple
+<FONT COLOR="#FF0000">N</FONT>etwork <FONT COLOR="#FF0000">M</FONT>anagement
+<FONT COLOR="#FF0000">P</FONT>rotocol</I> (SNMP). SNMP is a well-known
+management framework for the Internetletting hardware (such as routers,
+briges and modems) and software (such as operating systems, network layers
+and applications) provide their status via a <I><FONT COLOR="#FF0000">M</FONT>anagement
+<FONT COLOR="#FF0000">I</FONT>nformation <FONT COLOR="#FF0000">B</FONT>ase</I>
+(MIB). The MIB represents a collection of managed objects of remote devices
+that are accessible via SNMP-agents. Managers can query an agent for the
+values of objects managed by the agent.
+
+<P>This module exists of an agent that implements the following MIBs:
+<UL>
+<LI>
+<A HREF="snmpv2-mib.txt">SNMPv2-MIB</A></LI>
+<BR> A mandatory MIB for every SNMP agent. The MIB was
+defined by the SNMPv2 WG of the IETF (RFC 1907).
+
+<LI>
+<A HREF="www-mib.txt">WWW-MIB</A></LI>
+<BR>A MIB defined for the management of WWW Services.
+The MIB is defined within the SYSAPPL MIB wg of the IETF (RFC 2594).
+
+<LI>
+<A HREF="scoreboard-mib.txt">APACHE-SCOREBOARD-MIB</A></LI>
+<BR>An specific MIB for the Apache HTTP Sever which provide SNMP access to the internal scorebaord.</UL>
+
+<LI>
+<A HREF="config-mib.txt">APACHE-CONFIG-MIB</A></LI>
+<BR>A specific MIB for the Apache HTTP Sever with which SNMP access is given to some configuration parameters
+ at run-time.</UL>
+
+<H2>
+Installation instructions</H2>
+
+<OL>
+<LI>
+Install the Apache HTTP Server (Version 1.3.x) as required.</LI>
+
+<LI>
+Untar the SNMP module from within the Apache directory (directly above
+the 'src'- and 'htdocs'-directory). This creates an 'snmp_agt'-directory
+within the 'modules'-directory, 'htdocs/snmp_agt'-directory and an 'snmp.conf-dist'-file.</LI>
+
+<LI>
+Configure and make the Apache HTTP Server. You now have multiple options for the database you can use.</LI>
+<UL>
+<LI>The following commands makes the HTTP-server and includes the SNMP Agent Module with the DB:</LI>
+
+<BR><B>prompt#</B> <TT>CFLAGS="-DSNMP -DUSE_DB" \<BR>
+<BR><TT>./configure</TT> \
+<BR>--activate-module=src/modules/snmp_agt/libsnmp_agt.a<BR>
+<B>prompt#</B> <TT>make</TT><BR>
+<B>prompt#</B> <TT>make install</TT><BR>
+
+<LI>The following commands makes the HTTP-server and includes the SNMP Agent Module with the GDBM:
+<BR>NOTE: This installation process requires the GNU-DBM to be installed as well. This example
+assumes the the GNU-DBM include file is in directory /usr/local/gdbm/include and that the GNU-DBM
+library is in /usr/local/gdbm/lib.
+
+<BR><B>prompt#</B> <TT>CFLAGS="-DSNMP -DUSE_GDBM" \<BR>
+LIBS="-L/usr/local/gdbm/lib -lgdbm" \<BR>
+INCLUDES="-I/usr/local/gdbm/include" \</TT>
+<BR><TT>./configure</TT> \
+<BR>--enable-module=snmp_agt<BR>
+<B>prompt#</B> <TT>make</TT><BR>
+<B>prompt#</B> <TT>make install</TT><BR>
+
+</UL>
+<LI>
+Add the contents of the 'snmp.conf-dist'-file to the 'httpd.conf'-file.
+(These files are standard in the '/usr/local/apache/conf')</LI>
+
+<BR>&nbsp;
+<BR><B>prompt#</B> <TT>cat httpd.conf-dist snmp.conf-dist > httpd.temp</TT>
+<BR><B>prompt#</B> mv httpd.temp <TT>httpd.conf<BR>
+</TT>
+<LI>
+<TT>Edit the <A HREF="../mod/mod_snmp.html">SNMP-section</A> of the httpd.conf-file.</TT></LI>
+
+<LI>
+Start, restart and stop Apache with new binary.</LI>
+</OL>
+This installation process requires the GNU-DBM to be installed as well.
+If you have installed the GNU-DBM with a different prefix as "/usr/local/"
+You have to modify the "./configure" of the above step 3 accordingly (LIBS
+and INCLUDE).
+<H2>
+Fine-tuning the SNMP Module</H2>
+Within in the MIB several groups are defined with which a selection to
+your wishes can be made. Therefore, you can edit an 'command-line' expander
+('group_select'-file) to select the groups of your choice. That file allows
+you to override the default of all groups without doing a re-configure.
+A selection line in the file looks like: "echo '-D&lt;group>'"
+
+<P>The following groups exist in the implemented MIBs:
+<UL>
+<LI>
+<A HREF="snmpv2-mib.txt">SNMPv2-MIB</A></LI>
+
+<UL>
+<LI>
+systemGroup (mandatory)</LI>
+
+<LI>
+snmpGroup (to be selected with "SNMP_GROUP")</LI>
+</UL>
+
+<LI>
+<A HREF="snmpv2-mib.txt">WWW-MIB</A></LI>
+
+<UL>
+<LI>
+wwwSystemGroup (mandatory)</LI>
+
+<LI>
+wwwSummaryGroup (mandatory)</LI>
+
+<LI>
+wwwRequestInGroup (to be selected by "WWW_REQUEST_IN_GROUP")</LI>
+
+<LI>
+wwwRequestOutGroup (to be selected by "WWW_REQUEST_OUT_GROUP")</LI>
+
+<LI>
+wwwResponseInGroup (to be selected by "WWW_RESPONSE_IN_GROUP")</LI>
+
+<LI>
+wwwResponseOutGroup (to be selected by "WWW_RESPONE_OUT_GROUP")</LI>
+
+<LI>
+wwwDocumentsGroup (to be selected by "WWW_DOCUMENTS_GROUP")</LI>
+
+
+<P>Selecting "WWW_FULL_COMPLIANCE" selects all groups of the WWW-MIB.</UL>
+
+<LI>
+<A HREF="apache-mib.txt">APACHE-MIB</A></LI>
+
+<UL>
+<LI>
+apScoreBoardGroup (to be slected with "APSCOREBOARD_GROUP")</LI>
+</UL>
+</UL>
+
+<HR>
+<CENTER>
+<H3>
+Apache HTTP Server Version 1.3</H3></CENTER>
+<IMG SRC="../images/index.gif" ALT="Index" NOSAVE HEIGHT=32 WIDTH=100>
+</BODY>
+</HTML>
diff -ru -ruN apache_1.3.34_orig/htdocs/manual/snmp_agt/rfc2594.txt apache_1.3.34/htdocs/manual/snmp_agt/rfc2594.txt
--- apache_1.3.34_orig/htdocs/manual/snmp_agt/rfc2594.txt	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/htdocs/manual/snmp_agt/rfc2594.txt	2006-05-18 16:49:19.293764104 +0200
@@ -0,0 +1,2433 @@
+
+Network Working Group                                      H. Hazewinkel
+Request for Comments: 2594             Joint Research Centre of the E.C.
+Category: Standards Track                                 C. Kalbfleisch
+                                                             Verio, Inc.
+                                                        J. Schoenwaelder
+                                                         TU Braunschweig
+                                                                May 1999
+
+            Definitions of Managed Objects for WWW Services
+
+Status of this Memo
+
+   This document specifies an Internet standards track protocol for the
+   Internet community, and requests discussion and suggestions for
+   improvements.  Please refer to the current edition of the "Internet
+   Official Protocol Standards" (STD 1) for the standardization state
+   and status of this protocol.  Distribution of this memo is unlimited.
+
+Copyright Notice
+
+   Copyright (C) The Internet Society (1999).  All Rights Reserved.
+
+Abstract
+
+   This memo defines a portion of the Management Information Base (MIB)
+   for use with network management protocols in the Internet Community.
+   In particular it describes a set of objects for managing World Wide
+   Web (WWW) services.
+
+Table of Contents
+
+   1 Introduction .................................................    1
+   2 The SNMP Management Framework ................................    2
+   3 Terminology ..................................................    3
+   4 Overview .....................................................    4
+   4.1 Purpose and Requirements ...................................    4
+   4.2 Relationship to other Standards Efforts ....................    5
+   4.3 WWW Services ...............................................    5
+   4.4 Document Transfer Protocol .................................    6
+   5 Structure of the MIB .........................................    7
+   5.1 Service Information Group ..................................    7
+   5.2 Protocol Statistics Group ..................................    7
+   5.3 Document Statistics Group ..................................    8
+   6 Definitions ..................................................   10
+   7 Document Transfer Protocol Mappings ..........................   36
+   7.1 The HyperText Transfer Protocol ............................   36
+   7.2 The File Transfer Protocol .................................   37
+   8 Security Considerations ......................................   38
+   9 Intellectual Property ........................................   39
+   10 Acknowledgments .............................................   39
+
+
+Hazewinkel, et al.          Standards Track                     [Page 1]
+
+RFC 2594                    WWW Service MIB                     May 1999
+
+
+   11 Editors' Addresses ..........................................   39
+   12 References ..................................................   40
+   13 Full Copyright Statement ....................................   43
+
+
+1.  Introduction
+
+   This memo defines a set of objects for managing World Wide Web (WWW)
+   services. This MIB extends the application management framework
+   defined by the System Application Management MIB (SYSAPPL-MIB) [23]
+   and the Application Management MIB (APPLICATION-MIB) [24]. The MIB is
+   also self-contained so that it can be implemented and used without
+   having to implement or install the APPLICATION-MIB or the SYSAPPL-
+   MIB.
+
+   The protocol statistics defined in the WWW Service MIB are based on
+   an abstract document transfer protocol (DTP). This memo also defines
+   a mapping of the abstract DTP to HTTP and FTP.  Additional mappings
+   may be defined in the future in order to use this MIB with other
+   document transfer protocols. It is anticipated that such future
+   mappings will be defined in separate RFCs.
+
+   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
+   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
+   document are to be interpreted as described in RFC 2119 [17].
+
+
+2.  The SNMP Management Framework
+
+   The SNMP Management Framework presently consists of five major
+   components:
+
+    o   An overall architecture, described in RFC 2571 [1].
+
+    o   Mechanisms for describing and naming objects and events for the
+        purpose of management. The first version of this Structure of
+        Management Information (SMI) is called SMIv1 and described in
+        STD 16, RFC 1155 [2], STD 16, RFC 1212 [3] and RFC 1215 [4]. The
+        second version, called SMIv2, is described in STD 58, RFC 2578
+        [5], RFC 2579 [6] and RFC 2580 [7].
+
+    o   Message protocols for transferring management information. The
+        first version of the SNMP message protocol is called SNMPv1 and
+        described in STD 15, RFC 1157 [8]. A second version of the SNMP
+        message protocol, which is not an Internet standards track
+        protocol, is called SNMPv2c and described in RFC 1901 [9] and
+        RFC 1906 [10]. The third version of the message protocol is
+        called SNMPv3 and described in RFC 1906 [10], RFC 2572 [11] and
+        RFC 2574 [12].
+
+
+Hazewinkel, et al.          Standards Track                     [Page 2]
+
+RFC 2594                    WWW Service MIB                     May 1999
+
+
+    o   Protocol operations for accessing management information. The
+        first set of protocol operations and associated PDU formats is
+        described in RFC 1157 [8]. A second set of protocol operations
+        and associated PDU formats is described in RFC 1905 [13].
+
+    o   A set of fundamental applications described in RFC 2573 [14] and
+        the view-based access control mechanism described in RFC 2575
+        [15].
+
+   Managed objects are accessed via a virtual information store, termed
+   the Management Information Base or MIB.  Objects in the MIB are
+   defined using the mechanisms defined in the SMI.
+
+   This memo specifies a MIB module that is compliant to the SMIv2. A
+   MIB conforming to the SMIv1 can be produced through the appropriate
+   translations. The resulting translated MIB must be semantically
+   equivalent, except where objects or events are omitted because no
+   translation is possible (use of Counter64). Some machine readable
+   information in SMIv2 will be converted into textual descriptions in
+   SMIv1 during the translation process. However, this loss of machine
+   readable information is not considered to change the semantics of the
+   MIB.
+
+
+3.  Terminology
+
+   This section defines the terminology used throughout this document.
+
+   o    The 'World Wide Web' (WWW) is a world wide information system
+        which is based on the concept of documents that are linked
+        together by embedding references (links) to other local or
+        remote documents.
+
+   o    A 'document' is a coherent piece of data which is accessible in
+        the World Wide Web. No assumptions are made about the content or
+        the type of a document.
+
+   o    A 'Uniform Resource Locator' (URL) is a formatted string
+        representation for a document available via the Internet. URLs
+        are used to express references between documents. For the syntax
+        and semantics of the URL string representation refer to RFC 2396
+        [18]
+
+   o    A 'Document Transfer Protocol' (DTP) is a protocol used within
+        the World Wide Web to invoke actions on documents. The DTP is an
+        abstraction from real protocols, such as HTTP [19,20] or FTP
+        [21].
+
+
+
+
+Hazewinkel, et al.          Standards Track                     [Page 3]
+
+RFC 2594                    WWW Service MIB                     May 1999
+
+
+   o    A 'request' is a DTP protocol operation which is targeted to a
+        'document' and invokes an action on the target document.  The
+        request type specifies the action that should be performed. A
+        request can have a document associated with it.
+
+   o    A 'response' is a DTP protocol operation which is returned as a
+        result of a previous (and associated) request. The response
+        status indicates if the requested action was successful or if
+        errors occurred. A response can have a document associated with
+        it.
+
+   o    A 'WWW service' is a set of actions that can be invoked on a
+        document. Typical actions are the transfer of documents or the
+        retrieval of administrative information about documents. WWW
+        services are provided by means of a DTP. A WWW service can be
+        identified by the DTP protocol used to invoke services and the
+        transport endpoint used by that protocol.
+
+   o    A 'client' is a program which establishes connections for the
+        purpose of sending requests and receiving responses.
+
+   o    A 'server' is a program that accepts connections in order to
+        service requests by sending back responses.
+
+   o    A 'proxy' is an intermediary program which acts as both a server
+        and a client for the purpose of making requests on behalf of
+        other clients.  Requests are serviced internally or by passing
+        them on, with possible translation, to other servers.
+
+   o    A 'caching proxy' is a proxy with the capability of locally
+        storing responses to associated requests. A caching proxy can
+        respond to similar requests with a previously stored response.
+
+
+4.  Overview
+
+   The World Wide Web (WWW) is a global network of information.
+   Information is stored in documents, which can have various formats,
+   including hyper-text and multi-media documents. Access to these
+   documents is provided by servers which are located all around the
+   world and are linked to each other via hyper-links embedded in
+   documents.
+
+   The usability of the World Wide Web depends largely on the
+   performance of the services realized by these servers. The services
+   are typically monitored through log files. This becomes a difficult
+   task when a single organization is responsible for a large number of
+   services. It is therefore desirable to treat WWW services as objects
+   that can be managed by using the Internet network management
+   framework [22].
+
+
+Hazewinkel, et al.          Standards Track                     [Page 4]
+
+RFC 2594                    WWW Service MIB                     May 1999
+
+
+4.1.  Purpose and Requirements
+
+   The goal of this MIB is to define a standardized set of objects which
+   lead to integrated and improved performance and fault management in a
+   heterogeneous environment of WWW services. This MIB focuses on the
+   service-oriented view. It does not deal with the process oriented
+   view, which is covered by the System Application MIB [23] and the
+   Application MIB [24].
+
+   This document defines a set of managed objects to monitor WWW
+   services for short-term operational purposes, such as problem
+   detection and troubleshooting. No attempts are made here to cover
+   accounting or hit metering issues.
+
+   The scope of the MIB is further limited by the requirement that an
+   implementation conforming to this MIB must be possible without
+   putting a huge CPU or memory burden on the WWW server implementation.
+
+   In addition, this MIB does not cover WWW service configuration.
+   Server software has become an open market where competing vendors
+   constantly invent new features in order to shape their products. It
+   is therefore not possible to reach consensus on a common way to
+   configure WWW services at this point in time.
+
+
+4.2.  Relationship to other Standards Efforts
+
+   The WWW Service MIB fits into the application management architecture
+   defined in the System Application MIB [23]. The System Application
+   MIB and the Application MIB [24] use a process-oriented view, where
+   an application is viewed as a collection of processes. The WWW
+   Service MIB described in this memo uses a service-oriented view,
+   which looks at the services provided by a set of processes.
+
+   The relationship between the process-oriented view and the service-
+   oriented view is a many-to-many relationship, because one process can
+   implement multiple services and multiple services can be implemented
+   by a single set of processes. The Application Management MIB [24]
+   contains generic mapping tables, which map back and forth between
+   both views.
+
+   The WWW Service MIB interfaces to the Application MIB [24] by using
+   the service instance identifier (applSrvIndex) for wwwServiceIndex if
+   an applicable instance of applSrvIndex is available. The WWW Service
+   MIB is self-contained and can be implemented as a stand-alone module
+   if the service-level tables in the Application MIB are not available.
+
+
+
+
+
+Hazewinkel, et al.          Standards Track                     [Page 5]
+
+RFC 2594                    WWW Service MIB                     May 1999
+
+
+4.3.  WWW Services
+
+   The MIB is organized around the concept of WWW services. WWW services
+   are a set of actions that can be invoked on a document. A WWW service
+   is provided or used by either a client, a server or a proxy. Clients
+   send out requests for information to server or proxy server. Servers
+   receive, process and respond to requests received from clients.
+   Servers usually have access to local documents, which can be
+   transferred to clients.
+
+   A proxy is a special server, who acts as both a server and a client
+   for the purpose of making requests on behalf of other clients. A
+   proxy is able to translate between the client and the origin server.
+   A proxy might also interact with other information retrieval system,
+   like for example databases.
+
+   The MIB defined in this memo distinguishes between outgoing and
+   incoming requests and responses. This makes it possible to obtain
+   statistics for clients, servers and proxies with a single set of
+   objects.
+
+   A special proxy server is the caching proxy, which maintains a cache
+   of previously received documents in order to reduce the bandwidth
+   used by World Wide Web clients. One interesting piece of management
+   information is the percentage of requests that were served from the
+   cache of the caching proxy (hits/miss-ratio). This ratio is not
+   contained explicitly in this MIB. Instead, the ratio can be derived
+   from the objects that count incoming and outgoing requests and
+   responses.
+
+
+4.4.  Document Transfer Protocol
+
+   The MIB is based on the concept of an abstract document transfer
+   protocol (DTP). The purpose of the abstract document transfer
+   protocol is to make the MIB definitions independent from concrete
+   protocols, like the Hypertext Transfer Protocol (HTTP) [19,20] or the
+   File Transfer Protocol (FTP) [21].
+
+   The abstract document transfer protocol makes the following
+   assumptions about a concrete transfer protocol:
+
+   o    The transfer protocol uses a request/response style of
+        interactions.
+
+   o    Every request contains a request type, which defines the
+        operations performed by the receiving server. The request type
+        is represented by an OCTET STRING. It might be necessary to
+        define a translation into an OCTET STRING value for protocols
+        that use numbers to identify request types.
+
+
+Hazewinkel, et al.          Standards Track                     [Page 6]
+
+RFC 2594                    WWW Service MIB                     May 1999
+
+
+   o    A response contains a status code, which indicates if the
+        request was processed successfully or which error occurred. The
+        status code is represented as an INTEGER value. It might be
+        necessary to define a mapping for protocols that do not use an
+        INTEGER status code.
+
+   o    A transfer protocol can send multiple responses for a single
+        request.  Multiple responses are counted separately in the
+        protocol statistics group.
+
+        A primary response has to be identified for the document
+        statistics. The primary response is the response that indicates
+        whether the request was successful.
+
+   Section 7 of this memo defines a mapping of the document transfer
+   protocol to the HTTP protocol and the FTP protocol. Mappings to other
+   protocols, like NNTP [25] or WebNFS [26,27] might be defined in the
+   future.
+
+
+5.  Structure of the MIB
+
+   This section presents the structure of the MIB. The objects are
+   arranged into the following groups:
+
+   o    service information
+
+   o    protocol statistics
+
+   o    document statistics
+
+
+5.1.  Service Information Group
+
+   The service information group consists of a single table describing
+   all the WWW services managed by the SNMP agent. The service table
+   contains administrative network management information for
+   (potentially) multiple WWW services running on a single host. It also
+   contains information for all services within virtual domains of a
+   host. The columnar objects in the table can be divided into two main
+   groups:
+
+   o    global administrative information of the service, such as
+        service contact person, and
+
+   o    network information, such as the transfer protocol.
+
+
+
+
+
+Hazewinkel, et al.          Standards Track                     [Page 7]
+
+RFC 2594                    WWW Service MIB                     May 1999
+
+
+5.2.  Protocol Statistics Group
+
+   The protocol statistics group provides network management information
+   about the traffic received or transmitted by a WWW service. This
+   group contains counters related to DTP protocol operations and
+   consists of five tables:
+
+   o    The wwwSummaryTable contains a set of network traffic related
+        counters. The table provides a summarization of the network
+        traffic and protocol operations related to a WWW service. It is
+        well recognized that certain variables are redundant with
+        respect to the request and response tables, but they are added
+        to provide an operator a quick overview and to reduce SNMP
+        network traffic.
+
+   o    The wwwRequestInTable contains detailed information about
+        incoming requests. Every particular request type is counted
+        separately.
+
+   o    The wwwRequestOutTable contains detailed information about
+        outgoing requests. Every particular request type is counted
+        separately.
+
+   o    The wwwResponseInTable contains detailed information about
+        incoming responses. Every particular response type is counted
+        separately.
+
+   o    The wwwResponseOutTable contains detailed information about
+        outgoing responses. Every particular response type is counted
+        separately.
+
+
+5.3.  Document Statistics Group
+
+   The document group contains information about the documents which
+   were accessed in the past. The group provides four types of
+   statistics.
+
+   1.   Details about the last N attempts to invoke actions on
+        documents.
+
+   2.   The Top N documents sorted by the number of actions invoked on
+        them computed over a time interval.
+
+   3.   The Top N documents sorted by the number of content bytes
+        transferred computed over a time interval.
+
+   4.   Summary statistics computed over a time interval.
+
+
+
+Hazewinkel, et al.          Standards Track                     [Page 8]
+
+RFC 2594                    WWW Service MIB                     May 1999
+
+
+   The Top N document statistics are collected in buckets in order to
+   reduce agent resources and to allow a manager to detect changes in
+   the service usage pattern. Buckets are filled over a configurable
+   time interval. The agent computes the Top N statistics and starts a
+   new bucket once the time interval for the bucket has passed. The time
+   interval is configurable for each WWW service.
+
+   The document statistics group associates a response type to the
+   request which invoked an action. In case a DTP sends multiple
+   responses, the primary response must be used to derive the response
+   type of the request/response interaction.
+
+   The group consist of the following tables:
+
+   o    The wwwDocCtrlTable provides the manager a means to limit the
+        document statistic tables in size and to control the expiration
+        and creation of buckets.
+
+   o    The wwwDocLastNTable provides the manager information about the
+        last N documents which where accessed. The table lists the
+        documents for which access was attempted along with the request
+        and response type of the DTP and a status message. The request
+        and response types provide a manager information of how attempts
+        to invoke actions were handled by the DTP. The status message
+        object provides human readable text to further describe the
+        response type.
+
+        The number of documents in the wwwDocLastNTable is controlled by
+        the wwwDocCtrlLastNSize object in the wwwDocCtrlTable. The
+        wwwDocCtrlLastNLock object of the wwwDocCtrlTable allows a
+        management application to lock the wwwDocLastNTable in order to
+        retrieve a consistent snapshot of the fast changing
+        wwwDocLastNTable.
+
+   o    The wwwDocBucketTable lists the buckets of statistical
+        information that have been collected. An entry in the
+        wwwDocBucketTable contains the creation timestamp of the bucket
+        as well as summary information (number of accesses, number of
+        documents accessed and number of bytes transferred).
+
+        The time interval is controlled by the
+        wwwDocCtrlBucketTimeInterval object of the wwwDocCtrlTable. The
+        maximum number of buckets maintained by the SNMP agent for a
+        particular WWW service is controlled by the wwwDocCtrlBuckets
+        object of the wwwDocCtrlTable.
+
+   o    The wwwDocAccessTopNTable provides the manager an overview of
+        the top N documents which were accessed while statistics were
+        collected for a particular bucket. The wwwDocAccessTopNTable is
+
+
+Hazewinkel, et al.          Standards Track                     [Page 9]
+
+RFC 2594                    WWW Service MIB                     May 1999
+
+
+        sorted by the number of read attempts per document. The maximum
+        number of entries in the wwwDocAccessTopNTable is controlled by
+        the wwwDocCtrlTopNSize object.
+
+   o    The wwwDocBytesTopNTable provides the manager an overview of the
+        top N documents which caused most of the network traffic while
+        statistics were collected for a particular bucket. The
+        wwwDocBytesTopNTable is sorted by the number of bytes
+        transferred. The maximum number of entries in the
+        wwwDocBytesTopNTable is controlled by the wwwDocCtrlTopNSize
+        object.
+
+
+   The Top N statistics and the parameters of the underlying bucket are
+   not visible in the MIB as long as the bucket is filling up. Instead,
+   the following steps must be taken when the time interval for a
+   buckets has passed:
+
+
+   1.   A new entry in the wwwDocBucketTable is created to summarize the
+        document statistics for that time interval.
+
+   2.   The corresponding entries in the wwwDocAccessTopNTable and the
+        wwwDocBytesTopNTable are computed and made available.
+
+   3.   If the resulting number of entries in the wwwDocBucketTable for
+        the WWW service now exceeds wwwDocCtrlBuckets, then the oldest
+        bucket for this WWW service and all corresponding entries in the
+        wwwDocBucketTable, wwwDocAccessTopNTable, and
+        wwwDocBytesTopNTable are deleted.
+
+
+   Note that a bucket usually contains much more data than displayed in
+   the Top N tables. The number of entries in the Top N table for a
+   bucket is controlled by wwwDocCtrlTopNSize, while the number of
+   entries in a bucket depends on the number of actions invoked on
+   documents within the time interval over which a bucket is filled up.
+   It is therefore suggested to discard the data associated with a
+   bucket once the entries for the wwwDocBucketTable,
+   wwwDocAccessTopNTable and wwwDocBytesTopNTable have been calculated.
+
+
+6.  Definitions
+
+   WWW-MIB DEFINITIONS ::= BEGIN
+
+   IMPORTS
+       MODULE-IDENTITY, OBJECT-TYPE, mib-2,
+       Counter32, Counter64, Integer32, Unsigned32, TimeTicks
+           FROM SNMPv2-SMI
+
+
+Hazewinkel, et al.          Standards Track                    [Page 10]
+
+RFC 2594                    WWW Service MIB                     May 1999
+
+
+       TEXTUAL-CONVENTION, DisplayString, DateAndTime, TimeInterval
+           FROM SNMPv2-TC
+
+       MODULE-COMPLIANCE, OBJECT-GROUP
+           FROM SNMPv2-CONF
+
+       Utf8String
+           FROM SYSAPPL-MIB;
+
+   wwwMIB MODULE-IDENTITY
+       LAST-UPDATED "9902251400Z"
+       ORGANIZATION "IETF Application MIB Working Group"
+       CONTACT-INFO
+           "        Harrie Hazewinkel
+
+            Postal: Joint Research Centre of the E.C.
+                    via Fermi - Ispra 21020 (VA)
+                    Italy
+
+               Tel: +39+(0)332 786322
+               Fax: +39+(0)332 785641
+            E-mail: harrie.hazewinkel@jrc.it
+
+                    Carl W. Kalbfleisch
+
+            Postal: Verio, Inc.
+                    1950 Stemmons Freeway
+                    Suite 2006
+                    Dallas, TX 75207
+                    US
+
+               Tel: +1 214 290-8653
+               Fax: +1 214 744-0742
+            E-mail: cwk@verio.net
+
+                    Juergen Schoenwaelder
+
+            Postal: TU Braunschweig
+                    Bueltenweg 74/75
+                    38106 Braunschweig
+                    Germany
+
+               Tel: +49 531 391-3683
+               Fax: +49 531 489-5936
+            E-mail: schoenw@ibr.cs.tu-bs.de"
+       DESCRIPTION
+           "This WWW service MIB module is applicable to services
+            realized by a family of 'Document Transfer Protocols'
+            (DTP). Examples of DTPs are HTTP and FTP."
+
+
+Hazewinkel, et al.          Standards Track                    [Page 11]
+
+RFC 2594                    WWW Service MIB                     May 1999
+
+
+          -- revision history
+
+          REVISION    "9902251400Z"
+          DESCRIPTION "Initial version, published as RFC2594."
+
+          ::= { mib-2 65 }
+
+   --
+   --  Object Identifier Assignments
+   --
+
+   wwwMIBObjects     OBJECT IDENTIFIER ::= { wwwMIB 1 }
+   wwwMIBConformance OBJECT IDENTIFIER ::= { wwwMIB 2 }
+
+   --
+   -- Textual Conventions
+   --
+
+   WwwRequestType ::= TEXTUAL-CONVENTION
+       STATUS      current
+       DESCRIPTION
+           "The WwwRequestType defines the textual identification of
+            request types used by a document transfer protocol. For
+            the proper values for a given DTP, refer to the protocol
+            mappings for that DTP."
+       SYNTAX      OCTET STRING (SIZE (1..40))
+
+   WwwResponseType ::= TEXTUAL-CONVENTION
+       STATUS      current
+       DESCRIPTION
+           "The WwwResponseType defines the different response values
+            used by document transfer protocols. For the proper values
+            for a given DTP, refer to the protocol mappings for that
+            DTP."
+       SYNTAX      Integer32 (0..2147483647)
+
+   WwwOperStatus ::= TEXTUAL-CONVENTION
+       STATUS      current
+       DESCRIPTION
+           "The operational status of a WWW service. 'down' indicates
+            that the service is not available. 'running' indicates
+            that the service is operational and available. 'halted'
+            indicates that the service is operational but not
+            available. 'congested' indicates that the service is
+            operational but no additional inbound associations can be
+            accommodated. 'restarting' indicates that the service is
+            currently unavailable but is in the process of restarting
+            and will be available soon."
+       SYNTAX      INTEGER {
+                       down(1),
+
+
+Hazewinkel, et al.          Standards Track                    [Page 12]
+
+RFC 2594                    WWW Service MIB                     May 1999
+
+
+                       running(2),
+                       halted(3),
+                       congested(4),
+                       restarting(5)
+                   }
+
+   WwwDocName ::= TEXTUAL-CONVENTION
+       DISPLAY-HINT "255a"
+       STATUS      current
+       DESCRIPTION
+           "The server relative name of a document. If the URL were
+            http://www.x.org/standards/search/search.cgi?string=test
+            then the value of this textual convention would resolve
+            to '/standards/search/search.cgi'. This textual convention
+            uses the character set for URIs as defined in RFC 2396
+            section 2."
+       SYNTAX      OCTET STRING (SIZE (0..255))
+
+
+   -- The WWW Service Information Group
+   --
+   -- The WWW service information group contains information about
+   -- the WWW services known by the SNMP agent.
+
+   wwwService OBJECT IDENTIFIER ::= { wwwMIBObjects 1 }
+
+   wwwServiceTable OBJECT-TYPE
+       SYNTAX      SEQUENCE OF WwwServiceEntry
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "The table of the WWW services known by the SNMP agent."
+       ::= { wwwService 1 }
+
+   wwwServiceEntry OBJECT-TYPE
+       SYNTAX      WwwServiceEntry
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "Details about a particular WWW service."
+       INDEX       { wwwServiceIndex }
+       ::= { wwwServiceTable 1 }
+
+   WwwServiceEntry ::= SEQUENCE {
+       wwwServiceIndex             Unsigned32,
+       wwwServiceDescription       Utf8String,
+       wwwServiceContact           Utf8String,
+       wwwServiceProtocol          OBJECT IDENTIFIER,
+       wwwServiceName              DisplayString,
+       wwwServiceType              INTEGER,
+
+
+Hazewinkel, et al.          Standards Track                    [Page 13]
+
+RFC 2594                    WWW Service MIB                     May 1999
+
+
+       wwwServiceStartTime         DateAndTime,
+       wwwServiceOperStatus        WwwOperStatus,
+       wwwServiceLastChange        DateAndTime
+   }
+
+   wwwServiceIndex OBJECT-TYPE
+       SYNTAX      Unsigned32 (1..4294967295)
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "An integer used to uniquely identify a WWW service. The
+            value must be the same as the corresponding value of the
+            applSrvIndex defined in the Application Management MIB
+            (APPLICATION-MIB) if the applSrvIndex object is available.
+            It might be necessary to manually configure sub-agents in
+            order to meet this requirement."
+       ::= { wwwServiceEntry 1 }
+
+   wwwServiceDescription OBJECT-TYPE
+       SYNTAX      Utf8String
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "Textual description of the WWW service. This shall include
+            at least the vendor and version number of the application
+            realizing the WWW service. In a minimal case, this might
+            be the Product Token (see RFC 2068) for the application."
+       ::= { wwwServiceEntry 2 }
+
+   wwwServiceContact OBJECT-TYPE
+       SYNTAX      Utf8String
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The textual identification of the contact person for this
+            service, together with information on how to contact this
+            person. For instance, this might be a string containing an
+            email address, e.g. '<webmaster@domain.name>'."
+       ::= { wwwServiceEntry 3 }
+
+   wwwServiceProtocol OBJECT-TYPE
+       SYNTAX      OBJECT IDENTIFIER
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "An identification of the primary protocol in use by this
+            service. For Internet applications, the IANA maintains
+            a registry of the OIDs which correspond to well-known
+            application protocols.  If the application protocol is not
+            listed in the registry, an OID value of the form
+
+
+Hazewinkel, et al.          Standards Track                    [Page 14]
+
+RFC 2594                    WWW Service MIB                     May 1999
+
+
+            {applTCPProtoID port} or {applUDPProtoID port} are used for
+            TCP-based and UDP-based protocols, respectively. In either
+            case 'port' corresponds to the primary port number being
+            used by the protocol."
+       REFERENCE
+           "The OID values applTCPProtoID and applUDPProtoID are
+            defined in the NETWORK-SERVICES-MIB (RFC 2248)."
+       ::= { wwwServiceEntry 4 }
+
+   wwwServiceName OBJECT-TYPE
+       SYNTAX      DisplayString
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The fully qualified domain name by which this service is
+            known. This object must contain the virtual host name if
+            the service is realized for a virtual host."
+       ::= { wwwServiceEntry 5 }
+
+   wwwServiceType OBJECT-TYPE
+       SYNTAX      INTEGER {
+                       wwwOther(1),
+                       wwwServer(2),
+                       wwwClient(3),
+                       wwwProxy(4),
+                       wwwCachingProxy(5)
+                   }
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The application type using or realizing this WWW service."
+       ::= { wwwServiceEntry 6 }
+
+   wwwServiceStartTime OBJECT-TYPE
+       SYNTAX      DateAndTime
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The date and time when this WWW service was last started.
+            The value SHALL be '0000000000000000'H if the last start
+            time of this WWW service is not known."
+       ::= { wwwServiceEntry 7 }
+
+   wwwServiceOperStatus OBJECT-TYPE
+       SYNTAX      WwwOperStatus
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "Indicates the operational status of the WWW service."
+       ::= { wwwServiceEntry 8 }
+
+
+Hazewinkel, et al.          Standards Track                    [Page 15]
+
+RFC 2594                    WWW Service MIB                     May 1999
+
+
+   wwwServiceLastChange OBJECT-TYPE
+       SYNTAX      DateAndTime
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The date and time when this WWW service entered its current
+            operational state. The value SHALL be '0000000000000000'H if
+            the time of the last state change is not known."
+       ::= { wwwServiceEntry 9 }
+
+
+   -- The WWW Protocol Statistics Group
+   --
+   -- The WWW protocol statistics group contains statistics about
+   -- the DTP requests and responses sent or received.
+
+   wwwProtocolStatistics OBJECT IDENTIFIER ::= { wwwMIBObjects 2 }
+
+   wwwSummaryTable OBJECT-TYPE
+       SYNTAX      SEQUENCE OF WwwSummaryEntry
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "The table providing overview statistics for the
+            WWW services on this system."
+       ::= { wwwProtocolStatistics 1 }
+
+   wwwSummaryEntry OBJECT-TYPE
+       SYNTAX      WwwSummaryEntry
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "Overview statistics for an individual service."
+       INDEX       { wwwServiceIndex }
+       ::= { wwwSummaryTable 1 }
+
+   WwwSummaryEntry ::= SEQUENCE {
+       wwwSummaryInRequests        Counter32,
+       wwwSummaryOutRequests       Counter32,
+       wwwSummaryInResponses       Counter32,
+       wwwSummaryOutResponses      Counter32,
+       wwwSummaryInBytes           Counter64,
+       wwwSummaryInLowBytes        Counter32,
+       wwwSummaryOutBytes          Counter64,
+       wwwSummaryOutLowBytes       Counter32
+   }
+
+   wwwSummaryInRequests OBJECT-TYPE
+       SYNTAX      Counter32
+       MAX-ACCESS  read-only
+
+
+Hazewinkel, et al.          Standards Track                    [Page 16]
+
+RFC 2594                    WWW Service MIB                     May 1999
+
+
+       STATUS      current
+       DESCRIPTION
+           "The number of requests successfully received."
+       ::= { wwwSummaryEntry 1 }
+
+   wwwSummaryOutRequests OBJECT-TYPE
+       SYNTAX      Counter32
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The number of requests generated."
+       ::= { wwwSummaryEntry 2 }
+
+   wwwSummaryInResponses OBJECT-TYPE
+       SYNTAX      Counter32
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The number of responses successfully received."
+       ::= { wwwSummaryEntry 3 }
+
+   wwwSummaryOutResponses OBJECT-TYPE
+       SYNTAX      Counter32
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The number of responses generated."
+       ::= { wwwSummaryEntry 4 }
+
+   wwwSummaryInBytes OBJECT-TYPE
+       SYNTAX      Counter64
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The number of content bytes received."
+       ::= { wwwSummaryEntry 5 }
+
+   wwwSummaryInLowBytes OBJECT-TYPE
+       SYNTAX      Counter32
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The lowest thirty-two bits of wwwSummaryInBytes."
+       ::= { wwwSummaryEntry 6 }
+
+   wwwSummaryOutBytes OBJECT-TYPE
+       SYNTAX      Counter64
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+
+
+Hazewinkel, et al.          Standards Track                    [Page 17]
+
+RFC 2594                    WWW Service MIB                     May 1999
+
+
+           "The number of content bytes transmitted."
+       ::= { wwwSummaryEntry 7 }
+
+   wwwSummaryOutLowBytes OBJECT-TYPE
+       SYNTAX      Counter32
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The lowest thirty-two bits of wwwSummaryOutBytes."
+       ::= { wwwSummaryEntry 8 }
+
+   -- The WWW request tables contain detailed information about
+   -- requests send or received by WWW services.
+
+   wwwRequestInTable OBJECT-TYPE
+       SYNTAX      SEQUENCE OF WwwRequestInEntry
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "The table providing detailed statistics for requests
+            received by WWW services on this system."
+       ::= { wwwProtocolStatistics 2 }
+
+   wwwRequestInEntry OBJECT-TYPE
+       SYNTAX      WwwRequestInEntry
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "Request statistics for an individual service."
+       INDEX       { wwwServiceIndex, wwwRequestInIndex }
+       ::= { wwwRequestInTable 1 }
+
+   WwwRequestInEntry ::= SEQUENCE {
+       wwwRequestInIndex           WwwRequestType,
+       wwwRequestInRequests        Counter32,
+       wwwRequestInBytes           Counter32,
+       wwwRequestInLastTime        DateAndTime
+   }
+
+   wwwRequestInIndex OBJECT-TYPE
+       SYNTAX      WwwRequestType
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "The particular request type the statistics apply to."
+       ::= { wwwRequestInEntry 1 }
+
+   wwwRequestInRequests OBJECT-TYPE
+       SYNTAX      Counter32
+       MAX-ACCESS  read-only
+
+
+Hazewinkel, et al.          Standards Track                    [Page 18]
+
+RFC 2594                    WWW Service MIB                     May 1999
+
+
+       STATUS      current
+       DESCRIPTION
+           "The number of requests of this type received by this
+            WWW service."
+       ::= { wwwRequestInEntry 2 }
+
+   wwwRequestInBytes OBJECT-TYPE
+       SYNTAX      Counter32
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The number of content bytes per request type received
+            by this WWW service."
+       ::= { wwwRequestInEntry 3 }
+
+   wwwRequestInLastTime OBJECT-TYPE
+       SYNTAX      DateAndTime
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The date and time when the last byte of the last complete
+            request of this type was received by this WWW service. The
+            value SHALL be '0000000000000000'H if no request of this
+            type has been received yet."
+       ::= { wwwRequestInEntry 4 }
+
+   wwwRequestOutTable OBJECT-TYPE
+       SYNTAX      SEQUENCE OF WwwRequestOutEntry
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "The table providing detailed statistics for requests
+            generated by the services on this system."
+       ::= { wwwProtocolStatistics 3 }
+
+   wwwRequestOutEntry OBJECT-TYPE
+       SYNTAX      WwwRequestOutEntry
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "Request statistics for an individual service."
+       INDEX       { wwwServiceIndex, wwwRequestOutIndex }
+       ::= { wwwRequestOutTable 1 }
+
+   WwwRequestOutEntry ::= SEQUENCE {
+       wwwRequestOutIndex          WwwRequestType,
+       wwwRequestOutRequests       Counter32,
+       wwwRequestOutBytes          Counter32,
+       wwwRequestOutLastTime       DateAndTime
+   }
+
+
+Hazewinkel, et al.          Standards Track                    [Page 19]
+
+RFC 2594                    WWW Service MIB                     May 1999
+
+
+   wwwRequestOutIndex OBJECT-TYPE
+       SYNTAX      WwwRequestType
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "The particular request type the statistics apply to."
+       ::= { wwwRequestOutEntry 1 }
+
+   wwwRequestOutRequests OBJECT-TYPE
+       SYNTAX      Counter32
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The number of requests of this type generated by this
+            WWW service."
+       ::= { wwwRequestOutEntry 2 }
+
+   wwwRequestOutBytes OBJECT-TYPE
+       SYNTAX      Counter32
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The number of content bytes per requests type generated
+            by this WWW service."
+       ::= { wwwRequestOutEntry 3 }
+
+   wwwRequestOutLastTime OBJECT-TYPE
+       SYNTAX      DateAndTime
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The date and time when the first byte of the last request
+            of this type was send by this WWW service. The value SHALL
+            be '0000000000000000'H if no request of this type has been
+            send yet."
+       ::= { wwwRequestOutEntry 4 }
+
+   -- The WWW response tables contain detailed information about
+   -- responses sent or received by WWW services.
+
+   wwwResponseInTable OBJECT-TYPE
+       SYNTAX      SEQUENCE OF WwwResponseInEntry
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "The table providing detailed statistics for responses
+            received by WWW services on this system."
+       ::= { wwwProtocolStatistics 4 }
+
+   wwwResponseInEntry OBJECT-TYPE
+
+
+Hazewinkel, et al.          Standards Track                    [Page 20]
+
+RFC 2594                    WWW Service MIB                     May 1999
+
+
+       SYNTAX      WwwResponseInEntry
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "Response statistics for an individual service."
+       INDEX       { wwwServiceIndex, wwwResponseInIndex }
+       ::= { wwwResponseInTable 1 }
+
+   WwwResponseInEntry ::= SEQUENCE {
+       wwwResponseInIndex          WwwResponseType,
+       wwwResponseInResponses      Counter32,
+       wwwResponseInBytes          Counter32,
+       wwwResponseInLastTime       DateAndTime
+   }
+
+   wwwResponseInIndex OBJECT-TYPE
+       SYNTAX      WwwResponseType
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "The particular response type the statistics apply to."
+       ::= { wwwResponseInEntry 1 }
+
+   wwwResponseInResponses OBJECT-TYPE
+       SYNTAX      Counter32
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The number of responses of this type received by this
+            WWW service."
+       ::= { wwwResponseInEntry 2 }
+
+   wwwResponseInBytes OBJECT-TYPE
+       SYNTAX      Counter32
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The number of content bytes per response type received
+            by this WWW service."
+       ::= { wwwResponseInEntry 3 }
+
+   wwwResponseInLastTime OBJECT-TYPE
+       SYNTAX      DateAndTime
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The date and time when the last byte of the last complete
+            response of this type was received by this WWW service. The
+            value SHALL be '0000000000000000'H if no response of this
+            type has been received yet."
+
+
+Hazewinkel, et al.          Standards Track                    [Page 21]
+
+RFC 2594                    WWW Service MIB                     May 1999
+
+
+       ::= { wwwResponseInEntry 4 }
+
+   wwwResponseOutTable OBJECT-TYPE
+       SYNTAX      SEQUENCE OF WwwResponseOutEntry
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "The table providing detailed statistics for responses
+            generated by services on this system."
+       ::= { wwwProtocolStatistics 5 }
+
+   wwwResponseOutEntry OBJECT-TYPE
+       SYNTAX      WwwResponseOutEntry
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "Response statistics for an individual service."
+       INDEX       { wwwServiceIndex, wwwResponseOutIndex }
+       ::= { wwwResponseOutTable 1 }
+
+   WwwResponseOutEntry ::= SEQUENCE {
+       wwwResponseOutIndex         WwwResponseType,
+       wwwResponseOutResponses     Counter32,
+       wwwResponseOutBytes         Counter32,
+       wwwResponseOutLastTime      DateAndTime
+   }
+
+   wwwResponseOutIndex OBJECT-TYPE
+       SYNTAX      WwwResponseType
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "The particular response type the statistics apply to."
+       ::= { wwwResponseOutEntry 1 }
+
+   wwwResponseOutResponses OBJECT-TYPE
+       SYNTAX      Counter32
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The number of responses of this type generated by this
+            WWW service."
+       ::= { wwwResponseOutEntry 2 }
+
+   wwwResponseOutBytes OBJECT-TYPE
+       SYNTAX      Counter32
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The number of content bytes per response type generated
+
+
+Hazewinkel, et al.          Standards Track                    [Page 22]
+
+RFC 2594                    WWW Service MIB                     May 1999
+
+
+            by this WWW service."
+       ::= { wwwResponseOutEntry 3 }
+
+   wwwResponseOutLastTime OBJECT-TYPE
+       SYNTAX      DateAndTime
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The date and time when the first byte of the last response of
+            this type was sent by this WWW service. The value SHALL be
+            '0000000000000000'H if response of this type has been send
+            yet."
+       ::= { wwwResponseOutEntry 4 }
+
+
+   -- The WWW Document Statistics Group
+   --
+   -- The WWW document statistics group contains statistics about
+   -- document read attempts.
+
+   wwwDocumentStatistics OBJECT IDENTIFIER ::= { wwwMIBObjects 3 }
+
+   wwwDocCtrlTable OBJECT-TYPE
+       SYNTAX      SEQUENCE OF WwwDocCtrlEntry
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "A table which controls how the MIB implementation
+            collects and maintains document statistics."
+       ::= { wwwDocumentStatistics 1 }
+
+   wwwDocCtrlEntry OBJECT-TYPE
+       SYNTAX      WwwDocCtrlEntry
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "An entry used to configure the wwwDocLastNTable,
+            the wwwDocBucketTable, the wwwDocAccessTopNTable,
+            and the wwwDocBytesTopNTable."
+       INDEX       { wwwServiceIndex }
+       ::= { wwwDocCtrlTable 1 }
+
+   WwwDocCtrlEntry ::= SEQUENCE {
+       wwwDocCtrlLastNSize           Unsigned32,
+       wwwDocCtrlLastNLock           TimeTicks,
+       wwwDocCtrlBuckets             Unsigned32,
+       wwwDocCtrlBucketTimeInterval  TimeInterval,
+       wwwDocCtrlTopNSize            Unsigned32
+   }
+
+
+Hazewinkel, et al.          Standards Track                    [Page 23]
+
+RFC 2594                    WWW Service MIB                     May 1999
+
+
+   wwwDocCtrlLastNSize OBJECT-TYPE
+       SYNTAX      Unsigned32
+       MAX-ACCESS  read-write
+       STATUS      current
+       DESCRIPTION
+           "The maximum number of entries in the wwwDocLastNTable."
+       DEFVAL { 25 }
+       ::= { wwwDocCtrlEntry 1 }
+
+   wwwDocCtrlLastNLock OBJECT-TYPE
+       SYNTAX      TimeTicks
+       MAX-ACCESS  read-write
+       STATUS      current
+       DESCRIPTION
+           "This object allows a manager to lock the wwwDocLastNTable
+            in order to retrieve the wwwDocLastNTable in a consistent
+            state. The agent is expected to take a snapshot of the
+            wwwDocLastNTable when it is locked and to continue updating
+            the real wwwDocLastNTable table so that recent information is
+            available as soon as the wwwDocLastNTable is unlocked again.
+
+            Setting this object to a value greater than 0 will lock
+            the table. The timer ticks backwards until it reaches 0.
+            The table unlocks automatically once the timer reaches 0
+            and the timer stops ticking.
+
+            A manager can increase the timer to request more time to
+            read the table. However, any attempt to decrease the timer
+            will fail with an inconsistentValue error. This rule ensures
+            that multiple managers can simultaneously lock and retrieve
+            the wwwDocLastNTable. Note that managers must cooperate in
+            using wwwDocCtrlLastNLock. In particular, a manager MUST not
+            keep the wwwDocLastNTable locked when it is not necessary to
+            finish a retrieval operation."
+       ::= { wwwDocCtrlEntry 2 }
+
+   wwwDocCtrlBuckets OBJECT-TYPE
+       SYNTAX      Unsigned32
+       MAX-ACCESS  read-write
+       STATUS      current
+       DESCRIPTION
+           "The maximum number of buckets maintained by the agent
+            before the oldest bucket is deleted. The buckets are
+            used to populate the wwwDocAccessTopNTable and the
+            wwwDocBytesTopNTable. The time interval captured in
+            each bucket can be configured by setting the
+            wwwDocCtrlBucketTimeInterval object."
+       DEFVAL { 4 }        -- 4 buckets times 15 minutes = 1 hour
+       ::= { wwwDocCtrlEntry 3 }
+
+
+Hazewinkel, et al.          Standards Track                    [Page 24]
+
+RFC 2594                    WWW Service MIB                     May 1999
+
+
+   wwwDocCtrlBucketTimeInterval OBJECT-TYPE
+       SYNTAX      TimeInterval
+       MAX-ACCESS  read-write
+       STATUS      current
+       DESCRIPTION
+           "The time interval after which a new bucket is created.
+            Changing this object has no effect on existing buckets."
+       DEFVAL { 90000 }    -- 15 minutes (resolution .01 s)
+       ::= { wwwDocCtrlEntry 4 }
+
+   wwwDocCtrlTopNSize OBJECT-TYPE
+       SYNTAX      Unsigned32
+       MAX-ACCESS  read-write
+       STATUS      current
+       DESCRIPTION
+           "The maximum number of entries shown in the
+            wwwDocAccessTopNTable and the wwwDocBytesTopNTable.
+            Changing this object has no effect on existing buckets."
+       DEFVAL { 25 }
+       ::= { wwwDocCtrlEntry 5 }
+
+
+   wwwDocLastNTable OBJECT-TYPE
+       SYNTAX      SEQUENCE OF WwwDocLastNEntry
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "The table which logs the last N access attempts."
+       ::= { wwwDocumentStatistics 2 }
+
+   wwwDocLastNEntry OBJECT-TYPE
+       SYNTAX      WwwDocLastNEntry
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "An entry which describes a recent access attempt."
+       INDEX       { wwwServiceIndex, wwwDocLastNIndex }
+       ::= { wwwDocLastNTable 1 }
+
+   WwwDocLastNEntry ::= SEQUENCE {
+       wwwDocLastNIndex            Unsigned32,
+       wwwDocLastNName             WwwDocName,
+       wwwDocLastNTimeStamp        DateAndTime,
+       wwwDocLastNRequestType      WwwRequestType,
+       wwwDocLastNResponseType     WwwResponseType,
+       wwwDocLastNStatusMsg        Utf8String,
+       wwwDocLastNBytes            Unsigned32
+   }
+
+   wwwDocLastNIndex OBJECT-TYPE
+
+
+Hazewinkel, et al.          Standards Track                    [Page 25]
+
+RFC 2594                    WWW Service MIB                     May 1999
+
+
+       SYNTAX      Unsigned32 (1..4294967295)
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "An arbitrary monotonically increasing integer number used
+            for indexing the wwwDocLastNTable. The first document
+            accessed appears in the table with this index value equal
+            to one. Each subsequent document is indexed with the next
+            sequential index value. The Nth document accessed will be
+            indexed by N. This table presents a sliding window of the
+            last wwwDocCtrlLastNSize documents accessed. Thus, entries
+            in this table will be indexed by N-wwwDocCtrlLastNSize
+            thru N if N > wwwDocCtrlLastNSize and 1 thru N if
+            N <= wwwDocCtrlLastNSize.
+
+            The wwwDocCtrlLastNLock attribute can be used to lock
+            this table to allow the manager to read its contents."
+       ::= { wwwDocLastNEntry 1 }
+
+   wwwDocLastNName OBJECT-TYPE
+       SYNTAX      WwwDocName
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The name of the document for which access was attempted."
+       ::= { wwwDocLastNEntry 2 }
+
+   wwwDocLastNTimeStamp OBJECT-TYPE
+       SYNTAX      DateAndTime
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The date and time of the last attempt to access this
+            document."
+       ::= { wwwDocLastNEntry 3 }
+
+   wwwDocLastNRequestType OBJECT-TYPE
+       SYNTAX      WwwRequestType
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The protocol request type which was received by the
+            server when this document access was attempted."
+       ::= { wwwDocLastNEntry 4 }
+
+   wwwDocLastNResponseType OBJECT-TYPE
+       SYNTAX      WwwResponseType
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+
+
+Hazewinkel, et al.          Standards Track                    [Page 26]
+
+RFC 2594                    WWW Service MIB                     May 1999
+
+
+           "The protocol response type which was sent to the client
+            as a result of this attempt to access a document. This
+            object contains the type of the primary response if
+            there were multiple responses to a single request."
+       ::= { wwwDocLastNEntry 5 }
+
+   wwwDocLastNStatusMsg OBJECT-TYPE
+       SYNTAX      Utf8String
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "This object contains a human readable description of the
+            reason why the wwwDocLastNResponseType was returned to the
+            client. This object defines the implementation-specific
+            reason if the value of wwwDocLastNResponseType indicates
+            an error. For example, this object can indicate that the
+            requested document could not be transferred due to a
+            timeout condition or the document could not be transferred
+            because a 'soft link' pointing to the document could not be
+            resolved."
+       ::= { wwwDocLastNEntry 6 }
+
+   wwwDocLastNBytes OBJECT-TYPE
+       SYNTAX      Unsigned32
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The number of content bytes that were returned as a
+            result of this attempt to access a document."
+       ::= { wwwDocLastNEntry 7 }
+
+
+   wwwDocBucketTable OBJECT-TYPE
+       SYNTAX      SEQUENCE OF WwwDocBucketEntry
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "This table provides administrative summary information for
+            the buckets maintained per WWW service."
+       ::= { wwwDocumentStatistics 3 }
+
+   wwwDocBucketEntry OBJECT-TYPE
+       SYNTAX      WwwDocBucketEntry
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "An entry which describes the parameters associated with a
+            particular bucket."
+       INDEX       { wwwServiceIndex, wwwDocBucketIndex }
+       ::= { wwwDocBucketTable 1 }
+
+
+Hazewinkel, et al.          Standards Track                    [Page 27]
+
+RFC 2594                    WWW Service MIB                     May 1999
+
+
+   WwwDocBucketEntry ::= SEQUENCE {
+       wwwDocBucketIndex           Unsigned32,
+       wwwDocBucketTimeStamp       DateAndTime,
+       wwwDocBucketAccesses        Unsigned32,
+       wwwDocBucketDocuments       Unsigned32,
+       wwwDocBucketBytes           Unsigned32
+   }
+
+   wwwDocBucketIndex OBJECT-TYPE
+       SYNTAX      Unsigned32 (1..4294967295)
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "An arbitrary monotonically increasing integer number
+            used for indexing the wwwDocBucketTable. The index number
+            wraps to 1 whenever the maximum value is reached."
+       ::= { wwwDocBucketEntry 1 }
+
+   wwwDocBucketTimeStamp OBJECT-TYPE
+       SYNTAX      DateAndTime
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The date and time when the bucket was made available."
+       ::= { wwwDocBucketEntry 2 }
+
+   wwwDocBucketAccesses OBJECT-TYPE
+       SYNTAX      Unsigned32
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The total number of access attempts for any document
+            provided by this WWW service during the time interval
+            over which this bucket was created."
+       ::= { wwwDocBucketEntry 3 }
+
+   wwwDocBucketDocuments OBJECT-TYPE
+       SYNTAX      Unsigned32
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The total number of different documents for which access
+            was attempted this this WWW service during the time interval
+            over which this bucket was created."
+       ::= { wwwDocBucketEntry 4 }
+
+   wwwDocBucketBytes OBJECT-TYPE
+       SYNTAX      Unsigned32
+       MAX-ACCESS  read-only
+       STATUS      current
+
+
+Hazewinkel, et al.          Standards Track                    [Page 28]
+
+RFC 2594                    WWW Service MIB                     May 1999
+
+
+       DESCRIPTION
+           "The total number of content bytes which were transferred
+            from this WWW service during the time interval over which
+            this bucket was created."
+       ::= { wwwDocBucketEntry 5 }
+
+
+   wwwDocAccessTopNTable OBJECT-TYPE
+       SYNTAX      SEQUENCE OF WwwDocAccessTopNEntry
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "The table of the most frequently accessed documents in a
+            given bucket. This table is sorted by the column
+            wwwDocAccessTopNAccesses. Entries having the same number
+            of accesses are secondarily sorted by wwwDocAccessTopNBytes.
+            Entries with the same number of accesses and the same
+            number of bytes will have an arbitrary order."
+       ::= { wwwDocumentStatistics 4 }
+
+   wwwDocAccessTopNEntry OBJECT-TYPE
+       SYNTAX      WwwDocAccessTopNEntry
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "An entry in the top N table sorted by document accesses."
+       INDEX       { wwwServiceIndex, wwwDocBucketIndex,
+                     wwwDocAccessTopNIndex }
+       ::= { wwwDocAccessTopNTable 1 }
+
+   WwwDocAccessTopNEntry ::= SEQUENCE {
+       wwwDocAccessTopNIndex             Unsigned32,
+       wwwDocAccessTopNName              WwwDocName,
+       wwwDocAccessTopNAccesses          Unsigned32,
+       wwwDocAccessTopNBytes             Unsigned32,
+       wwwDocAccessTopNLastResponseType  WwwResponseType
+   }
+
+   wwwDocAccessTopNIndex OBJECT-TYPE
+       SYNTAX      Unsigned32 (1..4294967295)
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "An arbitrary monotonically increasing integer number
+            used for indexing the wwwDocAccessTopNTable. The index is
+            inversely correlated to the sorting order of the table. The
+            document with the highest access count will get the index
+            value 1."
+       ::= { wwwDocAccessTopNEntry 1 }
+
+
+Hazewinkel, et al.          Standards Track                    [Page 29]
+
+RFC 2594                    WWW Service MIB                     May 1999
+
+
+   wwwDocAccessTopNName OBJECT-TYPE
+       SYNTAX      WwwDocName
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The name of the document for which access was attempted."
+       ::= { wwwDocAccessTopNEntry 2 }
+
+   wwwDocAccessTopNAccesses OBJECT-TYPE
+       SYNTAX      Unsigned32
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The total number of access attempts for this document."
+       ::= { wwwDocAccessTopNEntry 3 }
+
+   wwwDocAccessTopNBytes OBJECT-TYPE
+       SYNTAX      Unsigned32
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The total number of content bytes that were transmitted
+            as a result of attempts to access this document."
+       ::= { wwwDocAccessTopNEntry 4 }
+
+   wwwDocAccessTopNLastResponseType OBJECT-TYPE
+       SYNTAX      WwwResponseType
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The protocol response type which was sent to the client
+            as a result of the last attempt to access this document.
+            This object contains the type of the primary response if
+            there were multiple responses to a single request."
+       ::= { wwwDocAccessTopNEntry 5 }
+
+
+   wwwDocBytesTopNTable OBJECT-TYPE
+       SYNTAX      SEQUENCE OF WwwDocBytesTopNEntry
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "The table of the documents which caused most network
+            traffic in a given bucket. This table is sorted by the
+            column wwwDocBytesTopNBytes. Entries having the same number
+            bytes are secondarily sorted by wwwDocBytesTopNAccesses.
+            Entries with the same number of accesses and the same
+            number of bytes will have an arbitrary order."
+       ::= { wwwDocumentStatistics 5 }
+
+
+Hazewinkel, et al.          Standards Track                    [Page 30]
+
+RFC 2594                    WWW Service MIB                     May 1999
+
+
+   wwwDocBytesTopNEntry OBJECT-TYPE
+       SYNTAX      WwwDocBytesTopNEntry
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "An entry in the top N table sorted by network traffic."
+       INDEX       { wwwServiceIndex, wwwDocBucketIndex,
+                     wwwDocBytesTopNIndex }
+       ::= { wwwDocBytesTopNTable 1 }
+
+   WwwDocBytesTopNEntry ::= SEQUENCE {
+       wwwDocBytesTopNIndex             Unsigned32,
+       wwwDocBytesTopNName              WwwDocName,
+       wwwDocBytesTopNAccesses          Unsigned32,
+       wwwDocBytesTopNBytes             Unsigned32,
+       wwwDocBytesTopNLastResponseType  WwwResponseType
+   }
+
+   wwwDocBytesTopNIndex OBJECT-TYPE
+       SYNTAX      Unsigned32 (1..4294967295)
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "An arbitrary monotonically increasing integer number
+            used for indexing the wwwDocBytesTopNTable. The index is
+            inversely correlated to the sorting order of the table. The
+            document with the highest byte count will get the index
+            value 1."
+       ::= { wwwDocBytesTopNEntry 1 }
+
+   wwwDocBytesTopNName OBJECT-TYPE
+       SYNTAX      WwwDocName
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The name of the document for which access was attempted."
+       ::= { wwwDocBytesTopNEntry 2 }
+
+   wwwDocBytesTopNAccesses OBJECT-TYPE
+       SYNTAX      Unsigned32
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The total number of access attempts for this document."
+       ::= { wwwDocBytesTopNEntry 3 }
+
+   wwwDocBytesTopNBytes OBJECT-TYPE
+       SYNTAX      Unsigned32
+       MAX-ACCESS  read-only
+       STATUS      current
+
+
+Hazewinkel, et al.          Standards Track                    [Page 31]
+
+RFC 2594                    WWW Service MIB                     May 1999
+
+
+       DESCRIPTION
+           "The total number of content bytes that were transmitted
+            as a result of attempts to access this document."
+       ::= { wwwDocBytesTopNEntry 4 }
+
+   wwwDocBytesTopNLastResponseType OBJECT-TYPE
+       SYNTAX      WwwResponseType
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The protocol response type which was sent to the client
+            as a result of the last attempt to access this document.
+            This object contains the type of the primary response if
+            there were multiple responses to a single request."
+       ::= { wwwDocBytesTopNEntry 5 }
+
+   --
+   -- Conformance Definitions
+   --
+
+   wwwMIBCompliances OBJECT IDENTIFIER ::= { wwwMIBConformance 1 }
+   wwwMIBGroups      OBJECT IDENTIFIER ::= { wwwMIBConformance 2 }
+
+   wwwMinimalCompliance MODULE-COMPLIANCE
+       STATUS      current
+       DESCRIPTION
+           "The compliance statement for SNMP agents which implement
+            the minimal subset of the WWW-MIB. Implementors might
+            choose this subset for high-performance server where
+            full compliance might be to expensive."
+       MODULE  -- this module
+       MANDATORY-GROUPS {
+           wwwServiceGroup,
+           wwwSummaryGroup
+       }
+       OBJECT wwwSummaryOutRequests
+       DESCRIPTION
+           "Instances of wwwSummaryOutRequests do not exist on pure
+            WWW server implementations."
+       OBJECT wwwSummaryInResponses
+       DESCRIPTION
+           "Instances of wwwSummaryOutRequests do not exist on pure
+            WWW server implementations."
+       OBJECT wwwSummaryInRequests
+       DESCRIPTION
+           "Instances of wwwSummaryInRequests do not exist on pure
+            WWW client implementations."
+       OBJECT wwwSummaryOutResponses
+       DESCRIPTION
+           "Instances of wwwSummaryOutResponses do not exist on pure
+
+
+Hazewinkel, et al.          Standards Track                    [Page 32]
+
+RFC 2594                    WWW Service MIB                     May 1999
+
+
+            WWW client implementations."
+       ::= { wwwMIBCompliances 1 }
+
+   wwwFullCompliance MODULE-COMPLIANCE
+       STATUS      current
+       DESCRIPTION
+           "The compliance statement for SNMP agents which implement
+            the full WWW-MIB."
+       MODULE  -- this module
+       MANDATORY-GROUPS {
+           wwwServiceGroup,
+           wwwSummaryGroup
+       }
+       GROUP  wwwRequestInGroup
+       DESCRIPTION
+           "The wwwRequestInGroup is mandatory only for WWW server
+            or proxy server implementations."
+       GROUP wwwResponseOutGroup
+       DESCRIPTION
+           "The wwwResponseOutGroup is mandatory only for WWW server
+            or proxy server implementations."
+       GROUP wwwRequestOutGroup
+       DESCRIPTION
+           "The wwwRequestOutGroup is mandatory only for WWW client
+            or proxy server implementations."
+       GROUP wwwResponseInGroup
+       DESCRIPTION
+           "The wwwRequestOutGroup is mandatory only for WWW client
+            or proxy server implementations."
+       GROUP wwwDocumentGroup
+       DESCRIPTION
+           "The wwwDocumentGroup is mandatory only for WWW server
+            or proxy server implementations."
+       OBJECT wwwSummaryOutRequests
+       DESCRIPTION
+           "Instances of wwwSummaryOutRequests do not exist on pure
+            WWW server implementations."
+       OBJECT wwwSummaryInResponses
+       DESCRIPTION
+           "Instances of wwwSummaryOutRequests do not exist on pure
+            WWW server implementations."
+       OBJECT wwwSummaryInRequests
+       DESCRIPTION
+           "Instances of wwwSummaryInRequests do not exist on pure
+            WWW client implementations."
+       OBJECT wwwSummaryOutResponses
+       DESCRIPTION
+           "Instances of wwwSummaryOutResponses do not exist on pure
+            WWW client implementations."
+       ::= { wwwMIBCompliances 2 }
+
+
+Hazewinkel, et al.          Standards Track                    [Page 33]
+
+RFC 2594                    WWW Service MIB                     May 1999
+
+
+   wwwServiceGroup OBJECT-GROUP
+       OBJECTS {
+           wwwServiceDescription,
+           wwwServiceContact,
+           wwwServiceProtocol,
+           wwwServiceName,
+           wwwServiceType,
+           wwwServiceStartTime,
+           wwwServiceOperStatus,
+           wwwServiceLastChange
+       }
+       STATUS      current
+       DESCRIPTION
+           "A collection of objects providing information about
+            the WWW services known by the SNMP agent."
+       ::= { wwwMIBGroups 1 }
+
+   wwwSummaryGroup OBJECT-GROUP
+       OBJECTS {
+           wwwSummaryInRequests,
+           wwwSummaryOutRequests,
+           wwwSummaryInResponses,
+           wwwSummaryOutResponses,
+           wwwSummaryInBytes,
+           wwwSummaryInLowBytes,
+           wwwSummaryOutBytes,
+           wwwSummaryOutLowBytes
+       }
+       STATUS      current
+       DESCRIPTION
+           "A collection of objects providing summary statistics
+            about requests and responses generated and received
+            by a WWW service."
+       ::= { wwwMIBGroups 2 }
+
+   wwwRequestInGroup OBJECT-GROUP
+       OBJECTS {
+           wwwRequestInRequests,
+           wwwRequestInBytes,
+           wwwRequestInLastTime
+       }
+       STATUS      current
+       DESCRIPTION
+           "A collection of objects providing detailed statistics
+            about requests received by a WWW service."
+       ::= { wwwMIBGroups 3 }
+
+   wwwRequestOutGroup OBJECT-GROUP
+       OBJECTS {
+           wwwRequestOutRequests,
+
+
+Hazewinkel, et al.          Standards Track                    [Page 34]
+
+RFC 2594                    WWW Service MIB                     May 1999
+
+
+           wwwRequestOutBytes,
+           wwwRequestOutLastTime
+       }
+       STATUS      current
+       DESCRIPTION
+           "A collection of objects providing detailed statistics
+            about requests generated by a WWW service."
+       ::= { wwwMIBGroups 4 }
+
+   wwwResponseInGroup OBJECT-GROUP
+       OBJECTS {
+           wwwResponseInResponses,
+           wwwResponseInBytes,
+           wwwResponseInLastTime
+       }
+       STATUS      current
+       DESCRIPTION
+           "A collection of objects providing detailed statistics
+            about responses received by a WWW service."
+       ::= { wwwMIBGroups 5 }
+
+   wwwResponseOutGroup OBJECT-GROUP
+       OBJECTS {
+           wwwResponseOutResponses,
+           wwwResponseOutBytes,
+           wwwResponseOutLastTime
+       }
+       STATUS      current
+       DESCRIPTION
+           "A collection of objects providing detailed statistics
+            about responses generated by a WWW service."
+       ::= { wwwMIBGroups 6 }
+
+   wwwDocumentGroup OBJECT-GROUP
+       OBJECTS {
+           wwwDocCtrlLastNSize,
+           wwwDocCtrlLastNLock,
+           wwwDocCtrlBuckets,
+           wwwDocCtrlBucketTimeInterval,
+           wwwDocCtrlTopNSize,
+           wwwDocLastNName,
+           wwwDocLastNTimeStamp,
+           wwwDocLastNRequestType,
+           wwwDocLastNResponseType,
+           wwwDocLastNStatusMsg,
+           wwwDocLastNBytes,
+           wwwDocBucketTimeStamp,
+           wwwDocBucketAccesses,
+           wwwDocBucketDocuments,
+           wwwDocBucketBytes,
+
+
+Hazewinkel, et al.          Standards Track                    [Page 35]
+
+RFC 2594                    WWW Service MIB                     May 1999
+
+
+           wwwDocAccessTopNName,
+           wwwDocAccessTopNAccesses,
+           wwwDocAccessTopNBytes,
+           wwwDocAccessTopNLastResponseType,
+           wwwDocBytesTopNName,
+           wwwDocBytesTopNAccesses,
+           wwwDocBytesTopNBytes,
+           wwwDocBytesTopNLastResponseType
+       }
+       STATUS  current
+       DESCRIPTION
+           "A collection of objects providing information about
+            accesses to documents."
+       ::= { wwwMIBGroups 7 }
+
+   END
+
+
+7.  Document Transfer Protocol Mappings
+
+   This section describes how existing protocols such as HTTP [19,20]
+   and FTP [21] can be mapped on the abstract Document Transfer Protocol
+   (DTP) used within the definitions of the WWW MIB. Every mapping must
+   define the identifier which is used to uniquely identify the transfer
+   protocol. In addition, the mappings must define how requests and
+   responses are identified.
+
+
+7.1.  The HyperText Transfer Protocol
+
+   The HyperText Transfer Protocol (HTTP) [19,20] is an application-
+   level protocol used to transfer hypermedia documents in a distributed
+   networked environment. HTTP is based on the request/response paradigm
+   and can be mapped on the abstract DTP easily.
+
+   The HTTP protocol usually runs over TCP and uses the well-known TCP
+   port 80. Therefore, the default value for the wwwServiceProtocol
+   object is { applTCPProtoID 80 }.
+
+   HTTP allows for both requests and responses and an open-ended set of
+   message types. The general message syntax of HTTP is therefore used
+   for the protocol mapping. The BNF specification of the general HTTP
+   message syntax as defined in [20] is as follows:
+
+       generic-message = start-line
+                         *message-header
+                         CRLF
+                         [ message-body ]
+
+       start-line   = Request-Line | Status-Line
+
+
+Hazewinkel, et al.          Standards Track                    [Page 36]
+
+RFC 2594                    WWW Service MIB                     May 1999
+
+
+       Request-Line = Method SP Request-URI SP HTTP-Version CRLF
+
+       Status-Line  = HTTP-Version SP Status-Code SP Reason-Phrase CRLF
+
+   Every HTTP-message where the start-line is a Request-Line is
+   considered a request in the abstract DTP. Every HTTP-message where
+   the start-line is a Status-Line is considered a response in the
+   abstract DTP. The mappings of WwwRequestType and WwwResponseType are
+   defined as follows:
+
+   o    The WwwRequestType corresponds to the method token in the
+        Request-Line.
+
+   o    The WwwResponseType corresponds to the Status-Code in the
+        Status-Line.
+
+
+7.2.  The File Transfer Protocol
+
+   The File Transfer Protocol (FTP) [21] is an application-level
+   protocol used to transfer files between hosts connected by the TCP/IP
+   suite of protocols. FTP is based on a request/response paradigm and
+   is mapped on the abstract DTP as defined in this section. The FTP
+   model as defined in [21] is depicted below.
+
+                                              -------------
+                                              |+---------+|
+                                              ||   User  ||    --------
+                                              ||Interface|<--->| User |
+                                              |+----|----+|    --------
+                ----------                    |     |     |
+                |+------+| control connection |+----|----+|
+                ||Server|<------------------->||  Client ||
+                ||  PI  ||  Commands/Replies  ||    PI   ||
+                |+--|---+|                    |+----|----+|
+                |   |    |                    |     |     |
+    --------    |+--|---+|        Data        |+----|----+|    --------
+    | File |<--->|Server|<------------------->||  Client |<--->| File |
+    |System|    || DTP  ||     Connection     ||   DTP   ||    |System|
+    --------    |+------+|                    |+---------+|    --------
+                ----------                    -------------
+
+   FTP uses two different connection types between a client and a server
+   to transfer files. The control connection is persistent during a FTP
+   session and used to exchange FTP commands and associated replies. The
+   data connection is only available when bulk data has to be
+   transferred.
+
+   The FTP protocol usually runs over TCP and uses the well-known TCP
+   port 21 to setup the control connection. Therefore, the default value
+
+
+Hazewinkel, et al.          Standards Track                    [Page 37]
+
+RFC 2594                    WWW Service MIB                     May 1999
+
+
+   for the wwwServiceProtocol object is { applTCPProtoID 21 }.
+
+
+   Every FTP command is considered a request in the abstract DTP. Every
+   FTP reply is considered a response in the abstract DTP. It should be
+   noted that a single FTP command can result in multiple FTP replies
+   (e.g. preliminary positive replies). The primary response for a FTP
+   request contains a status code of the form 2xy, 3xy, 4xy or 5xy.  See
+   section 4.2 in [21] for the exact meaning of these status codes.  The
+   mappings for WwwRequestType and WwwResponseType are defined as
+   follows:
+
+   o    The WwwRequestType corresponds to the FTP command token.
+
+   o    The WwwResponseType corresponds to the three-digit code which
+        starts a reply. Multi-line replies with the same three-digit
+        code are counted as a single DTP response.
+
+
+8.  Security Considerations
+
+   There are a number of management objects defined in this MIB module
+   that have a MAX-ACCESS clause of read-write.  Such objects may be
+   considered sensitive or vulnerable in some network environments.  The
+   support for write operations in a non-secure environment without
+   proper protection can have a negative effect on network operations.
+
+   There are a number of managed objects in this MIB that may contain
+   sensitive information:
+
+   o    The document statistics group contains traffic information
+        including the names of documents that were a target of protocol
+        operations. This information is sensitive as it allows to obtain
+        access statistics for documents.
+
+   o    The protocol statistics are less sensitive, because they do not
+        contain details about the target of individual requests and
+        responses.  However, traffic statistics and error counters still
+        provide usage information about WWW services and about the
+        overall quality of WWW services. It is suggested that sites
+        configure MIB views so that a user of this MIB can only access
+        the portion of the statistics that belong to the WWW services
+        managed by that user.
+
+   o    The service and the summary statistics groups provide
+        information about the existence of WWW services and condensed
+        usage statistics.  Some sites may want to protect this
+        information as well, especially if they offer private WWW
+        services that should not be known by the outside world.
+
+
+Hazewinkel, et al.          Standards Track                    [Page 38]
+
+RFC 2594                    WWW Service MIB                     May 1999
+
+
+   SNMPv1 by itself is not a secure environment.  Even if the network
+   itself is secure (for example by using IPSec), there is no control as
+   to who on the secure network is allowed to access
+   (read/change/create/delete) the objects in this MIB.
+
+
+   It is recommended that implementers consider the security features as
+   provided by the SNMPv3 framework.  Specifically, the use of the
+   User-based Security Model RFC 2574 [12] and the View-based Access
+   Control Model RFC 2575 [15] is recommended.
+
+   It is then a customer/user responsibility to ensure that the SNMP
+   entity giving access to an instance of this MIB is properly
+   configured to give access to the objects only to those principals
+   (users) that have legitimate rights to indeed read or write
+   (change/create/delete) them.
+
+
+9.  Intellectual Property
+
+   The IETF takes no position regarding the validity or scope of any
+   intellectual property or other rights that might be claimed to
+   pertain to the implementation or use of the technology described in
+   this document or the extent to which any license under such rights
+   might or might not be available; neither does it represent that it
+   has made any effort to identify any such rights.  Information on the
+   IETF's procedures with respect to rights in standards-track and
+   standards-related documentation can be found in BCP-11.  Copies of
+   claims of rights made available for publication and any assurances of
+   licenses to be made available, or the result of an attempt made to
+   obtain a general license or permission for the use of such
+   proprietary rights by implementors or users of this specification can
+   be obtained from the IETF Secretariat.
+
+   The IETF invites any interested party to bring to its attention any
+   copyrights, patents or patent applications, or other proprietary
+   rights which may cover technology that may be required to practice
+   this standard.  Please address the information to the IETF Executive
+   Director.
+
+
+10.  Acknowledgments
+
+   This document was produced by the Application MIB working group.  The
+   editors gratefully acknowledge the comments of the following
+   individuals:
+
+       Mark Gamble, Cheryl Krupczak, Randy Presuhn, Jon Saperia,
+       Bob Stewart, Martin Toet, Chris Wellens, Kenneth White.
+
+
+Hazewinkel, et al.          Standards Track                    [Page 39]
+
+RFC 2594                    WWW Service MIB                     May 1999
+
+
+11.  Editors' Addresses
+
+
+     Harrie Hazewinkel
+     Joint Research Centre of the E.C.
+     via Fermi - Ispra 21020 (VA)
+     Italy
+
+     Phone: +39 0332786322
+     Fax: +39 0332785641
+     EMail: harrie.hazewinkel@jrc.it
+
+
+     Carl W. Kalbfleisch
+     Verio, Inc.
+     1950 Stemmons Frwy
+     Suite 2006
+     Dallas, TX 75207
+     USA
+
+     Phone: +1 214 290-8653
+     Fax: +1 214 744-0742
+     EMail: cwk@verio.net
+
+
+     Juergen Schoenwaelder
+     TU Braunschweig
+     Bueltenweg 74/75
+     38106 Braunschweig
+     Germany
+
+     Phone: +49 531 391-3683
+     Fax: +49 531 489-5936
+     EMail: schoenw@ibr.cs.tu-bs.de
+
+
+12.  References
+
+[1]  Wijnen,, B., Harrington, D. and R.  Presuhn, "An Architecture for
+     Describing SNMP Management Frameworks", RFC 2571, April 1999.
+
+[2]  Rose, M. and K. McCloghrie, "Structure and Identification of
+     Management Information for TCP/IP-based Internets", STD, 16, RFC
+     1155, May 1990.
+
+[3]  Rose, M. and K. McCloghrie, "Concise MIB Definitions", STD 16, RFC
+     1212, Performance Systems International, March 1991.
+
+[4]  Rose, M., "A Convention for Defining Traps for use with the SNMP",
+     RFC 1215, March 1991.
+
+
+Hazewinkel, et al.          Standards Track                    [Page 40]
+
+RFC 2594                    WWW Service MIB                     May 1999
+
+
+[5]  McCloghrie, K., Perkins, D., Schoenwaelder, J., Case, J., Rose, M.
+     and S. Waldbusser, "Structure of Management Information Version 2
+     (SMIv2)", STD 58, RFC 2578, April 1999.
+
+[6]  McCloghrie, K., Perkins, D., Schoenwaelder, J., Case, J., Rose, M.
+     and S. Waldbusser, "Textual Conventions for SMIv2", STD 58, RFC
+     2579, April 1999.
+
+[7]  McCloghrie, K., Perkins, D., Schoenwaelder, J., Case, J., Rose, M.
+     and S. Waldbusser, "Conformance Statements for SMIv2", STD 58, RFC
+     2580, April 1999.
+
+[8]  Case, J., Fedor, M., Schoffstall, M. and J. Davin, "Simple Network
+     Management Protocol", STD 15, RFC 1157, May 1990.
+
+[9]  Case, J., McCloghrie, K., Rose, M. and S. Waldbusser, "Introduction
+     to Community-based SNMPv2", RFC 1901, January 1996.
+
+[10] Case, J., McCloghrie, K., Rose, M. and S. Waldbusser, "Transport
+     Mappings for Version 2 of the Simple Network Management Protocol
+     (SNMPv2)", RFC 1906, January 1996.
+
+[11] Case, J., Harrington D., Presuhn R. and B. Wijnen, "Message
+     Processing and Dispatching for the Simple Network Management
+     Protocol (SNMP)", RFC 2572, April 1999.
+
+[12] Blumenthal, U. and B. Wijnen, "User-based Security Model (USM) for
+     version 3 of the Simple Network Management Protocol (SNMPv3)", RFC
+     2574, April 1999.
+
+[13] Case, J., McCloghrie, K., Rose, M. and S. Waldbusser, "Protocol
+     Operations for Version 2 of the Simple Network Management Protocol
+     (SNMPv2)", RFC 1905, January 1996.
+
+[14] Levi, D., Meyer, P. and B. Stewart, "SNMP Applications", RFC 2573,
+     April 1999.
+
+[15] Wijnen, B., Presuhn, R. and K. McCloghrie, "View-based Access
+     Control Model (VACM) for the Simple Network Management Protocol
+     (SNMP)", RFC 2575, April 1999.
+
+[16] Hovey, R. and S. Bradner, "The Organizations Involved in the IETF
+     Standards Process", BCP 11, RFC 2028, October 1996.
+
+
+
+
+
+
+
+
+Hazewinkel, et al.          Standards Track                    [Page 41]
+
+RFC 2594                    WWW Service MIB                     May 1999
+
+
+[17] Bradner, S., "Key words for use in RFCs to Indicate Requirement
+     Levels", BCP 14, RFC 2119, March 1997.
+
+[18] Berners-Lee, T., Fielding, R. and L. Masinter, "Uniform Resource
+     Identifiers (URI): Generic Syntax", RFC 2396, August 1998.
+
+[19] Berners-Lee, T., Fielding, R. and H. Frystyk, "Hypertext Transfer
+     Protocol -- HTTP/1.0", RFC 1945, May 1996.
+
+[20] Fielding, R., Gettys, J., Mogul, J., Frystyk, H. and T. Berners-
+     Lee, "Hypertext Transfer Protocol -- HTTP/1.1", RFC 2068, January
+     1997.
+
+[21] Postel, J. and J. Reynolds, "File Transfer Protocol (FTP)", STD 9,
+     RFC 959, October 1985.
+
+[22] Kalbfleisch, C., "Applicability of Standards Track MIBs to
+     Management of World Wide Web Servers", RFC 2039, November 1996.
+
+[23] Krupczak, C. and J. Saperia, "Definitions of System-Level Managed
+     Objects for Applications", RFC 2287, February 1998.
+
+[24] Kalbfleisch, C., Krupczak, C., Presuhn, R. and J. Saperia,
+     "Application Management MIB", RFC 2564, May 1999.
+
+[25] Kantor, B. and P. Lapsley, "Network News Transfer Protocol: A
+     Proposed Standard for the Stream-Based Transmission of News", RFC
+     977, February 1986.
+
+[26] Callaghan, B., "WebNFS Client Specification", RFC 2054, October
+     1996
+
+[27] Callaghan, B., "WebNFS Server Specification", RFC 2055, October
+     1996.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Hazewinkel, et al.          Standards Track                    [Page 42]
+
+RFC 2594                    WWW Service MIB                     May 1999
+
+
+13.  Full Copyright Statement
+
+   Copyright (C) The Internet Society (1999). All Rights Reserved.
+
+   This document and translations of it may be copied and furnished to
+   others, and derivative works that comment on or otherwise explain it
+   or assist in its implementation may be prepared, copied, published
+   and distributed, in whole or in part, without restriction of any
+   kind, provided that the above copyright notice and this paragraph are
+   included on all such copies and derivative works.  However, this
+   document itself may not be modified in any way, such as by removing
+   the copyright notice or references to the Internet Society or other
+   Internet organizations, except as needed for the  purpose of
+   developing Internet standards in which case the procedures for
+   copyrights defined in the Internet Standards process must be
+   followed, or as required to translate it into languages other than
+   English.
+
+   The limited permissions granted above are perpetual and will not be
+   revoked by the Internet Society or its successors or assigns.
+
+   This document and the information contained herein is provided on an
+   "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
+   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
+   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
+   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
+   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
+
+Acknowledgement
+
+   Funding for the RFC Editor function is currently provided by the
+   Internet Society.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Hazewinkel, et al.          Standards Track                    [Page 43]
+
\ No newline at end of file
diff -ru -ruN apache_1.3.34_orig/htdocs/manual/snmp_agt/snmpv2-mib.txt apache_1.3.34/htdocs/manual/snmp_agt/snmpv2-mib.txt
--- apache_1.3.34_orig/htdocs/manual/snmp_agt/snmpv2-mib.txt	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/htdocs/manual/snmp_agt/snmpv2-mib.txt	2006-05-18 16:49:19.294763952 +0200
@@ -0,0 +1,750 @@
+SNMPv2-MIB DEFINITIONS ::= BEGIN
+
+IMPORTS
+    MODULE-IDENTITY, OBJECT-TYPE, NOTIFICATION-TYPE,
+    TimeTicks, Counter32, snmpModules, mib-2
+        FROM SNMPv2-SMI
+    DisplayString, TestAndIncr, TimeStamp
+        FROM SNMPv2-TC
+    MODULE-COMPLIANCE, OBJECT-GROUP, NOTIFICATION-GROUP
+        FROM SNMPv2-CONF;
+
+snmpMIB MODULE-IDENTITY
+    LAST-UPDATED "9511090000Z"
+    ORGANIZATION "IETF SNMPv2 Working Group"
+    CONTACT-INFO
+            "        Marshall T. Rose
+
+             Postal: Dover Beach Consulting, Inc.
+                     420 Whisman Court
+                     Mountain View, CA  94043-2186
+                     US
+
+                Tel: +1 415 968 1052
+
+             E-mail: mrose@dbc.mtview.ca.us"
+    DESCRIPTION
+            "The MIB module for SNMPv2 entities."
+    REVISION      "9304010000Z"
+    DESCRIPTION
+            "The initial revision of this MIB module was published as
+            RFC 1450."
+    ::= { snmpModules 1 }
+
+
+snmpMIBObjects OBJECT IDENTIFIER ::= { snmpMIB 1 }
+
+--  ::= { snmpMIBObjects 1 }        this OID is obsolete
+--  ::= { snmpMIBObjects 2 }        this OID is obsolete
+--  ::= { snmpMIBObjects 3 }        this OID is obsolete
+
+
+-- the System group
+--
+
+system   OBJECT IDENTIFIER ::= { mib-2 1 }
+
+sysDescr OBJECT-TYPE
+    SYNTAX      DisplayString (SIZE (0..255))
+    MAX-ACCESS  read-only
+    STATUS      current
+    DESCRIPTION
+            "A textual description of the entity.  This value should
+            include the full name and version identification of the
+            system's hardware type, software operating-system, and
+            networking software."
+    ::= { system 1 }
+
+sysObjectID OBJECT-TYPE
+    SYNTAX      OBJECT IDENTIFIER
+    MAX-ACCESS  read-only
+    STATUS      current
+    DESCRIPTION
+            "The vendor's authoritative identification of the network
+            allocated within the SMI enterprises subtree (1.3.6.1.4.1)
+            and provides an easy and unambiguous means for determining
+            `Flintstones, Inc.' was assigned the subtree
+            1.3.6.1.4.1.4242, it could assign the identifier
+            1.3.6.1.4.1.4242.1.1 to its `Fred Router'."
+    ::= { system 2 }
+
+sysUpTime OBJECT-TYPE
+    SYNTAX      TimeTicks
+    MAX-ACCESS  read-only
+    STATUS      current
+    DESCRIPTION
+            "The time (in hundredths of a second) since the network
+            management portion of the system was last re-initialized."
+    ::= { system 3 }
+
+sysContact OBJECT-TYPE
+    SYNTAX      DisplayString (SIZE (0..255))
+    MAX-ACCESS  read-write
+    STATUS      current
+    DESCRIPTION
+            "The textual identification of the contact person for this
+            this person.  If no contact information is known, the value
+            is the zero-length string."
+    ::= { system 4 }
+
+sysName OBJECT-TYPE
+    SYNTAX      DisplayString (SIZE (0..255))
+    MAX-ACCESS  read-write
+    STATUS      current
+    DESCRIPTION
+            "An administratively-assigned name for this managed node.
+            By convention, this is the node's fully-qualified domain
+            name.  If the name is unknown, the value is the zero-length
+            string."
+    ::= { system 5 }
+
+sysLocation OBJECT-TYPE
+    SYNTAX      DisplayString (SIZE (0..255))
+    MAX-ACCESS  read-write
+    STATUS      current
+    DESCRIPTION
+            "The physical location of this node (e.g., `telephone
+            closet, 3rd floor').  If the location is unknown, the value
+            is the zero-length string."
+    ::= { system 6 }
+
+sysServices OBJECT-TYPE
+    SYNTAX      INTEGER (0..127)
+    MAX-ACCESS  read-only
+    STATUS      current
+    DESCRIPTION
+            "A value which indicates the set of services that this
+            entity may potentially offers.  The value is a sum.  This
+            sum initially takes the value zero, Then, for each layer, L,
+            in the range 1 through 7, that this node performs
+            transactions for, 2 raised to (L - 1) is added to the sum.
+            For example, a node which performs only routing functions
+            would have a value of 4 (2^(3-1)).  In contrast, a node
+            which is a host offering application services would have a
+            value of 72 (2^(4-1) + 2^(7-1)).  Note that in the context
+            of the Internet suite of protocols, values should be
+            calculated accordingly:
+
+                 layer      functionality
+                   1        physical (e.g., repeaters)
+                   2        datalink/subnetwork (e.g., bridges)
+                   3        internet (e.g., supports the IP)
+                   4        end-to-end  (e.g., supports the TCP)
+                   7        applications (e.g., supports the SMTP)
+
+            For systems including OSI protocols, layers 5 and 6 may also
+            be counted."
+    ::= { system 7 }
+
+
+-- object resource information
+--
+-- a collection of objects which describe the SNMPv2 entity's
+-- (statically and dynamically configurable) support of
+-- various MIB modules.
+
+sysORLastChange OBJECT-TYPE
+    SYNTAX     TimeStamp
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+            "The value of sysUpTime at the time of the most recent
+            change in state or value of any instance of sysORID."
+    ::= { system 8 }
+
+sysORTable OBJECT-TYPE
+    SYNTAX     SEQUENCE OF SysOREntry
+    MAX-ACCESS not-accessible
+    STATUS     current
+    DESCRIPTION
+            "The (conceptual) table listing the capabilities of the
+            various MIB modules.  SNMPv2 entities having dynamically-
+            configurable support of MIB modules will have a
+            dynamically-varying number of conceptual rows."
+    ::= { system 9 }
+
+sysOREntry OBJECT-TYPE
+    SYNTAX     SysOREntry
+    MAX-ACCESS not-accessible
+    STATUS     current
+    DESCRIPTION
+            "An entry (conceptual row) in the sysORTable."
+    INDEX      { sysORIndex }
+    ::= { sysORTable 1 }
+
+SysOREntry ::= SEQUENCE {
+    sysORIndex     INTEGER,
+    sysORID        OBJECT IDENTIFIER,
+    sysORDescr     DisplayString,
+    sysORUpTime    TimeStamp
+}
+
+sysORIndex OBJECT-TYPE
+    SYNTAX     INTEGER (1..2147483647)
+    MAX-ACCESS not-accessible
+    STATUS     current
+    DESCRIPTION
+            "The auxiliary variable used for identifying instances of
+            the columnar objects in the sysORTable."
+    ::= { sysOREntry 1 }
+
+sysORID OBJECT-TYPE
+    SYNTAX     OBJECT IDENTIFIER
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+            "An authoritative identification of a capabilities statement
+            with respect to various MIB modules supported by the local
+            SNMPv2 entity acting in an agent role."
+    ::= { sysOREntry 2 }
+
+sysORDescr OBJECT-TYPE
+    SYNTAX     DisplayString
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+            "A textual description of the capabilities identified by the
+            corresponding instance of sysORID."
+    ::= { sysOREntry 3 }
+
+sysORUpTime OBJECT-TYPE
+    SYNTAX     TimeStamp
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+            "The value of sysUpTime at the time this conceptual row was
+            last instanciated."
+    ::= { sysOREntry 4 }
+
+
+-- the SNMP group
+--
+-- a collection of objects providing basic instrumentation and
+-- control of an SNMP entity.
+
+snmp     OBJECT IDENTIFIER ::= { mib-2 11 }
+
+snmpInPkts OBJECT-TYPE
+    SYNTAX     Counter32
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+            "The total number of messages delivered to the SNMP entity
+            from the transport service."
+    ::= { snmp 1 }
+
+snmpInBadVersions OBJECT-TYPE
+    SYNTAX     Counter32
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+            "The total number of SNMP messages which were delivered to
+            the SNMP entity and were for an unsupported SNMP version."
+    ::= { snmp 3 }
+
+snmpInBadCommunityNames OBJECT-TYPE
+    SYNTAX     Counter32
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+            "The total number of SNMP messages delivered to the SNMP
+            entity which used a SNMP community name not known to said
+            entity."
+    ::= { snmp 4 }
+
+snmpInBadCommunityUses OBJECT-TYPE
+    SYNTAX     Counter32
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+            "The total number of SNMP messages delivered to the SNMP
+            entity which represented an SNMP operation which was not
+            allowed by the SNMP community named in the message."
+    ::= { snmp 5 }
+
+snmpInASNParseErrs OBJECT-TYPE
+    SYNTAX     Counter32
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+            "The total number of ASN.1 or BER errors encountered by the
+            SNMP entity when decoding received SNMP messages."
+    ::= { snmp 6 }
+
+snmpEnableAuthenTraps OBJECT-TYPE
+    SYNTAX      INTEGER { enabled(1), disabled(2) }
+    MAX-ACCESS  read-write
+    STATUS      current
+    DESCRIPTION
+            "Indicates whether the SNMP entity is permitted to generate
+            authenticationFailure traps.  The value of this object
+            overrides any configuration information; as such, it
+            provides a means whereby all authenticationFailure traps may
+            be disabled.
+
+            Note that it is strongly recommended that this object be
+            stored in non-volatile memory so that it remains constant
+            across re-initializations of the network management system."
+    ::= { snmp 30 }
+
+snmpSilentDrops OBJECT-TYPE
+    SYNTAX     Counter32
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+            "The total number of GetRequest-PDUs, GetNextRequest-PDUs,
+            GetBulkRequest-PDUs, SetRequest-PDUs, and InformRequest-PDUs
+            delivered to the SNMP entity which were silently dropped
+            because the size of a reply containing an alternate
+            Response-PDU with an empty variable-bindings field was
+            greater than either a local constraint or the maximum
+            message size associated with the originator of the request."
+    ::= { snmp 31 }
+
+snmpProxyDrops OBJECT-TYPE
+    SYNTAX     Counter32
+    MAX-ACCESS read-only
+    STATUS     current
+    DESCRIPTION
+            "The total number of GetRequest-PDUs, GetNextRequest-PDUs,
+            GetBulkRequest-PDUs, SetRequest-PDUs, and InformRequest-PDUs
+            delivered to the SNMP entity which were silently dropped
+            because the transmission of the (possibly translated)
+            time-out) such that no Response-PDU could be returned."
+    ::= { snmp 32 }
+
+
+-- information for notifications
+--
+-- a collection of objects which allow the SNMPv2 entity, when
+-- SNMPv2-Trap-PDUs.
+
+snmpTrap       OBJECT IDENTIFIER ::= { snmpMIBObjects 4 }
+
+
+snmpTrapOID OBJECT-TYPE
+    SYNTAX     OBJECT IDENTIFIER
+    MAX-ACCESS accessible-for-notify
+    STATUS     current
+    DESCRIPTION
+            "The authoritative identification of the notification
+            currently being sent.  This variable occurs as the second
+            varbind in every SNMPv2-Trap-PDU and InformRequest-PDU."
+    ::= { snmpTrap 1 }
+
+--  ::= { snmpTrap 2 }   this OID is obsolete
+
+snmpTrapEnterprise OBJECT-TYPE
+    SYNTAX     OBJECT IDENTIFIER
+    MAX-ACCESS accessible-for-notify
+    STATUS     current
+    DESCRIPTION
+            "The authoritative identification of the enterprise
+            associated with the trap currently being sent.  When a
+            SNMPv2-Trap-PDU, this variable occurs as the last varbind."
+    ::= { snmpTrap 3 }
+
+--  ::= { snmpTrap 4 }   this OID is obsolete
+
+
+-- well-known traps
+
+snmpTraps      OBJECT IDENTIFIER ::= { snmpMIBObjects 5 }
+
+coldStart NOTIFICATION-TYPE
+    STATUS  current
+    DESCRIPTION
+            "A coldStart trap signifies that the SNMPv2 entity, acting
+            configuration may have been altered."
+    ::= { snmpTraps 1 }
+
+warmStart NOTIFICATION-TYPE
+    STATUS  current
+    DESCRIPTION
+            "A warmStart trap signifies that the SNMPv2 entity, acting
+            configuration is unaltered."
+    ::= { snmpTraps 2 }
+
+-- Note the linkDown NOTIFICATION-TYPE ::= { snmpTraps 3 }
+-- and the linkUp NOTIFICATION-TYPE ::= { snmpTraps 4 }
+-- are defined in RFC 1573
+
+authenticationFailure NOTIFICATION-TYPE
+    STATUS  current
+    DESCRIPTION
+            "An authenticationFailure trap signifies that the SNMPv2
+            implementations of the SNMPv2 must be capable of generating
+            this trap, the snmpEnableAuthenTraps object indicates
+            whether this trap will be generated."
+    ::= { snmpTraps 5 }
+
+-- Note the egpNeighborLoss NOTIFICATION-TYPE ::= { snmpTraps 6 }
+-- is defined in RFC 1213
+--
+-- the set group
+--
+-- a collection of objects which allow several cooperating
+-- coordinate their use of the SNMPv2 set operation.
+
+snmpSet        OBJECT IDENTIFIER ::= { snmpMIBObjects 6 }
+
+
+snmpSetSerialNo OBJECT-TYPE
+    SYNTAX     TestAndIncr
+    MAX-ACCESS read-write
+    STATUS     current
+    DESCRIPTION
+            "An advisory lock used to allow several cooperating SNMPv2
+            use of the SNMPv2 set operation.
+
+            This object is used for coarse-grain coordination.  To
+            achieve fine-grain coordination, one or more similar objects
+            might be defined within each MIB group, as appropriate."
+    ::= { snmpSet 1 }
+
+
+-- conformance information
+
+snmpMIBConformance
+               OBJECT IDENTIFIER ::= { snmpMIB 2 }
+
+snmpMIBCompliances
+               OBJECT IDENTIFIER ::= { snmpMIBConformance 1 }
+snmpMIBGroups  OBJECT IDENTIFIER ::= { snmpMIBConformance 2 }
+
+
+-- compliance statements
+
+--    ::= { snmpMIBCompliances 1 }      this OID is obsolete
+
+snmpBasicCompliance MODULE-COMPLIANCE
+    STATUS  current
+    DESCRIPTION
+            "The compliance statement for SNMPv2 entities which
+            implement the SNMPv2 MIB."
+    MODULE  -- this module
+        MANDATORY-GROUPS { snmpGroup, snmpSetGroup, systemGroup,
+                           snmpBasicNotificationsGroup }
+
+        GROUP   snmpCommunityGroup
+        DESCRIPTION
+            "This group is mandatory for SNMPv2 entities which
+            support community-based authentication."
+    ::= { snmpMIBCompliances 2 }
+
+
+-- units of conformance
+
+--  ::= { snmpMIBGroups 1 }           this OID is obsolete
+--  ::= { snmpMIBGroups 2 }           this OID is obsolete
+--  ::= { snmpMIBGroups 3 }           this OID is obsolete
+--  ::= { snmpMIBGroups 4 }           this OID is obsolete
+
+snmpGroup OBJECT-GROUP
+    OBJECTS { snmpInPkts,
+              snmpInBadVersions,
+              snmpInASNParseErrs,
+              snmpSilentDrops,
+              snmpProxyDrops,
+              snmpEnableAuthenTraps }
+    STATUS  current
+    DESCRIPTION
+            "A collection of objects providing basic instrumentation and
+            control of an SNMPv2 entity."
+    ::= { snmpMIBGroups 8 }
+
+snmpCommunityGroup OBJECT-GROUP
+    OBJECTS { snmpInBadCommunityNames,
+              snmpInBadCommunityUses }
+    STATUS  current
+    DESCRIPTION
+            "A collection of objects providing basic instrumentation of
+            a SNMPv2 entity which supports community-based
+            authentication."
+    ::= { snmpMIBGroups 9 }
+
+snmpSetGroup OBJECT-GROUP
+    OBJECTS { snmpSetSerialNo }
+    STATUS  current
+    DESCRIPTION
+            "A collection of objects which allow several cooperating
+            their use of the SNMPv2 set operation."
+    ::= { snmpMIBGroups 5 }
+
+systemGroup OBJECT-GROUP
+    OBJECTS { sysDescr, sysObjectID, sysUpTime,
+              sysContact, sysName, sysLocation,
+              sysServices,
+              sysORLastChange, sysORID,
+              sysORUpTime, sysORDescr }
+    STATUS  current
+    DESCRIPTION
+            "The system group defines objects which are common to all
+            managed systems."
+    ::= { snmpMIBGroups 6 }
+
+snmpBasicNotificationsGroup NOTIFICATION-GROUP
+    NOTIFICATIONS { coldStart, authenticationFailure }
+    STATUS        current
+    DESCRIPTION
+            "The two notifications which an SNMPv2 entity is required to
+            implement."
+    ::= { snmpMIBGroups 7 }
+
+
+-- definitions in RFC 1213 made obsolete by the inclusion of a
+-- subset of the snmp group in this MIB
+
+snmpOutPkts OBJECT-TYPE
+    SYNTAX      Counter32
+    MAX-ACCESS  read-only
+    STATUS      obsolete
+    DESCRIPTION
+            "The total number of SNMP Messages which were
+            passed from the SNMP protocol entity to the
+            transport service."
+    ::= { snmp 2 }
+
+-- { snmp 7 } is not used
+
+snmpInTooBigs OBJECT-TYPE
+    SYNTAX      Counter32
+    MAX-ACCESS  read-only
+    STATUS      obsolete
+    DESCRIPTION
+            "The total number of SNMP PDUs which were
+            delivered to the SNMP protocol entity and for
+            which the value of the error-status field is
+            `tooBig'."
+    ::= { snmp 8 }
+
+snmpInNoSuchNames OBJECT-TYPE
+    SYNTAX      Counter32
+    MAX-ACCESS  read-only
+   STATUS      obsolete
+    DESCRIPTION
+            "The total number of SNMP PDUs which were
+            delivered to the SNMP protocol entity and for
+            which the value of the error-status field is
+            `noSuchName'."
+    ::= { snmp 9 }
+
+snmpInBadValues OBJECT-TYPE
+    SYNTAX      Counter32
+    MAX-ACCESS  read-only
+    STATUS      obsolete
+    DESCRIPTION
+            "The total number of SNMP PDUs which were
+            delivered to the SNMP protocol entity and for
+            which the value of the error-status field is
+            `badValue'."
+    ::= { snmp 10 }
+
+snmpInReadOnlys OBJECT-TYPE
+    SYNTAX      Counter32
+    MAX-ACCESS  read-only
+    STATUS      obsolete
+    DESCRIPTION
+            "The total number valid SNMP PDUs which were
+            delivered to the SNMP protocol entity and for
+            which the value of the error-status field is
+            `readOnly'.  It should be noted that it is a
+            protocol error to generate an SNMP PDU which
+            contains the value `readOnly' in the error-status
+            field, as such this object is provided as a means
+            of detecting incorrect implementations of the
+            SNMP."
+    ::= { snmp 11 }
+
+snmpInGenErrs OBJECT-TYPE
+    SYNTAX      Counter32
+    MAX-ACCESS  read-only
+    STATUS      obsolete
+    DESCRIPTION
+            "The total number of SNMP PDUs which were
+            delivered to the SNMP protocol entity and for
+            which the value of the error-status field is
+            `genErr'."
+    ::= { snmp 12 }
+
+snmpInTotalReqVars OBJECT-TYPE
+    SYNTAX      Counter32
+    MAX-ACCESS  read-only
+    STATUS      obsolete
+    DESCRIPTION
+            "The total number of MIB objects which have been
+            retrieved successfully by the SNMP protocol entity
+            as the result of receiving valid SNMP Get-Request
+            and Get-Next PDUs."
+    ::= { snmp 13 }
+
+snmpInTotalSetVars OBJECT-TYPE
+    SYNTAX      Counter32
+    MAX-ACCESS  read-only
+    STATUS      obsolete
+    DESCRIPTION
+            "The total number of MIB objects which have been
+            altered successfully by the SNMP protocol entity
+            as the result of receiving valid SNMP Set-Request
+            PDUs."
+    ::= { snmp 14 }
+
+snmpInGetRequests OBJECT-TYPE
+    SYNTAX      Counter32
+    MAX-ACCESS  read-only
+    STATUS      obsolete
+    DESCRIPTION
+            "The total number of SNMP Get-Request PDUs which
+            have been accepted and processed by the SNMP
+            protocol entity."
+    ::= { snmp 15 }
+
+snmpInGetNexts OBJECT-TYPE
+    SYNTAX      Counter32
+    MAX-ACCESS  read-only
+    STATUS      obsolete
+    DESCRIPTION
+            "The total number of SNMP Get-Next PDUs which have
+            been accepted and processed by the SNMP protocol
+            entity."
+    ::= { snmp 16 }
+
+snmpInSetRequests OBJECT-TYPE
+    SYNTAX      Counter32
+    MAX-ACCESS  read-only
+    STATUS      obsolete
+    DESCRIPTION
+            "The total number of SNMP Set-Request PDUs which
+            have been accepted and processed by the SNMP
+            protocol entity."
+    ::= { snmp 17 }
+
+snmpInGetResponses OBJECT-TYPE
+    SYNTAX      Counter32
+    MAX-ACCESS  read-only
+    STATUS      obsolete
+    DESCRIPTION
+            "The total number of SNMP Get-Response PDUs which
+            have been accepted and processed by the SNMP
+            protocol entity."
+    ::= { snmp 18 }
+
+snmpInTraps OBJECT-TYPE
+    SYNTAX      Counter32
+    MAX-ACCESS  read-only
+    STATUS      obsolete
+    DESCRIPTION
+            "The total number of SNMP Trap PDUs which have
+            been accepted and processed by the SNMP protocol
+            entity."
+    ::= { snmp 19 }
+
+snmpOutTooBigs OBJECT-TYPE
+    SYNTAX      Counter32
+    MAX-ACCESS  read-only
+    STATUS      obsolete
+    DESCRIPTION
+            "The total number of SNMP PDUs which were
+            generated by the SNMP protocol entity and for
+            which the value of the error-status field is
+            `tooBig.'"
+    ::= { snmp 20 }
+
+snmpOutNoSuchNames OBJECT-TYPE
+    SYNTAX      Counter32
+    MAX-ACCESS  read-only
+    STATUS      obsolete
+    DESCRIPTION
+            "The total number of SNMP PDUs which were
+            generated by the SNMP protocol entity and for
+            which the value of the error-status is
+            `noSuchName'."
+    ::= { snmp 21 }
+
+snmpOutBadValues OBJECT-TYPE
+    SYNTAX      Counter32
+    MAX-ACCESS  read-only
+    STATUS      obsolete
+    DESCRIPTION
+            "The total number of SNMP PDUs which were
+            generated by the SNMP protocol entity and for
+            which the value of the error-status field is
+            `badValue'."
+    ::= { snmp 22 }
+
+
+-- { snmp 23 } is not used
+
+snmpOutGenErrs OBJECT-TYPE
+    SYNTAX      Counter32
+    MAX-ACCESS  read-only
+    STATUS      obsolete
+    DESCRIPTION
+            "The total number of SNMP PDUs which were
+            generated by the SNMP protocol entity and for
+            which the value of the error-status field is
+            `genErr'."
+    ::= { snmp 24 }
+
+snmpOutGetRequests OBJECT-TYPE
+    SYNTAX      Counter32
+    MAX-ACCESS  read-only
+    STATUS      obsolete
+    DESCRIPTION
+            "The total number of SNMP Get-Request PDUs which
+            have been generated by the SNMP protocol entity."
+    ::= { snmp 25 }
+
+snmpOutGetNexts OBJECT-TYPE
+    SYNTAX      Counter32
+    MAX-ACCESS  read-only
+    STATUS      obsolete
+    DESCRIPTION
+            "The total number of SNMP Get-Next PDUs which have
+            been generated by the SNMP protocol entity."
+    ::= { snmp 26 }
+
+snmpOutSetRequests OBJECT-TYPE
+    SYNTAX      Counter32
+    MAX-ACCESS  read-only
+    STATUS      obsolete
+    DESCRIPTION
+            "The total number of SNMP Set-Request PDUs which
+            have been generated by the SNMP protocol entity."
+    ::= { snmp 27 }
+
+
+snmpOutGetResponses OBJECT-TYPE
+    SYNTAX      Counter32
+    MAX-ACCESS  read-only
+    STATUS      obsolete
+    DESCRIPTION
+            "The total number of SNMP Get-Response PDUs which
+            have been generated by the SNMP protocol entity."
+    ::= { snmp 28 }
+
+snmpOutTraps OBJECT-TYPE
+    SYNTAX      Counter32
+    MAX-ACCESS  read-only
+    STATUS      obsolete
+    DESCRIPTION
+            "The total number of SNMP Trap PDUs which have
+            been generated by the SNMP protocol entity."
+    ::= { snmp 29 }
+
+snmpObsoleteGroup OBJECT-GROUP
+    OBJECTS { snmpOutPkts, snmpInTooBigs, snmpInNoSuchNames,
+              snmpInBadValues, snmpInReadOnlys, snmpInGenErrs,
+              snmpInTotalReqVars, snmpInTotalSetVars,
+              snmpInGetRequests, snmpInGetNexts, snmpInSetRequests,
+              snmpInGetResponses, snmpInTraps, snmpOutTooBigs,
+              snmpOutNoSuchNames, snmpOutBadValues, snmpOutGenErrs,
+              snmpOutGetRequests, snmpOutGetNexts, snmpOutSetRequests,
+              snmpOutGetResponses, snmpOutTraps }
+    STATUS  obsolete
+    DESCRIPTION
+            "A collection of objects from RFC 1213 made obsolete by this
+            MIB."
+    ::= { snmpMIBGroups 10 }
+
+END
diff -ru -ruN apache_1.3.34_orig/htdocs/manual/snmp_agt/www-mib.txt apache_1.3.34/htdocs/manual/snmp_agt/www-mib.txt
--- apache_1.3.34_orig/htdocs/manual/snmp_agt/www-mib.txt	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/htdocs/manual/snmp_agt/www-mib.txt	2006-05-18 16:49:19.293764104 +0200
@@ -0,0 +1,1266 @@
+   WWW-MIB DEFINITIONS ::= BEGIN
+
+   IMPORTS
+       MODULE-IDENTITY, OBJECT-TYPE, mib-2,
+       Counter32, Counter64, Integer32, Unsigned32, TimeTicks
+           FROM SNMPv2-SMI
+
+       TEXTUAL-CONVENTION, DisplayString, DateAndTime, TimeInterval
+           FROM SNMPv2-TC
+
+       MODULE-COMPLIANCE, OBJECT-GROUP
+           FROM SNMPv2-CONF
+
+       Utf8String
+           FROM SYSAPPL-MIB;
+
+   wwwMIB MODULE-IDENTITY
+       LAST-UPDATED "9710140000Z"
+       ORGANIZATION "Application MIB Working Group"
+       CONTACT-INFO
+           "        Harrie Hazewinkel
+
+            Postal: Joint Research Centre of the E.C.
+                    via Fermi - Ispra 21020 (VA)
+                    Italy
+
+               Tel: +39+(0)332 786322
+               Fax: +39+(0)332 785641
+            E-mail: harrie.hazewinkel@jrc.it
+
+                    Carl W. Kalbfleisch
+
+            Postal: Verio, Inc.
+                    1950 Stemmons Freeway
+                    Suite 2004 - Infomart
+                    Dallas, TX 75207
+                    US
+
+               Tel: +1 972 238-8303
+               Fax: +1 972 238-0268
+            E-mail: cwk@verio.net
+
+                    Juergen Schoenwaelder
+
+            Postal: TU Braunschweig
+                   Bueltenweg 74/75
+                    38106 Braunschweig
+                    Germany
+
+               Tel: +49 531 391-3683
+               Fax: +49 531 489-5936
+            E-mail: schoenw@ibr.cs.tu-bs.de"
+       DESCRIPTION
+           "This WWW service MIB module is applicable to services
+            realized by a family of 'Document Transfer Protocols'
+            (DTP). Examples of DTPs are HTTP and FTP."
+       -- Get real registration number from IANA.
+       -- ::= { mib-2 XXXX }
+       ::= { mib-2 8080 }
+
+   --
+   --  Object Identifier Assignments
+   --
+
+   wwwMIBObjects     OBJECT IDENTIFIER ::= { wwwMIB 1 }
+   wwwMIBConformance OBJECT IDENTIFIER ::= { wwwMIB 2 }
+
+   --
+   -- Textual Conventions
+   --
+
+   WwwRequestType ::= TEXTUAL-CONVENTION
+       STATUS      current
+       DESCRIPTION
+           "The WwwRequestType defines the textual identification of
+            request types used by a document transfer protocol. For
+            the proper values for a given DTP, refer to the protocol
+            mappings for that DTP."
+       SYNTAX      OCTET STRING (SIZE (1..40))
+
+   WwwResponseType ::= TEXTUAL-CONVENTION
+       STATUS      current
+       DESCRIPTION
+           "The WwwResponseType defines the different response values
+            used by document transfer protocols. For the proper values
+            for a given DTP, refer to the protocol mappings for that
+            DTP."
+       SYNTAX      Integer32 (0..2147483647)
+
+   WwwOperStatus ::= TEXTUAL-CONVENTION
+       STATUS      current
+       DESCRIPTION
+           "The operational status of a WWW service. 'down' indicates
+            that the service is not available. 'running' indicates
+            that the service is operational and available. 'halted'
+            indicates that the service is operational but not
+            available. 'congested' indicates that the service is
+            operational but no additional inbound associations can be
+            accommodated. 'restarting' indicates that the service is
+            currently unavailable but is in the process of restarting
+            and will be available soon."
+       SYNTAX      INTEGER {
+                       down(1),
+                       running(2),
+                       halted(3),
+                       congested(4),
+                       restarting(5)
+                   }
+
+   WwwDocName ::= TEXTUAL-CONVENTION
+       DISPLAY-HINT "255a"
+       STATUS      current
+       DESCRIPTION
+           "The server relative name of a document. If the URL were
+            http://www.x.org/standards/search/search.cgi?string=test
+            then the value of this textual convention would resolve
+            to '/standards/search/search.cgi'. This textual convention
+            uses the character set for URIs as defined in RFC 2396
+            section 2."
+       SYNTAX      OCTET STRING (SIZE (0..255))
+
+
+   -- The WWW Service Information Group
+   --
+   -- The WWW service information group contains information about
+   -- the WWW services known by the SNMP agent.
+
+   wwwService OBJECT IDENTIFIER ::= { wwwMIBObjects 1 }
+
+   wwwServiceTable OBJECT-TYPE
+       SYNTAX      SEQUENCE OF WwwServiceEntry
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "The table of the WWW services known by the SNMP agent."
+       ::= { wwwService 1 }
+
+   wwwServiceEntry OBJECT-TYPE
+       SYNTAX      WwwServiceEntry
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "Details about a particular WWW service."
+       INDEX       { wwwServiceIndex }
+       ::= { wwwServiceTable 1 }
+
+   WwwServiceEntry ::= SEQUENCE {
+       wwwServiceIndex             Unsigned32,
+       wwwServiceDescription       Utf8String,
+       wwwServiceContact           Utf8String,
+       wwwServiceProtocol          OBJECT IDENTIFIER,
+       wwwServiceName              DisplayString,
+       wwwServiceType              INTEGER,
+       wwwServiceStartTime         DateAndTime,
+       wwwServiceOperStatus        WwwOperStatus,
+       wwwServiceLastChange        DateAndTime
+   }
+
+   wwwServiceIndex OBJECT-TYPE
+       SYNTAX      Unsigned32
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "An integer used to uniquely identify a WWW service. The
+            value must be the same as the corresponding value of the
+            applSrvInst defined in the Application Management MIB
+            (APPLICATION-MIB) if the applSrvInst object is available.
+            It might be necessary to manually configure sub-agents in
+            order to meet this requirement."
+       ::= { wwwServiceEntry 1 }
+
+   wwwServiceDescription OBJECT-TYPE
+       SYNTAX      Utf8String
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "Textual description of the WWW service. This shall include
+            at least the vendor and version number of the application
+            realizing the WWW service. In a minimal case, this might
+            be the Product Token (see RFC 2068) for the application."
+       ::= { wwwServiceEntry 2 }
+
+   wwwServiceContact OBJECT-TYPE
+       SYNTAX      Utf8String
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The textual identification of the contact person for this
+            service, together with information on how to contact this
+            person. For instance, this might be a string containing an
+            email address, e.g. '<webmaster@domain.name>'."
+       ::= { wwwServiceEntry 3 }
+
+   wwwServiceProtocol OBJECT-TYPE
+       SYNTAX      OBJECT IDENTIFIER
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "An identification of the primary protocol in use by this
+            service. For Internet applications, the IANA maintains
+            a registry of the OIDs which correspond to well-known
+            application protocols.  If the application protocol is not
+            listed in the registry, an OID value of the form
+            {applTCPProtoID port} or {applUDPProtoID port} are used for
+            TCP-based and UDP-based protocols, respectively. In either
+            case 'port' corresponds to the primary port number being
+            used by the protocol."
+       REFERENCE
+           "The OID values applTCPProtoID and applUDPProtoID are
+            defined in the NETWORK-SERVICES-MIB (RFC 2248)."
+       ::= { wwwServiceEntry 4 }
+
+   wwwServiceName OBJECT-TYPE
+       SYNTAX      DisplayString
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The fully qualified domain name by which this service is
+            known. This object must contain the virtual host name if
+            the service is realized for a virtual host."
+       ::= { wwwServiceEntry 5 }
+
+   wwwServiceType OBJECT-TYPE
+       SYNTAX      INTEGER {
+                       wwwOther(1),
+                       wwwServer(2),
+                       wwwClient(3),
+                       wwwProxy(4),
+                       wwwCachingProxy(5)
+                   }
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The application type using or realizing this WWW service."
+       ::= { wwwServiceEntry 6 }
+
+   wwwServiceStartTime OBJECT-TYPE
+       SYNTAX      DateAndTime
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The date and time when this WWW service was last started.
+            The value SHALL be '0000000000000000'H if the last start
+            time of this WWW service is not known."
+       ::= { wwwServiceEntry 7 }
+
+   wwwServiceOperStatus OBJECT-TYPE
+       SYNTAX      WwwOperStatus
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "Indicates the operational status of the WWW service."
+       ::= { wwwServiceEntry 8 }
+
+   wwwServiceLastChange OBJECT-TYPE
+       SYNTAX      DateAndTime
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The date and time when this WWW service entered its current
+            operational state. The value SHALL be '0000000000000000'H if
+            the time of the last state change is not known."
+       ::= { wwwServiceEntry 9 }
+
+
+   -- The WWW Protocol Statistics Group
+   --
+   -- The WWW protocol statistics group contains statistics about
+   -- the DTP requests and responses sent or received.
+
+   wwwProtocolStatistics OBJECT IDENTIFIER ::= { wwwMIBObjects 2 }
+
+   wwwSummaryTable OBJECT-TYPE
+       SYNTAX      SEQUENCE OF WwwSummaryEntry
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "The table providing overview statistics for the
+            WWW services on this system."
+       ::= { wwwProtocolStatistics 1 }
+
+   wwwSummaryEntry OBJECT-TYPE
+       SYNTAX      WwwSummaryEntry
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "Overview statistics for an individual service."
+       INDEX       { wwwServiceIndex }
+       ::= { wwwSummaryTable 1 }
+
+   WwwSummaryEntry ::= SEQUENCE {
+       wwwSummaryInRequests        Counter32,
+       wwwSummaryOutRequests       Counter32,
+       wwwSummaryInResponses       Counter32,
+       wwwSummaryOutResponses      Counter32,
+       wwwSummaryInBytes           Counter64,
+       wwwSummaryInLowBytes        Counter32,
+       wwwSummaryOutBytes          Counter64,
+       wwwSummaryOutLowBytes       Counter32
+   }
+
+   wwwSummaryInRequests OBJECT-TYPE
+       SYNTAX      Counter32
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The number of requests successfully received."
+       ::= { wwwSummaryEntry 1 }
+
+   wwwSummaryOutRequests OBJECT-TYPE
+       SYNTAX      Counter32
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The number of requests generated."
+       ::= { wwwSummaryEntry 2 }
+
+   wwwSummaryInResponses OBJECT-TYPE
+       SYNTAX      Counter32
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The number of responses successfully received."
+       ::= { wwwSummaryEntry 3 }
+
+   wwwSummaryOutResponses OBJECT-TYPE
+       SYNTAX      Counter32
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The number of responses generated."
+       ::= { wwwSummaryEntry 4 }
+
+   wwwSummaryInBytes OBJECT-TYPE
+       SYNTAX      Counter64
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The number of content bytes received."
+       ::= { wwwSummaryEntry 5 }
+
+   wwwSummaryInLowBytes OBJECT-TYPE
+       SYNTAX      Counter32
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The lowest thirty-two bits of wwwSummaryInBytes."
+       ::= { wwwSummaryEntry 6 }
+
+   wwwSummaryOutBytes OBJECT-TYPE
+       SYNTAX      Counter64
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The number of content bytes transmitted."
+       ::= { wwwSummaryEntry 7 }
+
+   wwwSummaryOutLowBytes OBJECT-TYPE
+       SYNTAX      Counter32
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The lowest thirty-two bits of wwwSummaryOutBytes."
+       ::= { wwwSummaryEntry 8 }
+
+   -- The WWW request tables contain detailed information about
+   -- requests send or received by WWW services.
+
+   wwwRequestInTable OBJECT-TYPE
+       SYNTAX      SEQUENCE OF WwwRequestInEntry
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "The table providing detailed statistics for requests
+            received by WWW services on this system."
+       ::= { wwwProtocolStatistics 2 }
+
+   wwwRequestInEntry OBJECT-TYPE
+       SYNTAX      WwwRequestInEntry
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "Request statistics for an individual service."
+       INDEX       { wwwServiceIndex, wwwRequestInIndex }
+       ::= { wwwRequestInTable 1 }
+
+   WwwRequestInEntry ::= SEQUENCE {
+       wwwRequestInIndex           WwwRequestType,
+       wwwRequestInRequests        Counter32,
+       wwwRequestInBytes           Counter32,
+       wwwRequestInLastTime        DateAndTime
+   }
+
+   wwwRequestInIndex OBJECT-TYPE
+       SYNTAX      WwwRequestType
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "The particular request type the statistics apply to."
+       ::= { wwwRequestInEntry 1 }
+
+   wwwRequestInRequests OBJECT-TYPE
+       SYNTAX      Counter32
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The number of requests of this type received by this
+            WWW service."
+       ::= { wwwRequestInEntry 2 }
+
+   wwwRequestInBytes OBJECT-TYPE
+       SYNTAX      Counter32
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The number of content bytes per request type received
+            by this WWW service."
+       ::= { wwwRequestInEntry 3 }
+
+   wwwRequestInLastTime OBJECT-TYPE
+       SYNTAX      DateAndTime
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The date and time when the last byte of the last complete
+            request of this type was received by this WWW service. The
+            value SHALL be '0000000000000000'H if no request of this
+            type has been received yet."
+       ::= { wwwRequestInEntry 4 }
+
+   wwwRequestOutTable OBJECT-TYPE
+       SYNTAX      SEQUENCE OF WwwRequestOutEntry
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "The table providing detailed statistics for requests
+            generated by the services on this system."
+       ::= { wwwProtocolStatistics 3 }
+
+   wwwRequestOutEntry OBJECT-TYPE
+       SYNTAX      WwwRequestOutEntry
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "Request statistics for an individual service."
+       INDEX       { wwwServiceIndex, wwwRequestOutIndex }
+       ::= { wwwRequestOutTable 1 }
+
+   WwwRequestOutEntry ::= SEQUENCE {
+       wwwRequestOutIndex          WwwRequestType,
+       wwwRequestOutRequests       Counter32,
+       wwwRequestOutBytes          Counter32,
+       wwwRequestOutLastTime       DateAndTime
+   }
+
+   wwwRequestOutIndex OBJECT-TYPE
+       SYNTAX      WwwRequestType
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "The particular request type the statistics apply to."
+       ::= { wwwRequestOutEntry 1 }
+
+   wwwRequestOutRequests OBJECT-TYPE
+       SYNTAX      Counter32
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The number of requests of this type generated by this
+            WWW service."
+       ::= { wwwRequestOutEntry 2 }
+
+   wwwRequestOutBytes OBJECT-TYPE
+       SYNTAX      Counter32
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The number of content bytes per requests type generated
+            by this WWW service."
+       ::= { wwwRequestOutEntry 3 }
+
+   wwwRequestOutLastTime OBJECT-TYPE
+       SYNTAX      DateAndTime
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The date and time when the first byte of the last request
+            of this type was send by this WWW service. The value SHALL
+            be '0000000000000000'H if no request of this type has been
+            send yet."
+       ::= { wwwRequestOutEntry 4 }
+
+   -- The WWW response tables contain detailed information about
+   -- responses sent or received by WWW services.
+
+   wwwResponseInTable OBJECT-TYPE
+       SYNTAX      SEQUENCE OF WwwResponseInEntry
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "The table providing detailed statistics for responses
+            received by WWW services on this system."
+       ::= { wwwProtocolStatistics 4 }
+
+   wwwResponseInEntry OBJECT-TYPE
+       SYNTAX      WwwResponseInEntry
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "Response statistics for an individual service."
+       INDEX       { wwwServiceIndex, wwwResponseInIndex }
+       ::= { wwwResponseInTable 1 }
+
+   WwwResponseInEntry ::= SEQUENCE {
+       wwwResponseInIndex          WwwResponseType,
+       wwwResponseInResponses      Counter32,
+       wwwResponseInBytes          Counter32,
+       wwwResponseInLastTime       DateAndTime
+   }
+
+   wwwResponseInIndex OBJECT-TYPE
+       SYNTAX      WwwResponseType
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "The particular response type the statistics apply to."
+       ::= { wwwResponseInEntry 1 }
+
+   wwwResponseInResponses OBJECT-TYPE
+       SYNTAX      Counter32
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The number of responses of this type received by this
+            WWW service."
+       ::= { wwwResponseInEntry 2 }
+
+   wwwResponseInBytes OBJECT-TYPE
+       SYNTAX      Counter32
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The number of content bytes per response type received
+            by this WWW service."
+       ::= { wwwResponseInEntry 3 }
+
+   wwwResponseInLastTime OBJECT-TYPE
+       SYNTAX      DateAndTime
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The date and time when the last byte of the last complete
+            response of this type was received by this WWW service. The
+            value SHALL be '0000000000000000'H if no response of this
+            type has been received yet."
+       ::= { wwwResponseInEntry 4 }
+
+   wwwResponseOutTable OBJECT-TYPE
+       SYNTAX      SEQUENCE OF WwwResponseOutEntry
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "The table providing detailed statistics for responses
+            generated by services on this system."
+       ::= { wwwProtocolStatistics 5 }
+
+   wwwResponseOutEntry OBJECT-TYPE
+       SYNTAX      WwwResponseOutEntry
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "Response statistics for an individual service."
+       INDEX       { wwwServiceIndex, wwwResponseOutIndex }
+       ::= { wwwResponseOutTable 1 }
+
+   WwwResponseOutEntry ::= SEQUENCE {
+       wwwResponseOutIndex         WwwResponseType,
+       wwwResponseOutResponses     Counter32,
+       wwwResponseOutBytes         Counter32,
+       wwwResponseOutLastTime      DateAndTime
+   }
+
+   wwwResponseOutIndex OBJECT-TYPE
+       SYNTAX      WwwResponseType
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "The particular response type the statistics apply to."
+       ::= { wwwResponseOutEntry 1 }
+
+   wwwResponseOutResponses OBJECT-TYPE
+       SYNTAX      Counter32
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The number of responses of this type generated by this
+            WWW service."
+       ::= { wwwResponseOutEntry 2 }
+
+   wwwResponseOutBytes OBJECT-TYPE
+       SYNTAX      Counter32
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The number of content bytes per response type generated
+            by this WWW service."
+       ::= { wwwResponseOutEntry 3 }
+
+   wwwResponseOutLastTime OBJECT-TYPE
+       SYNTAX      DateAndTime
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The date and time when the first byte of the last response of
+            this type was sent by this WWW service. The value SHALL be
+            '0000000000000000'H if response of this type has been send
+            yet."
+       ::= { wwwResponseOutEntry 4 }
+
+
+   -- The WWW Document Statistics Group
+   --
+   -- The WWW document statistics group contains statistics about
+   -- document read attempts.
+
+   wwwDocumentStatistics OBJECT IDENTIFIER ::= { wwwMIBObjects 3 }
+
+   wwwDocCtrlTable OBJECT-TYPE
+       SYNTAX      SEQUENCE OF WwwDocCtrlEntry
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "A table which controls how the MIB implementation
+            collects and maintains document statistics."
+       ::= { wwwDocumentStatistics 1 }
+
+   wwwDocCtrlEntry OBJECT-TYPE
+       SYNTAX      WwwDocCtrlEntry
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "An entry used to configure the wwwDocLastNTable,
+            the wwwDocBucketTable, the wwwDocAccessTopNTable,
+            and the wwwDocBytesTopNTable."
+       INDEX       { wwwServiceIndex }
+       ::= { wwwDocCtrlTable 1 }
+
+   WwwDocCtrlEntry ::= SEQUENCE {
+       wwwDocCtrlLastNSize           Unsigned32,
+       wwwDocCtrlLastNLock           TimeTicks,
+       wwwDocCtrlBuckets             Unsigned32,
+       wwwDocCtrlBucketTimeInterval  TimeInterval,
+       wwwDocCtrlTopNSize            Unsigned32
+   }
+
+   wwwDocCtrlLastNSize OBJECT-TYPE
+       SYNTAX      Unsigned32
+       MAX-ACCESS  read-write
+       STATUS      current
+       DESCRIPTION
+           "The maximum number of entries in the wwwDocLastNTable."
+       DEFVAL { 25 }
+       ::= { wwwDocCtrlEntry 1 }
+
+   wwwDocCtrlLastNLock OBJECT-TYPE
+       SYNTAX      TimeTicks
+       MAX-ACCESS  read-write
+       STATUS      current
+       DESCRIPTION
+           "This object allows a manager to lock the wwwDocLastNTable
+            in order to retrieve the wwwDocLastNTable in a consistent
+            state. The agent is expected to take a snapshot of the
+            wwwDocLastNTable when it is locked and to continue updating
+            the real wwwDocLastNTable table so that recent information is
+            available as soon as the wwwDocLastNTable is unlocked again.
+
+            Setting this object to a value greater than 0 will lock
+            the table. The timer ticks backwards until it reaches 0.
+            The table unlocks automatically once the timer reaches 0
+            and the timer stops ticking.
+
+            A manager can increase the timer to request more time to
+            read the table. However, any attempt to decrease the timer
+            will fail with an inconsistentValue error. This rule ensures
+            that multiple managers can simultaneously lock and retrieve
+            the wwwDocLastNTable."
+       ::= { wwwDocCtrlEntry 2 }
+
+   wwwDocCtrlBuckets OBJECT-TYPE
+       SYNTAX      Unsigned32
+       MAX-ACCESS  read-write
+       STATUS      current
+       DESCRIPTION
+           "The maximum number of buckets maintained by the agent
+            before the oldest bucket is deleted. The buckets are used
+            to populate the wwwDocAccessTopNTable and the
+            wwwDocBytesTopNTable."
+       DEFVAL { 2 }
+       ::= { wwwDocCtrlEntry 3 }
+
+   wwwDocCtrlBucketTimeInterval OBJECT-TYPE
+       SYNTAX      TimeInterval
+       MAX-ACCESS  read-write
+       STATUS      current
+       DESCRIPTION
+           "The time interval after which a new bucket is created.
+            Changing this object has no effect on existing buckets."
+       DEFVAL { 90000 }    -- 15 minutes (resolution .01 s)
+       ::= { wwwDocCtrlEntry 4 }
+
+   wwwDocCtrlTopNSize OBJECT-TYPE
+       SYNTAX      Unsigned32
+       MAX-ACCESS  read-write
+       STATUS      current
+       DESCRIPTION
+           "The maximum number of entries shown in the
+            wwwDocAccessTopNTable and the wwwDocBytesTopNTable.
+            Changing this object has no effect on existing buckets."
+       DEFVAL { 25 }
+       ::= { wwwDocCtrlEntry 5 }
+
+
+   wwwDocLastNTable OBJECT-TYPE
+       SYNTAX      SEQUENCE OF WwwDocLastNEntry
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "The table which logs the last N access attempts."
+       ::= { wwwDocumentStatistics 2 }
+
+   wwwDocLastNEntry OBJECT-TYPE
+       SYNTAX      WwwDocLastNEntry
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "An entry which describes a recent access attempt."
+       INDEX       { wwwServiceIndex, wwwDocLastNIndex }
+       ::= { wwwDocLastNTable 1 }
+
+   WwwDocLastNEntry ::= SEQUENCE {
+       wwwDocLastNIndex            Unsigned32,
+       wwwDocLastNName             WwwDocName,
+       wwwDocLastNTimeStamp        DateAndTime,
+       wwwDocLastNRequestType      WwwRequestType,
+       wwwDocLastNResponseType     WwwResponseType,
+       wwwDocLastNStatusMsg        Utf8String,
+       wwwDocLastNBytes            Unsigned32
+   }
+
+   wwwDocLastNIndex OBJECT-TYPE
+       SYNTAX      Unsigned32
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "An arbitrary monotonically increasing integer number used
+            for indexing the wwwDocLastNTable. The first document
+            accessed appears in the table with this index value equal
+            to one. Each subsequent document is indexed with the next
+            sequential index value. The Nth document accessed will be
+            indexed by N. This table presents a sliding window of the
+            last N documents accessed where N is the value of
+            wwwDocCtrlLastNSize. Thus at any given time, the entries in
+            this table will be indexed by N-wwwDocCtrlLastNSize thru
+            N. The wwwDocCtrlLastNLock attribute can be used to lock
+            this table to allow the manager to read its contents."
+       ::= { wwwDocLastNEntry 1 }
+
+   wwwDocLastNName OBJECT-TYPE
+       SYNTAX      WwwDocName
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The name of the document for which access was attempted."
+       ::= { wwwDocLastNEntry 2 }
+
+   wwwDocLastNTimeStamp OBJECT-TYPE
+       SYNTAX      DateAndTime
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The date and time of the last attempt to access this
+            document."
+       ::= { wwwDocLastNEntry 3 }
+
+   wwwDocLastNRequestType OBJECT-TYPE
+       SYNTAX      WwwRequestType
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The protocol request type which was received by the
+            server when this document access was attempted."
+       ::= { wwwDocLastNEntry 4 }
+
+   wwwDocLastNResponseType OBJECT-TYPE
+       SYNTAX      WwwResponseType
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The protocol response type which was sent to the client
+            as a result of this attempt to access a document. This
+            object contains the type of the primary response if
+            there were multiple responses to a single request."
+       ::= { wwwDocLastNEntry 5 }
+
+   wwwDocLastNStatusMsg OBJECT-TYPE
+       SYNTAX      Utf8String
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "This object contains a human readable description of the
+            reason why the wwwDocLastNResponseType was returned to the
+            client. This object defines the implementation-specific
+            reason if the value of wwwDocLastNResponseType indicates
+            an error. For example, this object can indicate that the
+            requested document could not be transferred due to a
+            timeout condition or the document could not be transferred
+            because a 'soft link' pointing to the document could not be
+            resolved."
+       ::= { wwwDocLastNEntry 6 }
+
+   wwwDocLastNBytes OBJECT-TYPE
+       SYNTAX      Unsigned32
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The number of content bytes that were returned as a
+            result of this attempt to access a document."
+       ::= { wwwDocLastNEntry 7 }
+
+
+   wwwDocBucketTable OBJECT-TYPE
+       SYNTAX      SEQUENCE OF WwwDocBucketEntry
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "This table provides administrative summary information for
+            the buckets maintained per WWW service."
+       ::= { wwwDocumentStatistics 3 }
+
+   wwwDocBucketEntry OBJECT-TYPE
+       SYNTAX      WwwDocBucketEntry
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "An entry which describes the parameters associated with a
+            particular bucket."
+       INDEX       { wwwServiceIndex, wwwDocBucketIndex }
+       ::= { wwwDocBucketTable 1 }
+
+   WwwDocBucketEntry ::= SEQUENCE {
+       wwwDocBucketIndex           Unsigned32,
+       wwwDocBucketTimeStamp       DateAndTime,
+       wwwDocBucketAccesses        Unsigned32,
+       wwwDocBucketDocuments       Unsigned32,
+       wwwDocBucketBytes           Unsigned32
+   }
+
+   wwwDocBucketIndex OBJECT-TYPE
+       SYNTAX      Unsigned32
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "An arbitrary monotonically increasing integer number
+            used for indexing the wwwDocBucketTable. The index number
+            wraps to 1 whenever the maximum value is reached."
+       ::= { wwwDocBucketEntry 1 }
+
+   wwwDocBucketTimeStamp OBJECT-TYPE
+       SYNTAX      DateAndTime
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The date and time when the bucket was made available."
+       ::= { wwwDocBucketEntry 2 }
+
+   wwwDocBucketAccesses OBJECT-TYPE
+       SYNTAX      Unsigned32
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The total number of access attempts for any document
+            provided by this WWW service during the time interval
+            over which this bucket was created."
+       ::= { wwwDocBucketEntry 3 }
+
+   wwwDocBucketDocuments OBJECT-TYPE
+       SYNTAX      Unsigned32
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The total number of different documents for which access
+            was attempted this this WWW service during the time interval
+            over which this bucket was created."
+       ::= { wwwDocBucketEntry 4 }
+
+   wwwDocBucketBytes OBJECT-TYPE
+       SYNTAX      Unsigned32
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The total number of content bytes which were transferred
+            from this WWW service during the time interval over which
+            this bucket was created."
+       ::= { wwwDocBucketEntry 5 }
+
+
+   wwwDocAccessTopNTable OBJECT-TYPE
+       SYNTAX      SEQUENCE OF WwwDocAccessTopNEntry
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "The table of the most frequently accessed documents in a
+            given bucket. This table is sorted by the column
+            wwwDocAccessTopNAccesses. Entries having the same number
+            of accesses are secondarily sorted by wwwDocAccessTopNBytes.
+            Entries with the same number of accesses and the same
+            number of bytes will have an arbitrary order."
+       ::= { wwwDocumentStatistics 4 }
+
+   wwwDocAccessTopNEntry OBJECT-TYPE
+       SYNTAX      WwwDocAccessTopNEntry
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "An entry in the top N table sorted by document accesses."
+       INDEX       { wwwServiceIndex, wwwDocBucketIndex,
+                     wwwDocAccessTopNIndex }
+       ::= { wwwDocAccessTopNTable 1 }
+
+   WwwDocAccessTopNEntry ::= SEQUENCE {
+       wwwDocAccessTopNIndex             Unsigned32,
+       wwwDocAccessTopNName              WwwDocName,
+       wwwDocAccessTopNAccesses          Unsigned32,
+       wwwDocAccessTopNBytes             Unsigned32,
+       wwwDocAccessTopNLastResponseType  WwwResponseType
+   }
+
+   wwwDocAccessTopNIndex OBJECT-TYPE
+       SYNTAX      Unsigned32
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "An arbitrary monotonically increasing integer number
+            used for indexing the wwwDocAccessTopNTable. The index is
+            inversely correlated to the sorting order of the table. The
+            document with the highest access count will get the index
+            value 1."
+       ::= { wwwDocAccessTopNEntry 1 }
+
+   wwwDocAccessTopNName OBJECT-TYPE
+       SYNTAX      WwwDocName
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The name of the document for which access was attempted."
+       ::= { wwwDocAccessTopNEntry 2 }
+
+   wwwDocAccessTopNAccesses OBJECT-TYPE
+       SYNTAX      Unsigned32
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The total number of access attempts for this document."
+       ::= { wwwDocAccessTopNEntry 3 }
+
+   wwwDocAccessTopNBytes OBJECT-TYPE
+       SYNTAX      Unsigned32
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The total number of content bytes that were transmitted
+            as a result of attempts to access this document."
+       ::= { wwwDocAccessTopNEntry 4 }
+
+   wwwDocAccessTopNLastResponseType OBJECT-TYPE
+       SYNTAX      WwwResponseType
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The protocol response type which was sent to the client
+            as a result of the last attempt to access this document.
+            This object contains the type of the primary response if
+            there were multiple responses to a single request."
+       ::= { wwwDocAccessTopNEntry 5 }
+
+   wwwDocBytesTopNTable OBJECT-TYPE
+       SYNTAX      SEQUENCE OF WwwDocBytesTopNEntry
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "The table of the documents which caused most network
+            traffic in a given bucket. This table is sorted by the
+            column wwwDocBytesTopNBytes. Entries having the same number
+            bytes are secondarily sorted by wwwDocBytesTopNAccesses.
+            Entries with the same number of accesses and the same
+            number of bytes will have an arbitrary order."
+       ::= { wwwDocumentStatistics 5 }
+
+   wwwDocBytesTopNEntry OBJECT-TYPE
+       SYNTAX      WwwDocBytesTopNEntry
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "An entry in the top N table sorted by network traffic."
+       INDEX       { wwwServiceIndex, wwwDocBucketIndex,
+                     wwwDocBytesTopNIndex }
+       ::= { wwwDocBytesTopNTable 1 }
+
+   WwwDocBytesTopNEntry ::= SEQUENCE {
+       wwwDocBytesTopNIndex             Unsigned32,
+       wwwDocBytesTopNName              WwwDocName,
+       wwwDocBytesTopNAccesses          Unsigned32,
+       wwwDocBytesTopNBytes             Unsigned32,
+       wwwDocBytesTopNLastResponseType  WwwResponseType
+   }
+
+   wwwDocBytesTopNIndex OBJECT-TYPE
+       SYNTAX      Unsigned32
+       MAX-ACCESS  not-accessible
+       STATUS      current
+       DESCRIPTION
+           "An arbitrary monotonically increasing integer number
+            used for indexing the wwwDocBytesTopNTable. The index is
+            inversely correlated to the sorting order of the table. The
+            document with the highest byte count will get the index
+            value 1."
+       ::= { wwwDocBytesTopNEntry 1 }
+
+   wwwDocBytesTopNName OBJECT-TYPE
+       SYNTAX      WwwDocName
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The name of the document for which access was attempted."
+       ::= { wwwDocBytesTopNEntry 2 }
+
+   wwwDocBytesTopNAccesses OBJECT-TYPE
+       SYNTAX      Unsigned32
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The total number of access attempts for this document."
+       ::= { wwwDocBytesTopNEntry 3 }
+
+   wwwDocBytesTopNBytes OBJECT-TYPE
+       SYNTAX      Unsigned32
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The total number of content bytes that were transmitted
+            as a result of attempts to access this document."
+       ::= { wwwDocBytesTopNEntry 4 }
+
+   wwwDocBytesTopNLastResponseType OBJECT-TYPE
+       SYNTAX      WwwResponseType
+       MAX-ACCESS  read-only
+       STATUS      current
+       DESCRIPTION
+           "The protocol response type which was sent to the client
+            as a result of the last attempt to access this document.
+            This object contains the type of the primary response if
+            there were multiple responses to a single request."
+       ::= { wwwDocBytesTopNEntry 5 }
+
+   --
+   -- Conformance Definitions
+   --
+
+   wwwMIBCompliances OBJECT IDENTIFIER ::= { wwwMIBConformance 1 }
+   wwwMIBGroups      OBJECT IDENTIFIER ::= { wwwMIBConformance 2 }
+
+   wwwMinimalCompliance MODULE-COMPLIANCE
+       STATUS      current
+       DESCRIPTION
+           "The compliance statement for SNMP agents which implement
+            the minimal subset of the WWW-MIB. Implementors might
+            choose this subset for high-performance server where
+            full compliance might be to expensive."
+       MODULE  -- this module
+       MANDATORY-GROUPS {
+           wwwServiceGroup,
+           wwwSummaryGroup
+       }
+       OBJECT wwwSummaryOutRequests
+       DESCRIPTION
+           "The value of wwwSummaryOutRequests will be zero for
+            pure WWW server implementations."
+       OBJECT wwwSummaryInResponses
+       DESCRIPTION
+           "The value of wwwSummaryOutRequests will be zero for
+            pure WWW server implementations."
+       OBJECT wwwSummaryInRequests
+       DESCRIPTION
+           "The value of wwwSummaryInRequests will be zero for
+            pure WWW client implementations."
+       OBJECT wwwSummaryOutResponses
+       DESCRIPTION
+           "The value of wwwSummaryOutResponses will be zero for
+            pure WWW client implementations."
+       ::= { wwwMIBCompliances 1 }
+
+   wwwFullCompliance MODULE-COMPLIANCE
+       STATUS      current
+       DESCRIPTION
+           "The compliance statement for SNMP agents which implement
+            the full WWW-MIB."
+       MODULE  -- this module
+       MANDATORY-GROUPS {
+           wwwServiceGroup,
+           wwwSummaryGroup
+       }
+       GROUP  wwwRequestInGroup
+       DESCRIPTION
+           "The wwwRequestInGroup is mandatory only for WWW server
+            or proxy server implementations."
+       GROUP wwwResponseOutGroup
+       DESCRIPTION
+           "The wwwResponseOutGroup is mandatory only for WWW server
+            or proxy server implementations."
+       GROUP wwwRequestOutGroup
+       DESCRIPTION
+           "The wwwRequestOutGroup is mandatory only for WWW client
+            or proxy server implementations."
+       GROUP wwwResponseInGroup
+       DESCRIPTION
+           "The wwwRequestOutGroup is mandatory only for WWW client
+            or proxy server implementations."
+       GROUP wwwDocumentGroup
+       DESCRIPTION
+           "The wwwDocumentGroup is mandatory only for WWW server
+            or proxy server implementations."
+       OBJECT wwwSummaryOutRequests
+       DESCRIPTION
+           "The value of wwwSummaryOutRequests will be zero for
+            pure WWW server implementations."
+       OBJECT wwwSummaryInResponses
+       DESCRIPTION
+           "The value of wwwSummaryOutRequests will be zero for
+            pure WWW server implementations."
+       OBJECT wwwSummaryInRequests
+       DESCRIPTION
+           "The value of wwwSummaryInRequests will be zero for
+            pure WWW client implementations."
+       OBJECT wwwSummaryOutResponses
+       DESCRIPTION
+           "The value of wwwSummaryOutResponses will be zero for
+            pure WWW client implementations."
+       ::= { wwwMIBCompliances 2 }
+
+   wwwServiceGroup OBJECT-GROUP
+       OBJECTS {
+           wwwServiceDescription,
+           wwwServiceContact,
+           wwwServiceProtocol,
+           wwwServiceName,
+           wwwServiceType,
+           wwwServiceStartTime,
+           wwwServiceOperStatus,
+           wwwServiceLastChange
+       }
+       STATUS      current
+       DESCRIPTION
+           "A collection of objects providing information about
+            the WWW services known by the SNMP agent."
+       ::= { wwwMIBGroups 1 }
+
+   wwwSummaryGroup OBJECT-GROUP
+       OBJECTS {
+           wwwSummaryInRequests,
+           wwwSummaryOutRequests,
+           wwwSummaryInResponses,
+           wwwSummaryOutResponses,
+           wwwSummaryInBytes,
+           wwwSummaryInLowBytes,
+           wwwSummaryOutBytes,
+           wwwSummaryOutLowBytes
+       }
+       STATUS      current
+       DESCRIPTION
+           "A collection of objects providing summary statistics
+            about requests and responses generated and received
+            by a WWW service."
+       ::= { wwwMIBGroups 2 }
+
+   wwwRequestInGroup OBJECT-GROUP
+       OBJECTS {
+           wwwRequestInRequests,
+           wwwRequestInBytes,
+           wwwRequestInLastTime
+       }
+       STATUS      current
+       DESCRIPTION
+           "A collection of objects providing detailed statistics
+            about requests received by a WWW service."
+       ::= { wwwMIBGroups 3 }
+
+   wwwRequestOutGroup OBJECT-GROUP
+       OBJECTS {
+           wwwRequestOutRequests,
+           wwwRequestOutBytes,
+           wwwRequestOutLastTime
+       }
+       STATUS      current
+       DESCRIPTION
+           "A collection of objects providing detailed statistics
+            about requests generated by a WWW service."
+       ::= { wwwMIBGroups 4 }
+
+   wwwResponseInGroup OBJECT-GROUP
+       OBJECTS {
+           wwwResponseInResponses,
+           wwwResponseInBytes,
+           wwwResponseInLastTime
+       }
+       STATUS      current
+       DESCRIPTION
+           "A collection of objects providing detailed statistics
+            about responses received by a WWW service."
+       ::= { wwwMIBGroups 5 }
+
+   wwwResponseOutGroup OBJECT-GROUP
+       OBJECTS {
+           wwwResponseOutResponses,
+           wwwResponseOutBytes,
+           wwwResponseOutLastTime
+       }
+       STATUS      current
+       DESCRIPTION
+           "A collection of objects providing detailed statistics
+            about responses generated by a WWW service."
+       ::= { wwwMIBGroups 6 }
+
+   wwwDocumentGroup OBJECT-GROUP
+       OBJECTS {
+           wwwDocCtrlLastNSize,
+           wwwDocCtrlLastNLock,
+           wwwDocCtrlBuckets,
+           wwwDocCtrlBucketTimeInterval,
+           wwwDocCtrlTopNSize,
+           wwwDocLastNName,
+           wwwDocLastNTimeStamp,
+           wwwDocLastNRequestType,
+           wwwDocLastNResponseType,
+           wwwDocLastNStatusMsg,
+           wwwDocLastNBytes,
+           wwwDocBucketTimeStamp,
+           wwwDocBucketAccesses,
+           wwwDocBucketDocuments,
+           wwwDocBucketBytes,
+           wwwDocAccessTopNName,
+           wwwDocAccessTopNAccesses,
+           wwwDocAccessTopNBytes,
+           wwwDocAccessTopNLastResponseType,
+           wwwDocBytesTopNName,
+           wwwDocBytesTopNAccesses,
+           wwwDocBytesTopNBytes,
+           wwwDocBytesTopNLastResponseType
+       }
+       STATUS  current
+       DESCRIPTION
+           "A collection of objects providing information about
+            accesses to documents."
+       ::= { wwwMIBGroups 7 }
+
+   END
+
diff -ru -ruN apache_1.3.34_orig/src/Configuration.tmpl apache_1.3.34/src/Configuration.tmpl
--- apache_1.3.34_orig/src/Configuration.tmpl	2006-05-18 16:49:19.275766840 +0200
+++ apache_1.3.34/src/Configuration.tmpl	2006-05-18 16:49:19.306762128 +0200
@@ -460,3 +460,8 @@
 
 AddModule modules/standard/mod_setenvif.o
 
+## The SNMP Agent with which SNMP access is given to the internal statistics
+## of the HTTP Server.
+
+# AddModule modules/snmp_agt/libsnmp_agt.a
+
diff -ru -ruN apache_1.3.34_orig/src/main/http_main.c apache_1.3.34/src/main/http_main.c
--- apache_1.3.34_orig/src/main/http_main.c	2006-05-18 16:49:19.225774440 +0200
+++ apache_1.3.34/src/main/http_main.c	2006-05-18 16:49:19.329758632 +0200
@@ -84,6 +84,10 @@
 #include <sys/prctl.h>
 #endif
 
+#ifdef SNMP
+#include "../modules/snmp_agt/mod_snmp.h"
+#endif
+
 #ifdef MULTITHREAD
 /* special debug stuff -- PCS */
 
@@ -2579,7 +2583,7 @@
     ++ss->cur_vtime;
 #endif
 
-    if (ap_extended_status) {
+    if (SNMP_SCOREBOARD(ap_extended_status)) {
 #ifndef OPTIMIZE_TIMEOUTS
 	ss->last_used = time(NULL);
 #endif
@@ -3276,6 +3280,9 @@
 	 */
 	return;
     }
+#ifdef SNMP
+    cleanup_snmp_module();
+#endif
     shutdown_pending = 1;
 #else
     signal_parent(0);	    /* get the parent process to wake up */
@@ -3290,6 +3297,9 @@
 	/* Probably not an error - don't bother reporting it */
 	return;
     }
+#ifdef SNMP
+    cleanup_snmp_module();
+#endif
     restart_pending = 1;
     is_graceful = graceful;
 #else
@@ -4326,7 +4336,7 @@
 API_EXPORT(void) ap_child_terminate(request_rec *r)
 {
     r->connection->keepalive = 0;
-    requests_this_child = ap_max_requests_per_child = 1;
+    requests_this_child = SNMP_SCOREBOARD(ap_max_requests_per_child) = 1;
 }
 
 static void child_main(int child_num_arg)
@@ -4468,8 +4478,8 @@
 	}
 
 #ifndef WIN32
-	if ((ap_max_requests_per_child > 0
-	     && requests_this_child++ >= ap_max_requests_per_child)) {
+	if ((SNMP_SCOREBOARD(ap_max_requests_per_child) > 0
+	     && requests_this_child++ >= SNMP_SCOREBOARD(ap_max_requests_per_child))) {
 	    clean_child_exit(0);
 	}
 #else
@@ -4786,7 +4796,7 @@
 	    if (r->status == HTTP_OK)
 		ap_process_request(r);
 
-	    if(ap_extended_status)
+	    if (SNMP_SCOREBOARD(ap_extended_status))
 		increment_counts(my_child_num, r);
 
 #ifdef TPF_HAVE_NSD
@@ -4977,7 +4987,7 @@
     int i;
     time_t now = time(NULL);
 
-    for (i = 0; number_to_start && i < ap_daemons_limit; ++i) {
+    for (i = 0; number_to_start && i < SNMP_SCOREBOARD(ap_daemons_limit); ++i) {
 	if (ap_scoreboard_image->servers[i].status != SERVER_DEAD) {
 	    continue;
 	}
@@ -5039,7 +5049,7 @@
     total_non_dead = 0;
 
     ap_sync_scoreboard_image();
-    for (i = 0; i < ap_daemons_limit; ++i) {
+    for (i = 0; i < SNMP_SCOREBOARD(ap_daemons_limit); ++i) {
 	int status;
 
 	if (i >= max_daemons_limit && free_length == idle_spawn_rate)
@@ -5094,7 +5104,7 @@
 	}
     }
     max_daemons_limit = last_non_dead + 1;
-    if (idle_count > ap_daemons_max_free) {
+    if (idle_count > SNMP_SCOREBOARD(ap_daemons_max_free)) {
 	/* kill off one child... we use SIGUSR1 because that'll cause it to
 	 * shut down gracefully, in case it happened to pick up a request
 	 * while we were counting. Use the define SIG_IDLE_KILL to reflect
@@ -5106,7 +5116,7 @@
         ap_update_child_status(to_kill, SERVER_DEAD, (request_rec *)NULL);
 #endif
     }
-    else if (idle_count < ap_daemons_min_free) {
+    else if (idle_count < SNMP_SCOREBOARD(ap_daemons_min_free)) {
 	/* terminate the free list */
 	if (free_length == 0) {
 	    /* only report this condition once */
@@ -5296,9 +5306,8 @@
 #endif
 
 	set_signals();
-
-	if (ap_daemons_max_free < ap_daemons_min_free + 1)	/* Don't thrash... */
-	    ap_daemons_max_free = ap_daemons_min_free + 1;
+	if (SNMP_SCOREBOARD(ap_daemons_max_free) < SNMP_SCOREBOARD(ap_daemons_min_free) + 1)	/* Don't thrash... */
+	    SNMP_SCOREBOARD(ap_daemons_max_free) = SNMP_SCOREBOARD(ap_daemons_min_free) + 1;
 
 	/* If we're doing a graceful_restart then we're going to see a lot
 	 * of children exiting immediately when we get into the main loop
@@ -5309,8 +5318,8 @@
 	 * supposed to start up without the 1 second penalty between each fork.
 	 */
 	remaining_children_to_start = ap_daemons_to_start;
-	if (remaining_children_to_start > ap_daemons_limit) {
-	    remaining_children_to_start = ap_daemons_limit;
+	if (remaining_children_to_start > SNMP_SCOREBOARD(ap_daemons_limit)) {
+	    remaining_children_to_start = SNMP_SCOREBOARD(ap_daemons_limit);
 	}
 	if (!is_graceful) {
 	    startup_children(remaining_children_to_start);
@@ -5322,6 +5331,11 @@
 	    hold_off_on_exponential_spawning = 10;
 	}
 
+	#ifdef SNMP
+	    /* starting the SNMP ENTITY */
+	    snmp_agt_main(server_conf, pconf, ptrans);
+	#endif /* SNMP */
+
 	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, server_conf,
 		    "%s configured -- resuming normal operations",
 		    ap_get_server_version());
@@ -5360,7 +5374,7 @@
 		    (void) ap_update_child_status(child_slot, SERVER_DEAD,
 					       (request_rec *) NULL);
 		    if (remaining_children_to_start
-			&& child_slot < ap_daemons_limit) {
+			&& child_slot < SNMP_SCOREBOARD(ap_daemons_limit)) {
 			/* we're still doing a 1-for-1 replacement of dead
 			 * children with new children
 			 */
@@ -5465,7 +5479,7 @@
 	     * corruption too easily.
 	     */
 	    ap_sync_scoreboard_image();
-	    for (i = 0; i < ap_daemons_limit; ++i) {
+	    for (i = 0; i < SNMP_SCOREBOARD(ap_daemons_limit); ++i) {
 		if (ap_scoreboard_image->servers[i].status != SERVER_DEAD) {
 		    ap_scoreboard_image->servers[i].status = SERVER_GRACEFUL;
 		}
@@ -6136,7 +6150,7 @@
 	    if (r->status == HTTP_OK)
 		ap_process_request(r);
 
-	    if (ap_extended_status)
+	    if (SNMP_SCOREBOARD(ap_extended_status))
 		increment_counts(child_num, r);
 	    if (!current_conn->keepalive || current_conn->aborted)
 		break;
@@ -6573,7 +6587,7 @@
     sd = -1;
     nthreads = ap_threads_per_child;
     max_jobs_after_exit_request = ap_excess_requests_per_child;
-    max_jobs_per_exe = ap_max_requests_per_child;
+    max_jobs_per_exe = SNMP_SCOREBOARD(ap_max_requests_per_child);
     if (nthreads <= 0)
 	nthreads = 40;
     if (max_jobs_per_exe <= 0)
diff -ru -ruN apache_1.3.34_orig/src/main/http_protocol.c apache_1.3.34/src/main/http_protocol.c
--- apache_1.3.34_orig/src/main/http_protocol.c	2006-05-18 16:49:19.218775504 +0200
+++ apache_1.3.34/src/main/http_protocol.c	2006-05-18 16:49:19.333758024 +0200
@@ -1166,6 +1166,8 @@
 
     r->sent_bodyct     = 0;                      /* bytect isn't for body */
 
+    r->bytes_recv      = 0;
+
     r->read_length     = 0;
     r->read_body       = REQUEST_NO_BODY;
 
@@ -2422,7 +2424,7 @@
         }
         ap_hard_timeout("reading request body", r);
         while ((rv = ap_get_client_block(r, dumpbuf, HUGE_STRING_LEN)) > 0)
-            continue;
+            r->bytes_recv += rv;
         ap_kill_timeout(r);
 
         if (rv < 0)
diff -ru -ruN apache_1.3.34_orig/src/main/http_request.c apache_1.3.34/src/main/http_request.c
--- apache_1.3.34_orig/src/main/http_request.c	2006-05-18 16:49:19.222774896 +0200
+++ apache_1.3.34/src/main/http_request.c	2006-05-18 16:49:19.336757568 +0200
@@ -29,7 +29,9 @@
 #include "http_request.h"
 #include "http_core.h"
 #include "http_protocol.h"
+#ifndef SNMP
 #include "http_conf_globals.h"	/* for ap_extended_status */
+#endif
 #include "http_log.h"
 #include "http_main.h"
 #include "scoreboard.h"
@@ -1308,7 +1310,7 @@
 {
     int old_stat;
 
-    if (ap_extended_status)
+    if (SNMP_SCOREBOARD(ap_extended_status))
 	ap_time_process_request(r->connection->child_num, START_PREQUEST);
 
     process_request_internal(r);
@@ -1327,7 +1329,7 @@
     ap_log_transaction(r);
 
     (void) ap_update_child_status(r->connection->child_num, old_stat, r);
-    if (ap_extended_status)
+    if (SNMP_SCOREBOARD(ap_extended_status))
 	ap_time_process_request(r->connection->child_num, STOP_PREQUEST);
 }
 
diff -ru -ruN apache_1.3.34_orig/src/modules/snmp_agt/Makefile.libdir apache_1.3.34/src/modules/snmp_agt/Makefile.libdir
--- apache_1.3.34_orig/src/modules/snmp_agt/Makefile.libdir	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/src/modules/snmp_agt/Makefile.libdir	2006-05-18 16:49:19.296763648 +0200
@@ -0,0 +1,4 @@
+This is a place-holder which indicates to Configure that it shouldn't
+provide the default targets when building the Makefile in this directory.
+Instead it'll just prepend all the important variable definitions, and
+copy the Makefile.tmpl onto the end.
diff -ru -ruN apache_1.3.34_orig/src/modules/snmp_agt/Makefile.tmpl apache_1.3.34/src/modules/snmp_agt/Makefile.tmpl
--- apache_1.3.34_orig/src/modules/snmp_agt/Makefile.tmpl	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/src/modules/snmp_agt/Makefile.tmpl	2006-05-18 16:49:19.295763800 +0200
@@ -0,0 +1,84 @@
+MOD_SRCS=mod_snmp.c buckets.c
+MIB_SRCS=snmpv2-mib.c \
+	snmpv2-tc.c \
+	scoreboard-mib.c  \
+	config-mib.c \
+	www-mib.c
+SNMPSRCS=src_snmp/asn1.c \
+        src_snmp/snmp_community.c \
+        src_snmp/agt_mib.c \
+        src_snmp/agt_engine.c
+MOD_OBJS=$(MOD_SRCS:.c=.o)
+MIB_OBJS=$(MIB_SRCS:.c=.o)
+SNMPOBJS=$(SNMPSRCS:.c=.o)
+
+all:    libsnmp_agt.a
+
+libsnmp_agt.a: status_codes.h $(SNMPOBJS) $(MIB_OBJS) $(MOD_OBJS)
+	rm -f $@
+	ar crv $@ $(SNMPOBJS) $(MIB_OBJS) $(MOD_OBJS)
+	$(RANLIB) $@
+
+.SUFFIXES: .o .so
+
+.c.o:
+	$(CC) -c -o $@ -Wall -DHAVE_CONFIG_H $(INCLUDES) -Isrc_snmp `./group_select` $(CFLAGS) $(SPACER) $<
+
+distclean: clean
+	rm Makefile
+
+clean:
+	rm -f *.o src_snmp/*.o status_codes.h libsnmp_agt.a
+
+# We really don't expect end users to use this rule.  It works only with
+# gcc, and rebuilds Makefile.tmpl.  You have to re-run Configure after
+# using it.
+depend:
+	cp Makefile.tmpl Makefile.tmpl.bak \
+		&& sed -ne '1,/^# DO NOT REMOVE/p' Makefile.tmpl > Makefile.new \
+		&& gcc -MM $(INCLUDES) -Isrc_snmp $(CFLAGS) *.c >> Makefile.new \
+		&& sed -e '1,$$s: $(INCDIR)/: $$(INCDIR)/:g' \
+			-e '1,$$s: $(OSDIR)/: $$(OSDIR)/:g' \
+			-e '1,$$s: src_snmp/: src_snmp/:g' Makefile.new \
+			> Makefile.tmpl \
+		&& rm Makefile.new
+
+# Internal stuff, should not need changing.
+
+status_codes.h: $(INCDIR)/httpd.h remake_status
+	./remake_status
+
+
+$(SNMPOBJS) $(MIB_OBJS) $(MOD_OBJS): Makefile group_select
+
+# DO NOT REMOVE
+scoreboard-mib.o: scoreboard-mib.c src_snmp/asn1.h src_snmp/agt_mib.h \
+ scoreboard-mib.h
+config-mib.o: config-mib.c config-mib.h
+mod_snmp.o: mod_snmp.c $(INCDIR)/httpd.h $(INCDIR)/ap_config.h \
+ $(INCDIR)/ap_mmn.h $(INCDIR)/ap_config_auto.h \
+ $(OSDIR)/os.h $(INCDIR)/ap_ctype.h $(INCDIR)/ap_alloc.h \
+ $(INCDIR)/buff.h $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
+ $(INCDIR)/http_config.h $(INCDIR)/http_core.h \
+ $(INCDIR)/http_log.h $(INCDIR)/http_protocol.h \
+ $(INCDIR)/scoreboard.h src_snmp/asn1.h src_snmp/snmp.h \
+ src_snmp/agt_mib.h src_snmp/agt_engine.h \
+ src_snmp/snmp_community.h snmpv2-mib.h snmpv2-conf.h snmpv2-tc.h \
+ snmpv2-smi.h mod_snmp.h status_codes.h
+bcukets.o: buckets.c mod_snmp.h
+snmpv2-mib.o: snmpv2-mib.c $(INCDIR)/httpd.h \
+ $(INCDIR)/ap_config.h $(INCDIR)/ap_mmn.h \
+ $(INCDIR)/ap_config_auto.h $(OSDIR)/os.h \
+ $(INCDIR)/ap_ctype.h $(INCDIR)/ap_alloc.h $(INCDIR)/buff.h \
+ $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
+ $(INCDIR)/http_config.h mod_snmp.h src_snmp/asn1.h \
+ src_snmp/agt_mib.h snmpv2-mib.h snmpv2-conf.h snmpv2-tc.h \
+ snmpv2-smi.h
+snmpv2-tc.o: snmpv2-tc.c snmpv2-tc.h snmpv2-smi.h
+www-mib.o: www-mib.c $(INCDIR)/httpd.h $(INCDIR)/ap_config.h \
+ $(INCDIR)/ap_mmn.h $(INCDIR)/ap_config_auto.h \
+ $(OSDIR)/os.h $(INCDIR)/ap_ctype.h $(INCDIR)/ap_alloc.h \
+ $(INCDIR)/buff.h $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
+ $(INCDIR)/scoreboard.h $(INCDIR)/http_config.h \
+ src_snmp/asn1.h src_snmp/agt_mib.h www-mib.h snmpv2-conf.h \
+ snmpv2-tc.h snmpv2-smi.h snmpv2-mib.h mod_snmp.h
diff -ru -ruN apache_1.3.34_orig/src/modules/snmp_agt/buckets.c apache_1.3.34/src/modules/snmp_agt/buckets.c
--- apache_1.3.34_orig/src/modules/snmp_agt/buckets.c	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/src/modules/snmp_agt/buckets.c	2006-05-18 16:49:19.295763800 +0200
@@ -0,0 +1,252 @@
+/* ====================================================================
+ * Copyright (c) 1999-2000 Harrie Hazewinkel.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by Harrie Hazewinkel."
+ *
+ * 4. The name of the Copyright holder must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission.
+ *
+ * 5. Products derived from this software may not be called "MOD-SNMP"
+ *    nor may "MOD-SNMP" appear in their names  without prior written
+ *    permission of the Harrie Hazewinkel.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the Harrie Hazewinkel"
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * The creator of this module is harrie@lisanza.net
+ * This file contains generated code of SMASH also created by Harrie.
+ *
+ */
+
+#include <stdio.h>
+
+#include "httpd.h"
+#include "http_config.h"
+#include "http_core.h"
+#include "http_log.h"
+
+#include "mod_snmp.h"
+
+int		ap_bucket_errno;
+#if defined USE_DB || USE_DB2
+WwwDocTopN	record_data;
+#endif
+
+/*
+ * FUNCTION
+ * BD_BUCKET ap_bucket_open:
+ *      Function that opens a bucket in order to implement
+ *      the wwwDcoumentsGroup.
+ *      Returns the bucket when succesfull otherwise NULL.
+ * INPUT
+ * char *name:
+ *      A human-readable string to identify the bucket.
+ */ 
+BUCKET_DB
+ap_bucket_open(char *name)
+{
+BUCKET_DB	bucket;
+
+#ifdef USE_DB
+    unlink(name);
+    bucket = dbopen(name, (O_CREAT | O_RDWR), 0664, DB_HASH, NULL);
+    ap_bucket_errno = errno;
+#elif USE_DB2
+    int	result;
+
+    result = db_open(name, DB_HASH, (O_CREAT | O_RDWR), 0664, NULL, NULL, bucket);
+    ap_bucket_errno = errno;
+    if (result) {
+	return(NULL);
+    }
+#elif USE_DBM
+#elif USE_NDBM
+#endif
+    return(bucket);
+}
+
+
+/*
+ * FUNCTION
+ * void ap_bucket_close:
+ *      Function that close a bucket used to implement
+ *      the wwwDcoumentsGroup.
+ * INPUT
+ * BUCKET_DB bucket:
+ *      The bucket to be closed.
+ */
+void
+ap_bucket_close(BUCKET_DB bucket)
+{
+    if (!bucket) return;
+#ifdef USE_DB
+    (bucket->close)(bucket);
+#elif USE_DB2
+    (bucket->close)(bucket, 0);
+#elif USE_DBM
+#elif USE_NDBM
+#endif
+}
+
+/*
+ * FUNCTION
+ * WwwDocTopN *ap_bucket_fetch:
+ *      Function that fetches the record associated with the key
+ *      from the bucket.
+ *      Returns when succesfull the record otherwise NULL.
+ * INPUT
+ * BUCKET_DB bucket:
+ *      The bucket from which the record will be fetched.
+ * char *keystr:
+ *      The key of the record that needs to be fetched.
+ */
+WwwDocTopN *
+ap_bucket_fetch(BUCKET_DB bucket, char *keystr)  
+{
+#ifdef USE_DB
+    DBT	key;
+    DBT	data;
+
+    if (bucket) {
+	key.data = keystr;
+	key.size = strlen(keystr);
+	if (!((bucket->get)(bucket, &key, &data, 0))) {
+	    if (data.size == sizeof(record_data)) {
+		memcpy(&record_data, data.data, sizeof(WwwDocTopN));
+		return(&record_data);
+	    }
+	}
+	ap_bucket_errno = errno;
+    }
+#elif USE_DB2
+    DBT			key;
+    DBT			data;
+
+    if (bucket) {
+	key.data = keystr;
+	key.size = strlen(keystr);
+	data.data = record;
+	data.size = sizeof(record);
+	if (!((bucket->get)(bucket, &key, &data, 0))) {
+	    return record;
+	}
+	ap_bucket_errno = errno;
+    }
+#elif USE_DBM
+#elif USE_NDBM
+#endif
+    return(NULL);
+}
+
+/*
+ * FUNCTION
+ * WwwDocTopN *ap_bucket_store:
+ *      Function that stores a record associated with the key
+ *      from the bucket.
+ *      Returns when succesfull the record otherwise NULL.
+ * INPUT
+ * BUCKET_DB bucket:
+ *      The bucket from which the record will be fetched.
+ * char *keystr:
+ *      The key of the record that needs to be fetched.
+ */
+int
+ap_bucket_store(BUCKET_DB bucket, char *keystr, WwwDocTopN *record,
+	int action)
+{
+int result = 0;
+#ifdef USE_DB
+    DBT	key;
+    DBT	data;
+
+    if (bucket) {
+	key.data = keystr;
+	key.size = strlen(keystr);
+	data.data = record;
+	data.size = sizeof(WwwDocTopN);
+	result = (bucket->put)(bucket, &key, &data, action);
+	ap_bucket_errno = errno;
+    }
+#elif USE_DB2
+    DBT	key;
+    DBT	record;
+
+    if (bucket) {
+	key.data = keystr;
+	key.size = strlen(keystr);
+	record.data = record;
+	record.size = sizeof(WwwDocTopN);
+	result = (bucket->put)(bucket, &key, &data, action);
+	ap_bucket_errno = errno;
+    }
+#elif USE_DBM
+#elif USE_NDBM
+#endif
+    return(result);
+}
+
+WwwDocTopN *
+ap_bucket_seqfetch(BUCKET_DB bucket, int action)
+{
+#ifdef USE_DB
+DBT	key;
+DBT	record;
+
+    if (bucket) {
+	if ((bucket->seq)(bucket, &key, &record, action) == 0) {
+	    if (record.size == sizeof(record_data)) {
+		memcpy(&record_data, record.data, record.size);
+		return(&record_data);
+	    }
+	}
+    }
+#elif USE_DB2
+#elif USE_DBM
+#elif USE_NDBM
+#endif
+    return(NULL);
+}
+
+
+const char *
+ap_bucket_strerror()
+{
+#ifdef USE_DB
+     return(strerror(ap_bucket_errno));
+#elif USE_DB2
+     return("");
+#elif USE_DBM
+#elif USE_NDBM
+#endif
+}
+
diff -ru -ruN apache_1.3.34_orig/src/modules/snmp_agt/config-mib.c apache_1.3.34/src/modules/snmp_agt/config-mib.c
--- apache_1.3.34_orig/src/modules/snmp_agt/config-mib.c	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/src/modules/snmp_agt/config-mib.c	2006-05-18 16:49:19.299763192 +0200
@@ -0,0 +1,563 @@
+/* ====================================================================
+ * Copyright (c) 1999-2000 Harrie Hazewinkel.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by Harrie Hazewinkel."
+ *
+ * 4. The name of the Copyright holder must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission.
+ *
+ * 5. Products derived from this software may not be called "MOD-SNMP"
+ *    nor may "MOD-SNMP" appear in their names  without prior written
+ *    permission of the Harrie Hazewinkel.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the Harrie Hazewinkel"
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * The creator of this module is harrie@mod-snmp.com
+ * This file contains generated code of SMASH also created by Harrie.
+ *
+ */
+
+/* General includes */
+#include <stdio.h>
+
+/* Apache includes */
+#include <httpd.h>
+#include <http_conf_globals.h>
+#include <scoreboard.h>
+
+/* SNMP includes */
+#include "asn1.h"
+#include "snmp.h"
+#include "agt_mib.h"
+#include "agt_engine.h"
+#include "snmpv2-mib.h"
+#include "config-mib.h"
+
+
+void
+init_APACHE_CONFIG_MIB()
+{
+#ifdef APACHE_CONFIG_GROUP
+    ap_sync_scoreboard_image();
+    ap_scoreboard_image->global.keep_alive = 0;
+    ap_scoreboard_image->global.keep_alive_requests = 0;
+    ap_scoreboard_image->global.keep_alive_timeout = 0;
+    ap_scoreboard_image->global.hostname_lookup = 0;
+    ap_scoreboard_image->global.log_level = 0;
+
+    ap_scoreboard_image->global.ap_extended_status = ap_extended_status;
+    ap_scoreboard_image->global.ap_max_requests_per_child = ap_max_requests_per_child;
+    ap_scoreboard_image->global.ap_daemons_limit = ap_daemons_limit;
+    ap_scoreboard_image->global.ap_daemons_min_free = ap_daemons_min_free;
+    ap_scoreboard_image->global.ap_daemons_max_free = ap_daemons_max_free;
+    register_subtrees_of_APACHE_CONFIG_MIB();
+    /* insert the Object Resource in sysORTable */
+    { static struct sysOREntry_struct value = { NULL, 1, {8, {O_apacheConfigMIB}}, "The Apache Config MIB module", 0};
+      insert_sysOREntry(&value);
+    } 
+#endif
+}
+
+#ifdef APACHE_CONFIG_GROUP
+/*
+The configExtendedStatus provides a mean to switch 
+the extended status logging in the scoreboard.
+
+This variable could be used to reduce the load
+when it is turned off.
+*/
+int	write_configExtendedStatus(int action,
+	unsigned char *var_val, unsigned char var_val_type, int var_val_len,
+	unsigned char *statP, oid *name, int name_len)
+{
+int	size;
+
+    switch (action) {
+    case CHECK:
+	if (var_val_type != SNMP_INTEGER) {
+	    return SNMP_ERROR_WRONGTYPE;
+	}
+	size = 4;
+	asn_parse_int(var_val, &size, &var_val_type,
+			(long *)&ap_extended_status,
+			sizeof (ap_extended_status));
+	break;
+    case COMMIT:
+	if (ap_extended_status != 1 && ap_extended_status != 2) {
+	    return SNMP_ERROR_WRONGVALUE;
+	}
+	ap_scoreboard_image->global.ap_extended_status = ap_extended_status - 1;
+	break;
+    case FREE:
+	break;
+    default:
+	break;
+    }
+    return(SNMP_ERROR_NOERROR);
+}
+
+unsigned char *
+var_configExtendedStatus(int *var_len, snmp_info_t *mesg,
+        int (**write_method)(int, unsigned char *, unsigned char, int,
+		unsigned char *, oid *, int))
+{
+    ap_sync_scoreboard_image();
+    *write_method = write_configExtendedStatus;
+    long_return = ap_scoreboard_image->global.ap_extended_status + 1;
+    *var_len = sizeof(long_return);
+    return (unsigned char *) &(long_return);
+}
+
+/* The configKeepAliveSwitch enables/disables the
+ * persistent connections.
+ */
+int	write_configKeepAliveSwitch(int action,
+	unsigned char *var_val, unsigned char var_val_type, int var_val_len,
+	unsigned char *statP, oid *name, int name_len)
+{
+    switch (action) {
+    case CHECK:
+	break;
+    case COMMIT:
+	break;
+    case FREE:
+	break;
+    }
+    return(SNMP_ERROR_NOERROR);
+}
+
+unsigned char *
+var_configKeepAliveSwitch(int *var_len, snmp_info_t *mesg,
+        int (**write_method)(int, unsigned char *, unsigned char, int,
+		unsigned char *, oid *, int))
+{
+    ap_sync_scoreboard_image();
+    *write_method = write_configKeepAliveSwitch;
+    long_return = ap_scoreboard_image->global.keep_alive + 1;
+    *var_len = sizeof(long);
+    return (unsigned char *) &(long_return);
+}
+
+/* The maximum number of requests the apache server will
+ * serve via 1 persistent connection.
+ * If 'configKeepAlive is disabled only 1 request
+ * per connection will be served.
+ * 
+ * Server performance can be gained if this value is 
+ * kept high.
+ */
+int	write_configKeepAliveRequests(int action,
+	unsigned char *var_val, unsigned char var_val_type, int var_val_len,
+	unsigned char *statP, oid *name, int name_len)
+{
+    switch (action) {
+    case CHECK:
+	break;
+    case COMMIT:
+	break;
+    case FREE:
+	break;
+    }
+    return(SNMP_ERROR_NOERROR);
+}
+
+unsigned char *
+var_configKeepAliveRequests(int *var_len, snmp_info_t *mesg,
+        int (**write_method)(int, unsigned char *, unsigned char, int,
+		unsigned char *, oid *, int))
+{
+    ap_sync_scoreboard_image();
+    /* *write_method = write_configKeepAliveRequests; */
+    long_return = ap_scoreboard_image->global.keep_alive_requests;
+    *var_len = sizeof(long);
+    return (unsigned char *) &(long_return);
+}
+
+/* The number of seconds the Apache server will wait
+ * for a subsequent request before closing the connection.
+ * 
+ * If 'configKeepAlive' is disabled the connection will
+ * be terminated directly after serving the 
+ * first request.
+ */
+int	write_configKeepAliveTimeout(int action,
+	unsigned char *var_val, unsigned char var_val_type, int var_val_len,
+	unsigned char *statP, oid *name, int name_len)
+{
+    switch (action) {
+    case CHECK:
+	break;
+    case COMMIT:
+	break;
+    case FREE:
+	break;
+    }
+    return(SNMP_ERROR_NOERROR);
+}
+
+unsigned char *
+var_configKeepAliveTimeout(int *var_len, snmp_info_t *mesg,
+        int (**write_method)(int, unsigned char *, unsigned char, int,
+		unsigned char *, oid *, int))
+{
+    ap_sync_scoreboard_image();
+    /* *write_method = write_configKeepAliveTimeout; */
+    long_return = ap_scoreboard_image->global.keep_alive_timeout;
+    *var_len = sizeof(long);
+    return (unsigned char *) &(long_return);
+}
+
+/* The configMaxServers sets the limit on the number of simultaneous
+ * requests that can be supported; not more than this number
+ * of child server processes will be created.
+ * The maximum number is limited by the implementation, 
+ * the value 'HARD_SERVER_LIMIT'
+ * 
+ * Any connection attempts over the limit will
+ * normally be queued, up to a number based on the
+ * ListenBacklog directive.
+ */
+int	write_configMaxServers(int action,
+	unsigned char *var_val, unsigned char var_val_type, int var_val_len,
+	unsigned char *statP, oid *name, int name_len)
+{
+int	size;
+
+    switch (action) {
+    case CHECK:
+	if (var_val_type != SNMP_INTEGER) {
+	    return SNMP_ERROR_WRONGTYPE;
+	}
+	size = 4;
+	if (NULL == asn_parse_int(var_val, &size, &var_val_type,
+			(long *)&ap_daemons_limit,
+			sizeof (ap_daemons_limit))) {
+	    return SNMP_ERROR_WRONGVALUE;
+	}
+	break;
+    case COMMIT:
+	if ((ap_daemons_limit < 1) ||
+		(ap_daemons_limit > HARD_SERVER_LIMIT)) {
+	    return SNMP_ERROR_WRONGVALUE;
+	}
+	ap_scoreboard_image->global.ap_daemons_limit = ap_daemons_limit;
+	break;
+    case FREE:
+	break;
+    default:
+	break;
+    }
+    return(SNMP_ERROR_NOERROR);
+}
+
+unsigned char *
+var_configMaxServers(int *var_len, snmp_info_t *mesg,
+        int (**write_method)(int, unsigned char *, unsigned char, int,
+		unsigned char *, oid *, int))
+{
+    ap_sync_scoreboard_image();
+    *write_method = write_configMaxServers;
+    long_return = ap_scoreboard_image->global.ap_daemons_limit;
+    *var_len = sizeof(long);
+    return (unsigned char *) &(long_return);
+}
+
+/* The configMinSpareServers sets the desired minimum number of
+ * idle child server processes. An idle process is one which is
+ * not handling a request. If there are fewer than
+ * MinSpareServers idle, then the parent process creates new
+ * children at a maximum rate of 1 per second.
+ * 
+ * Tuning of this parameter should only be necessary on
+ * very busy sites. Setting this parameter to a large number
+ * is almost always a bad idea.
+ * 
+ * This variable has no effect on Microsoft Windows. 
+ */
+int	write_configMinSpareServers(int action,
+	unsigned char *var_val, unsigned char var_val_type, int var_val_len,
+	unsigned char *statP, oid *name, int name_len)
+{
+int	size;
+
+    switch (action) {
+    case CHECK:
+	if (var_val_type != SNMP_INTEGER) {
+	    return SNMP_ERROR_WRONGTYPE;
+	}
+	size = 4;
+	if (NULL == asn_parse_int(var_val, &size, &var_val_type,
+			(long *)&ap_daemons_min_free,
+			sizeof (ap_daemons_min_free))) {
+	    return SNMP_ERROR_WRONGVALUE;
+	}
+	break;
+    case COMMIT:
+	if ((ap_daemons_min_free < 1) ||
+		(ap_daemons_min_free > ap_daemons_max_free)) {
+	    return SNMP_ERROR_WRONGVALUE;
+	}
+	ap_scoreboard_image->global.ap_daemons_min_free = ap_daemons_min_free;
+	break;
+    case FREE:
+	break;
+    }
+    return(SNMP_ERROR_NOERROR);
+}
+
+unsigned char *
+var_configMinSpareServers(int *var_len, snmp_info_t *mesg,
+        int (**write_method)(int, unsigned char *, unsigned char, int,
+		unsigned char *, oid *, int))
+{
+    ap_sync_scoreboard_image();
+    *write_method = write_configMinSpareServers;
+    long_return = ap_scoreboard_image->global.ap_daemons_min_free;
+    *var_len = sizeof(long);
+    return (unsigned char *) &(long_return);
+}
+
+/* The configMaxSpareServers sets the desired maximum number
+ * of idle child server processes. An idle process is one
+ * which is not handling a request. If there are more than
+ * MaxSpareServers idle, then the parent process will kill
+ * off the excess processes.
+ * 
+ * Tuning of this parameter should only be necessary on
+ * very busy sites. Setting this parameter to a large
+ * number is almost always a bad idea.
+ * 
+ * This variable has no effect when used with the Apache
+ * Web server on a Microsoft Windo
+ */
+int	write_configMaxSpareServers(int action,
+	unsigned char *var_val, unsigned char var_val_type, int var_val_len,
+	unsigned char *statP, oid *name, int name_len)
+{
+int	size;
+
+    switch (action) {
+    case CHECK:
+	if (var_val_type != SNMP_INTEGER) {
+	    return SNMP_ERROR_WRONGTYPE;
+	}
+	size = 4;
+	if (NULL == asn_parse_int(var_val, &size, &var_val_type,
+			(long *)&ap_daemons_max_free,
+			sizeof (ap_daemons_max_free))) {
+	    return SNMP_ERROR_WRONGVALUE;
+	}
+	break;
+    case COMMIT:
+	if ((ap_daemons_max_free < 1) ||
+		(ap_daemons_max_free < ap_daemons_min_free) ||
+		(ap_daemons_max_free > ap_daemons_limit)) {
+	    return SNMP_ERROR_WRONGVALUE;
+	}
+	ap_scoreboard_image->global.ap_daemons_max_free = ap_daemons_max_free;
+	break;
+    case FREE:
+	break;
+    }
+    return(SNMP_ERROR_NOERROR);
+}
+
+unsigned char *
+var_configMaxSpareServers(int *var_len, snmp_info_t *mesg,
+        int (**write_method)(int, unsigned char *, unsigned char, int,
+		unsigned char *, oid *, int))
+{
+    ap_sync_scoreboard_image();
+    *write_method = write_configMaxSpareServers;
+    long_return = ap_scoreboard_image->global.ap_daemons_max_free;
+    *var_len = sizeof(long);
+    return (unsigned char *) &(long_return);
+}
+
+/* The MaxRequestsPerChild directive sets the limit on
+ * the number of requests that an individual child server
+ * process will handle.
+ * After configMaxRequestsPerChild requests, the child process
+ * will die. If MaxRequestsPerChild is 0, then the process
+ * will never expire.
+ * 
+ * Setting configMaxRequestsPerChild to a non-zero limit has
+ * two beneficial effects: 
+ * 
+ * it limits the amount of memory that process can
+ * consume by (accidental) memory leakage; 
+ * by giving processes a finite lifetime, it 
+ */
+int	write_configMaxRequestsPerChild(int action,
+	unsigned char *var_val, unsigned char var_val_type, int var_val_len,
+	unsigned char *statP, oid *name, int name_len)
+{
+    switch (action) {
+    case CHECK:
+	break;
+    case COMMIT:
+	break;
+    case FREE:
+	break;
+    }
+    return(SNMP_ERROR_NOERROR);
+}
+
+unsigned char *
+var_configMaxRequestsPerChild(int *var_len, snmp_info_t *mesg,
+        int (**write_method)(int, unsigned char *, unsigned char, int,
+		unsigned char *, oid *, int))
+{
+    ap_sync_scoreboard_image();
+    /* *write_method = write_configMaxRequestsPerServer; */
+    long_return = ap_scoreboard_image->global.ap_max_requests_per_child;
+    *var_len = sizeof(long);
+    return (unsigned char *) &(long_return);
+}
+
+/* This variable enables DNS lookups so that host names can
+ * be logged (and passed to CGIs/SSIs in REMOTE_HOST).
+ * on: A forward lookup will be done to acquire the hostname.
+ * off: No forward lookup will be done.
+ * double: A double DNS lookup will be done. First the reverse 
+ * lookup will be done and on tat result a forward
+ * lookup will be done and at least one of the ip
+ * addresses in the forward lookup must match the
+ * original address. (In 'tcpwrapper' terminology
+ * this is called PARANOID.)
+ */
+int	write_configHostNameLookup(int action,
+	unsigned char *var_val, unsigned char var_val_type, int var_val_len,
+	unsigned char *statP, oid *name, int name_len)
+{
+    switch (action) {
+    case CHECK:
+	break;
+    case COMMIT:
+	break;
+    case FREE:
+	break;
+    }
+    return(SNMP_ERROR_NOERROR);
+}
+
+unsigned char *
+var_configHostNameLookup(int *var_len, snmp_info_t *mesg,
+        int (**write_method)(int, unsigned char *, unsigned char, int,
+		unsigned char *, oid *, int))
+{
+    ap_sync_scoreboard_image();
+    /* *write_method = write_configHostNameLookup; */
+    long_return = ap_scoreboard_image->global.hostname_lookup;
+    *var_len = sizeof(long);
+    return (unsigned char *) &(long_return);
+}
+
+/* LogLevel adjusts the verbosity of the messages recorded
+ * in the error logs.
+ * The following levels are available, in order of
+ * decreasing significance: 
+ * emerg: Emergencies - system is unusable. 
+ * 'Child cannot open lock file. Exiting'
+ * alert: Action must be taken immediately. 
+ * 'getpwuid: couldn't determine user name from uid'
+ * crit: Critical Conditions. 
+ * 'socket: Failed to get a socket, exiting child'
+ * error: Error conditions. 
+ * 'Premature end of script headers'
+ * warn: Warning
+ */
+int	write_configLogLevel(int action,
+	unsigned char *var_val, unsigned char var_val_type, int var_val_len,
+	unsigned char *statP, oid *name, int name_len)
+{
+    switch (action) {
+    case CHECK:
+	break;
+    case COMMIT:
+	break;
+    case FREE:
+	break;
+    }
+    return(SNMP_ERROR_NOERROR);
+}
+
+unsigned char *
+var_configLogLevel(int *var_len, snmp_info_t *mesg,
+        int (**write_method)(int, unsigned char *, unsigned char, int,
+		unsigned char *, oid *, int))
+{
+    ap_sync_scoreboard_image();
+    /* *write_method = write_configLogLevel; */
+    long_return = ap_scoreboard_image->global.log_level;
+    *var_len = sizeof(long);
+    return (unsigned char *) &(long_return);
+}
+
+
+static oid configMIBObjects_oid[] = { O_configMIBObjects };
+static Object configMIBObjects_variables[] = {
+    { SNMP_INTEGER, (RWRITE| SCALAR), var_configExtendedStatus,
+                 {2, { I_configExtendedStatus, 0 }}},
+    { SNMP_INTEGER, (RWRITE| SCALAR), var_configKeepAliveSwitch,
+                 {2, { I_configKeepAliveSwitch, 0 }}},
+    { SNMP_INTEGER, (RWRITE| SCALAR), var_configKeepAliveRequests,
+                 {2, { I_configKeepAliveRequests, 0 }}},
+    { SNMP_INTEGER, (RWRITE| SCALAR), var_configKeepAliveTimeout,
+                 {2, { I_configKeepAliveTimeout, 0 }}},
+    { SNMP_INTEGER, (RWRITE| SCALAR), var_configMaxServers,
+                 {2, { I_configMaxServers, 0 }}},
+    { SNMP_INTEGER, (RWRITE| SCALAR), var_configMinSpareServers,
+                 {2, { I_configMinSpareServers, 0 }}},
+    { SNMP_INTEGER, (RWRITE| SCALAR), var_configMaxSpareServers,
+                 {2, { I_configMaxSpareServers, 0 }}},
+    { SNMP_INTEGER, (RWRITE| SCALAR), var_configMaxRequestsPerChild,
+                 {2, { I_configMaxRequestsPerChild, 0 }}},
+    { SNMP_INTEGER, (RWRITE| SCALAR), var_configHostNameLookup,
+                 {2, { I_configHostNameLookup, 0 }}},
+    { SNMP_INTEGER, (RWRITE| SCALAR), var_configLogLevel,
+                 {2, { I_configLogLevel, 0 }}},
+    { 0, 0, NULL, {0, {0}}}
+    };
+static SubTree configMIBObjects_tree =  { NULL, configMIBObjects_variables,
+	        (sizeof(configMIBObjects_oid)/sizeof(oid)), configMIBObjects_oid};
+
+/* This is the MIB registration function. This should be called */
+/* within the init_APACHE_CONFIG_MIB-function */
+void register_subtrees_of_APACHE_CONFIG_MIB()
+{
+    insert_group_in_mib(&configMIBObjects_tree);
+}
+
+#endif
diff -ru -ruN apache_1.3.34_orig/src/modules/snmp_agt/config-mib.h apache_1.3.34/src/modules/snmp_agt/config-mib.h
--- apache_1.3.34_orig/src/modules/snmp_agt/config-mib.h	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/src/modules/snmp_agt/config-mib.h	2006-05-18 16:49:19.296763648 +0200
@@ -0,0 +1,130 @@
+/* ====================================================================
+ * Copyright (c) 1997-2000 Harrie Hazewinkel.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by Harrie Hazewinkel."
+ *
+ * 4. The name of the Copyright holder must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission.
+ *
+ * 5. Products derived from this software may not be called "MOD-SNMP"
+ *    nor may "MOD-SNMP" appear in their names  without prior written
+ *    permission of the Harrie Hazewinkel.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the Harrie Hazewinkel"
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * The creator of this module is Harrie.Hazewinkel@bigfoot.com
+ * This file contains generated code of SMASH also created by Harrie.
+ *
+ *
+ */
+
+#ifndef	_APACHE_CONFIG_MIB_
+#define	_APACHE_CONFIG_MIB_
+
+/* required include files (IMPORTS) */
+
+
+void init_APACHE_CONFIG_MIB();
+void register_subtrees_of_APACHE_CONFIG_MIB();
+
+/* defined objects in this module */
+
+/* MIB object apacheConfigMIB = universityOfTwente, 6 */
+#define	I_apacheConfigMIB	5
+#define	O_apacheConfigMIB	1, 3, 6, 1, 4, 1, 785, 6
+
+/* MIB object configMIBObjects = apacheConfigMIB, 1 */
+#define	I_configMIBObjects	1
+#define	O_configMIBObjects	1, 3, 6, 1, 4, 1, 785, 6, 1
+
+/* MIB object configExtendedStatus = configMIBObjects, 1 */
+#define	I_configExtendedStatus	1
+#define	O_configExtendedStatus	1, 3, 6, 1, 4, 1, 785, 6, 1, 1
+
+/* MIB object configKeepAliveSwitch = configMIBObjects, 2 */
+#define	I_configKeepAliveSwitch	2
+#define	O_configKeepAliveSwitch	1, 3, 6, 1, 4, 1, 785, 6, 1, 2
+
+/* MIB object configKeepAliveRequests = configMIBObjects, 3 */
+#define	I_configKeepAliveRequests	3
+#define	O_configKeepAliveRequests	1, 3, 6, 1, 4, 1, 785, 6, 1, 3
+
+/* MIB object configKeepAliveTimeout = configMIBObjects, 4 */
+#define	I_configKeepAliveTimeout	4
+#define	O_configKeepAliveTimeout	1, 3, 6, 1, 4, 1, 785, 6, 1, 4
+
+/* MIB object configMaxServers = configMIBObjects, 5 */
+#define	I_configMaxServers	5
+#define	O_configMaxServers	1, 3, 6, 1, 4, 1, 785, 6, 1, 5
+
+/* MIB object configMinSpareServers = configMIBObjects, 6 */
+#define	I_configMinSpareServers	6
+#define	O_configMinSpareServers	1, 3, 6, 1, 4, 1, 785, 6, 1, 6
+
+/* MIB object configMaxSpareServers = configMIBObjects, 7 */
+#define	I_configMaxSpareServers	7
+#define	O_configMaxSpareServers	1, 3, 6, 1, 4, 1, 785, 6, 1, 7
+
+/* MIB object configMaxRequestsPerChild = configMIBObjects, 8 */
+#define	I_configMaxRequestsPerChild	8
+#define	O_configMaxRequestsPerChild	1, 3, 6, 1, 4, 1, 785, 6, 1, 8
+
+/* MIB object configHostNameLookup = configMIBObjects, 9 */
+#define	I_configHostNameLookup	9
+#define	O_configHostNameLookup	1, 3, 6, 1, 4, 1, 785, 6, 1, 9
+
+/* MIB object configLogLevel = configMIBObjects, 10 */
+#define	I_configLogLevel	10
+#define	O_configLogLevel	1, 3, 6, 1, 4, 1, 785, 6, 1, 10
+
+/* MIB object configMIBConformance = apacheConfigMIB, 2 */
+#define	I_configMIBConformance	2
+#define	O_configMIBConformance	1, 3, 6, 1, 4, 1, 785, 6, 2
+
+/* MIB object configMIBCompliances = configMIBConformance, 1 */
+#define	I_configMIBCompliances	1
+#define	O_configMIBCompliances	1, 3, 6, 1, 4, 1, 785, 6, 2, 1
+
+/* MIB object configMIBGroups = configMIBConformance, 2 */
+#define	I_configMIBGroups	2
+#define	O_configMIBGroups	1, 3, 6, 1, 4, 1, 785, 6, 2, 2
+
+/* MIB object configConfigGroup = configMIBGroups, 1 */
+#define	I_configConfigGroup	1
+#define	O_configConfigGroup	1, 3, 6, 1, 4, 1, 785, 6, 2, 2, 1
+
+/* Put here additional MIB specific include definitions */
+void	init_config_mib();
+
+#endif	/* _APACHE_CONFIG_MIB_ */
diff -ru -ruN apache_1.3.34_orig/src/modules/snmp_agt/group_select apache_1.3.34/src/modules/snmp_agt/group_select
--- apache_1.3.34_orig/src/modules/snmp_agt/group_select	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/src/modules/snmp_agt/group_select	2006-05-18 16:49:19.299763192 +0200
@@ -0,0 +1,22 @@
+#!/bin/sh
+## USED AS COMMAND-LINE EXPANDER TO SELECT THE FUNCTIONALITY IMPLEMENTED!!
+##
+## Use this if you want no core patch. If disables the Apache specific MIB modules.
+echo '-DNO_CORE_PATCH'
+##
+## Enables the mandatory SNMPv2-MIB.
+echo '-DSNMP_GROUP'
+## Enables the request type specific wwwRequestInTable
+echo '-DWWW_REQUEST_IN_GROUP'
+## Enables the request type specific wwwRequestOutTable
+echo '-DWWW_REQUEST_OUT_GROUP'
+## Enables the respsonse type specific wwwResponseInTable
+echo '-DWWW_RESPONSE_IN_GROUP'
+## Enables the respsonse type specific wwwResponseOutTable
+echo '-DWWW_RESPONSE_OUT_GROUP'
+## Enables the documents specific tables.
+echo '-DWWW_DOCUMENTS_GROUP'
+## Enables the APACHE-SCOREBOARD-MIB
+echo '-DSCOREBOARD_GROUP'
+## Enables the APACHE-CONFIG-MIB
+echo '-DAPACHE_CONFIG_GROUP'
diff -ru -ruN apache_1.3.34_orig/src/modules/snmp_agt/mod_snmp.c apache_1.3.34/src/modules/snmp_agt/mod_snmp.c
--- apache_1.3.34_orig/src/modules/snmp_agt/mod_snmp.c	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/src/modules/snmp_agt/mod_snmp.c	2006-05-18 16:49:19.299763192 +0200
@@ -0,0 +1,708 @@
+/* ====================================================================
+ * Copyright (c) 1997-2000 Harrie Hazewinkel.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by Harrie Hazewinkel."
+ *
+ * 4. The name of the Copyright holder must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission.
+ *
+ * 5. Products derived from this software may not be called "MOD-SNMP"
+ *    nor may "MOD-SNMP" appear in their names  without prior written
+ *    permission of Harrie Hazewinkel.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by Harrie Hazewinkel"
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * The creator of this module is harrie@mod-snmp.com
+ * This file contains generated code of SMASH also created by Harrie.
+ * This code is a rewrite of the prototype implementation of the
+ * DESIRE/MUSIQ project. Special thanks to them.
+ *
+ */
+
+
+ 
+/* General includes */
+#include <sys/types.h>
+#include <limits.h>
+#include <sys/socket.h>
+#ifdef UNIXDOMAINSOCKET
+#include <sys/un.h>
+#endif
+ 
+/* Apache includes */
+#include "httpd.h"
+#include "http_config.h"
+#include "http_core.h"
+#include "http_log.h"
+#include "http_protocol.h"
+#include "scoreboard.h"
+
+/* SNMP includes */
+#include "asn1.h"
+#include "snmp.h"
+#include "agt_engine.h"
+#include "snmp_community.h"
+#include "www-mib.h"
+#include "snmpv2-mib.h"
+#include "config-mib.h"
+#include "scoreboard-mib.h"
+#include "mod_snmp.h"
+#include "status_codes.h"
+
+/* Is really define somewhere in a library */
+extern int errno;
+
+server_rec		*www_services; /* www_services records */
+ap_generation_t		snmp_generation; /* generation of this child */
+
+pid_t			snmpagent_pid;
+int			snmp_port = SNMP_PORT;
+char*			snmp_addr = "0.0.0.0";
+char			*snmp_temp_dir = SNMP_AGT_BUCKET_DEFAULT_DIR;
+int			snmp_module_debug_level = 0;
+
+int			http2snmp_socket = 1;
+#ifdef UNIXDOMAINSOCKET
+struct sockaddr_un	http2snmp_address;
+int			http2snmp_addresslength;
+char			*http2snmp_name = HTTP_2_SNMP_SOCKETNAME;
+#else
+int			http2snmp_addresslength;
+struct sockaddr_in	http2snmp_address;
+#endif
+
+/*
+ * Function:
+ *	void cleanup_snmp_module()
+ * Description:
+ *	Cleaning up function to allow restarts for the SNMP-module
+ *	at (re-)start this function kills the existing SNMP-agent
+ *	process and cleanup up the 'http-snmp-api'.
+ */
+void
+cleanup_snmp_module()
+{
+
+    /* kill existing snmp-agent (if there is any) */
+    if (snmpagent_pid) {
+	kill(snmpagent_pid, SIGKILL);
+    }
+#ifdef UNXIDOMAINSOCKET 
+    unlink(http2snmp_name);
+#endif
+}
+/*
+ * Function:
+ *	void init_snmp_module(server_rec *s, pool *p)
+ * Description:
+ *	Initialisation for 'apache-servers' to use the SNMP-module. This does
+ *	NOT intialise the complete SNMP-AGENT. The SNMP-AGENT allocates some
+ *	memory and it is not required that the rest of the http-server this
+ *	knows.
+ */
+void	init_snmp_module(server_rec *s, pool *p)
+{
+int	hostNr = 0;
+int	mainport = s->port;
+
+    /* Cleanup existing stuff for restarts */
+    cleanup_snmp_module();
+
+    snmp_generation = ap_my_generation;
+ 
+    /* now initialise */
+#ifdef UNIXDOMAINSOCKET
+    http2snmp_socket = socket(AF_UNIX, SOCK_DGRAM, 0);
+#else
+    http2snmp_socket = socket(AF_INET, SOCK_DGRAM, 0);
+#endif
+    if (http2snmp_socket < 0) {
+	ap_log_unixerr("open_channel", NULL,    
+			"Cannot open 'http-snmp-api' socket\n", s);
+    }  
+    memset((char *) &http2snmp_address, 0, sizeof(http2snmp_address));
+    #ifdef UNIXDOMAINSOCKET
+	http2snmp_address.sun_family = AF_UNIX;
+	strcpy(http2snmp_address.sun_path, http2snmp_name);
+	http2snmp_address.sun_len = sizeof(http2snmp_address.sun_family) +
+				strlen(http2snmp_address.sun_path) + 1;
+	http2snmp_addresslength = http2snmp_address.sun_len;
+    #else
+	http2snmp_address.sin_family = AF_INET;
+	http2snmp_address.sin_addr.s_addr = inet_addr("127.0.0.1");
+	http2snmp_address.sin_port = htons(0);
+	http2snmp_addresslength = sizeof(http2snmp_address);
+    #endif
+    if (bind(http2snmp_socket, (struct sockaddr *)&http2snmp_address,
+						http2snmp_addresslength) < 0){
+	ap_log_unixerr("open_channel", NULL, 
+		"Cannot bind 'http-snmp-api' socket\n", s);
+    }
+#ifndef UNIXDOMAINSOCKET
+    getsockname(http2snmp_socket, (struct sockaddr *)&http2snmp_address,
+						&http2snmp_addresslength);
+#endif
+
+    /* initialise the server record with numbers */
+    while (s) {
+	s->vhost_index = hostNr++;
+	s->port = mainport;
+	s = s->next;
+    }
+    if (hostNr >= HARD_VIRTUAL_HOST_MAX) {
+        ap_log_error_old("Number of v-hosts exceeds \"HARD_VIRTUAL_HOST_MAX\"",
+                                                www_services); 
+        exit(-1);
+    }
+
+}
+
+const char *
+snmp_communities (cmd_parms *cmd, void *dummy, char *arg)
+{
+    if ( strlen(arg) > MAX_COMMUNITY_LEN ) 
+		return "Community string too long";
+    /* A little over the top, but is more easy to 
+     * use the same of the SNMP-lib.
+     */
+    return set_community(NULL, arg);
+}
+
+int	snmp_section = 0;
+char	*start_snmp_config_magic = "<SNMP> out of place";
+char	*end_snmp_config_magic = "</SNMP> out of place";
+char	*outside_snmp_config_magic = "Not in SNMP section";
+
+const char *
+start_snmp_section (cmd_parms *cmd, void *dummy, char *argu)
+{
+    char *endp;
+    char *colon;
+
+    if (snmp_section) return "SNMP does not nest";
+    snmp_section = 1;
+    endp = strrchr(argu, '>');
+    if (endp) *endp = '\0';
+    colon = strrchr(argu, ':');
+    if (colon) {
+        *colon = '\0';
+        snmp_addr =  argu;
+        snmp_port = atoi(++colon);
+    } else {
+        snmp_port = atoi (argu);
+    }
+    return NULL;
+}
+
+const char *
+end_snmp_section(cmd_parms *cmd, void *dummy)
+{
+    if (snmp_section) {
+	snmp_section = 0;
+        return NULL;
+    }
+    return end_snmp_config_magic;
+}
+
+const char *
+snmp_buckets(cmd_parms *cmd, void *dummy, char *arg)
+{
+    if (snmp_section) {
+	snmp_temp_dir = ap_pstrdup(cmd->pool, arg);
+	return NULL;
+    }
+    return "Not specified in SNMP-section";
+}
+
+#ifdef UNIXDOMAINSOCKET
+const char *
+init_http2snmp_socketname(cmd_parms *cmd, void *dummy, char *arg)
+{
+    pool *p = cmd->pool;
+    int i = strlen(arg);
+
+    if (i > MAX_OCTSTR_LEN) {
+	i = MAX_OCTSTR_LEN;
+    }
+    http2snmp_name = (char *)ap_pcalloc (p, i+1);
+    if (http2snmp_name) {
+	strncpy(http2snmp_name, arg, i);
+    }
+    return NULL;
+}
+#endif
+
+char *bucketDir;
+
+/*
+ * Function:
+ *	int     init_wwwProtocolStatistics(server_rec *s, pool *p)
+ * Description:
+ *	Initialisation of the www protocol statistics (protocol and document).
+ *	Since it uses a lot of allocated memory only done within
+ *	SNMP-agent. All values are set to the MIB defined default!!
+ */
+int	init_wwwProtocolStatistics(server_rec *s, pool *p)
+{
+WwwStats		*wwwStats;
+
+
+    while (s) {
+	wwwStats = (WwwStats *)ap_pcalloc (p, sizeof(WwwStats));
+	if (wwwStats) {
+	    s->snmp_www_stats = wwwStats;
+
+	    wwwStats->summaryInRequests = 0;
+	    wwwStats->summaryOutRequests = 0;
+	    wwwStats->summaryInResponses = 0;
+	    wwwStats->summaryOutResponses = 0;
+	    wwwStats->summaryInLowBytes = 0;
+	    wwwStats->summaryOutLowBytes = 0;
+#ifdef WWW_DOCUMENTS_GROUP
+	    wwwStats->docCtrlLastNSize = DEFAULT_LASTNSIZE;
+	    wwwStats->docCtrlLastNLock = 0;
+	    wwwStats->docCtrlBuckets = DEFAULT_BUCKETS;
+	    wwwStats->docCtrlBucketTimeInterval = 9000; 
+	    wwwStats->docCtrlTopNSize = DEFAULT_TOPNSIZE;
+	    wwwStats->docLastNIndex = 0;
+	    wwwStats->docBucketIndex = 0;
+	    wwwStats->bucketName = ap_pstrcat(p, 
+			ap_server_root_relative(p, snmp_temp_dir),
+					"/bucket.", s->server_hostname, NULL);
+	    wwwStats->bucket = ap_bucket_open(wwwStats->bucketName);
+	    if (!wwwStats->bucket) {
+		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, s,
+			"SNMP:ap_bucket_open: %s '%s'", ap_bucket_strerror(),
+			wwwStats->bucketName);
+	    }
+#endif /* WWW_DOCUMENTS_GROUP */
+	}
+	s = s->next;
+    }
+    return(OK);
+}
+
+/*
+ * Function:
+ *	int	 http_log_lastDocument(request_rec *r)
+ * Description:
+ * This function fills the document log structure at the http-side
+ * of the 'http-to-snmp-api' and sends (datagram) it to the snmp-side.
+ */
+int
+http_log_Document(request_rec *r)
+{
+    int			i;
+    ApiMsg        document;
+
+    document.serviceIndex = r->server->vhost_index;
+    document.requestTime = r->request_time;
+    document.bytesIn = r->bytes_recv;
+    if (!r->sent_bodyct) {
+	document.bytesOut = 0;
+    } else {
+	ap_bgetopt(r->connection->client, BO_BYTECT, &document.bytesOut);
+    }
+    strncpy(document.docName, r->uri, sizeof(document.docName));
+    sprintf(document.statusMsg, "host '%d'", r->server->vhost_index);
+    document.requestInType = -1;
+    for (i=0 ; i<(METHODS-1) ; i++) {
+	if(!strcmp(r->method, requestTypes[i])) {
+		document.requestInType = i;
+		break;
+	}
+    }
+    i = 0;
+    while (responseTypes[i] > 0) {
+	if(responseTypes[i] == r->status) {
+		document.responseOutType = i;
+	    break;
+	}
+	i++;
+    }
+    if (0 >= sendto(http2snmp_socket, (char *)&document, sizeof(document), 0,
+		(struct sockaddr *)&http2snmp_address, sizeof(http2snmp_address))) {
+	perror("sendto");
+    }
+    return(OK);
+}
+
+
+int
+snmp_log_lastDocument(int socket)
+{
+ApiMsg		lastDoc;
+server_rec	*s;
+WwwStats	*wwwStats;
+#ifdef WWW_DOCUMENTS_GROUP
+int		lastNIndex;
+WwwDocTopN	documentData;
+WwwDocTopN	*ptr_documentData;
+#endif /* WWW_DOCUMENTS_GROUP */
+
+    if (read(socket, &lastDoc, sizeof(lastDoc)) != sizeof(lastDoc)) {
+	return(!OK);
+    }
+
+    /* Search for the correct ServiceIndex */
+    for (s = www_services ; s ; s = s->next) {
+	if (s->vhost_index == lastDoc.serviceIndex) {
+	    break;
+	}
+    }
+
+    if (s) {
+	wwwStats = (WwwStats *)s->snmp_www_stats;
+	if (wwwStats) {
+	    wwwStats->summaryInRequests++;
+	    wwwStats->summaryOutResponses++;
+	    wwwStats->summaryInLowBytes += lastDoc.bytesIn;
+	    wwwStats->summaryOutLowBytes += lastDoc.bytesOut;
+#ifdef WWW_REQUEST_IN_GROUP
+	    if (lastDoc.requestInType >= 0){
+		wwwStats->requestInEntries[ lastDoc.requestInType ].count++;
+		wwwStats->requestInEntries[ lastDoc.requestInType ].bytes +=
+					lastDoc.bytesIn;
+		wwwStats->requestInEntries[ lastDoc.requestInType ].lastTime =
+					lastDoc.requestTime;
+	    }
+#endif /* WWW_REQUEST_IN_GROUP */
+#ifdef WWW_RESPONSE_OUT_GROUP
+	    wwwStats->responseOutEntries[ lastDoc.responseOutType ].count++;
+	    wwwStats->responseOutEntries[ lastDoc.responseOutType ].bytes +=
+					lastDoc.bytesOut;
+	    wwwStats->responseOutEntries[ lastDoc.responseOutType ].lastTime =
+					lastDoc.requestTime;
+#endif /* WWW_RESPONSE_OUT_GROUP */
+#ifdef WWW_DOCUMENTS_GROUP
+	    if (wwwStats->docLastNTable) {
+		wwwStats->docLastNIndex++;
+		lastNIndex = wwwStats->docLastNIndex % MAX_LASTNSIZE;
+		strncpy(wwwStats->docLastNTable[ lastNIndex ].docName,
+					lastDoc.docName, MAX_DOCNAME);
+		wwwStats->docLastNTable[ lastNIndex ].requestTime =
+					lastDoc.requestTime;
+		wwwStats->docLastNTable[ lastNIndex ].requestType =
+					lastDoc.requestInType;
+		wwwStats->docLastNTable[ lastNIndex ].responseType =
+					lastDoc.responseOutType;
+		strncpy(wwwStats->docLastNTable[ lastNIndex ].statusMsg,
+					lastDoc.statusMsg, MAX_STATMSG);
+		wwwStats->docLastNTable[ lastNIndex ].docBytes =
+					lastDoc.bytesOut;
+	    }
+	    ptr_documentData = ap_bucket_fetch(wwwStats->bucket, lastDoc.docName);
+	    if (ptr_documentData) {
+		/* found in bucket; update document document data */
+
+		ptr_documentData->accesses++;
+		ptr_documentData->bytes += lastDoc.bytesOut;
+		ptr_documentData->lastResponseType = lastDoc.responseOutType;
+		ptr_documentData->lastAccess = lastDoc.requestTime;
+		if (ap_bucket_store(wwwStats->bucket, lastDoc.docName,
+					ptr_documentData, RECORD_REPLACE)) {
+		    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, www_services,
+					"ap_bucket_store '%s'", ap_bucket_strerror());
+		}
+	     } else {
+		/* not found in bucket; insert document data */
+		strcpy(documentData.name, lastDoc.docName);
+		documentData.accesses = 1;
+		documentData.bytes = lastDoc.bytesOut;
+		documentData.lastResponseType = lastDoc.responseOutType;
+		documentData.lastAccess = lastDoc.requestTime;
+		if (ap_bucket_store(wwwStats->bucket, lastDoc.docName, &documentData,
+		    					RECORD_INSERT)) {
+		    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, www_services,
+					"ap_bucket_store '%s'", ap_bucket_strerror());
+		}
+
+	    }
+#endif /* WWW_DOCUMENTS_GROUP */
+	}
+    }
+    return(OK);
+}
+
+#ifdef WWW_DOCUMENTS_GROUP
+void
+insert_in_accessTopNTable(WwwDocTopN *doc, WwwDocTopN *accessTopNTable, int size)
+{
+int	i;
+
+    size = size-2; /* We correct this for the array */
+    for ( i=0 ; i<size ; i++) {
+	if (accessTopNTable[i].accesses <= doc->accesses) {
+	    while (i <= size) {
+		memcpy(&(accessTopNTable[size+1]), &(accessTopNTable[size]),
+							sizeof(WwwDocTopN));
+		size--;
+	    }
+	    memcpy(&(accessTopNTable[i]), doc, sizeof(WwwDocTopN));
+	    for (i=0; i<25 ; i++) {
+	    }
+	    return;
+	}
+    }
+    if (accessTopNTable[i].accesses <= doc->accesses) {
+	memcpy(&(accessTopNTable[i]), doc, sizeof(WwwDocTopN));
+    }
+}
+
+void
+insert_in_bytesTopNTable(WwwDocTopN *doc, WwwDocTopN *bytesTopNTable, int size)
+{
+int     i;
+
+    size = size-2; /* We correct this for the array */
+    for ( i=0 ; i<size ; i++) {
+	if (bytesTopNTable[i].bytes <= doc->bytes) {
+	    while (i <= size) {
+		memcpy(&(bytesTopNTable[size+1]), &(bytesTopNTable[size]),
+							sizeof(WwwDocTopN));
+		size--;
+	    }
+	    memcpy(&(bytesTopNTable[i]), doc, sizeof(WwwDocTopN));
+	    for (i = 0 ; i<25 ; i++) {
+	    }
+	    return;
+	}
+    }
+    if (bytesTopNTable[i].bytes <= doc->bytes) {
+	memcpy(&(bytesTopNTable[i]), doc, sizeof(WwwDocTopN));
+    }
+}
+
+void
+set_alarm_bucketsTimeInterval(server_rec *service)
+{   
+WwwStats	*wwwStats = service->snmp_www_stats;
+    
+    if (wwwStats) {
+	if (wwwStats->docCtrlBucketTimeInterval > 0) {
+	    alarm(wwwStats->docCtrlBucketTimeInterval/100);
+	}       
+    }           
+}               
+
+void
+compute_bucket_table(WwwStats *wwwStats)
+{
+WwwDocBucket	*docBucket;
+WwwDocTopN	*documentData;
+
+    docBucket = &(wwwStats->docBucketTable[++wwwStats->docBucketIndex % 
+						MAX_BUCKETS ]);;
+    if (docBucket) {
+	docBucket->bucketCreateTime = time(NULL);
+	docBucket->accesses = 0;
+	docBucket->documents = 0;
+	docBucket->bytes = 0;
+	if (docBucket->accessTopNTable) {
+	    memset(docBucket->accessTopNTable, 0,
+		(sizeof(WwwDocTopN) * MAX_LASTNSIZE));
+	}
+	if (docBucket->bytesTopNTable) {
+	    memset(docBucket->bytesTopNTable, 0,
+		(sizeof(WwwDocTopN) * MAX_LASTNSIZE));
+	}
+	/* We now go through the complete bucket and sort the documentData */
+	documentData = ap_bucket_seqfetch(wwwStats->bucket, FIRST_RECORD);
+	while (documentData) {
+	    insert_in_accessTopNTable(documentData, docBucket->accessTopNTable,
+					wwwStats->docCtrlTopNSize);
+	    insert_in_bytesTopNTable(documentData, docBucket->bytesTopNTable,
+					wwwStats->docCtrlTopNSize);
+	    docBucket->accesses += documentData->accesses;
+	    docBucket->documents++;
+	    docBucket->bytes += documentData->bytes;
+	    documentData = ap_bucket_seqfetch(wwwStats->bucket, NEXT_RECORD);
+	}
+    }
+}
+
+/* This function walks through to compute all bucket related tables.
+ * It does them always together, but it should be possible to do this
+ * independent.
+ */
+void
+compute_buckets(int signal)
+{
+server_rec	*s = www_services;
+WwwStats	*wwwStats;
+
+    set_alarm_bucketsTimeInterval(s); 
+    while (s) {
+	wwwStats = s->snmp_www_stats;
+	if (wwwStats) {
+	    compute_bucket_table(wwwStats);
+	    ap_bucket_close(wwwStats->bucket);
+	    wwwStats->bucket = ap_bucket_open(wwwStats->bucketName);
+	    if (!wwwStats->bucket) {
+		ap_log_unixerr("ap_bucket_open", NULL, ap_bucket_strerror(), s);
+	    }
+	}
+	s = s->next;
+    }
+}
+
+void
+init_alarm_bucketsTimeInterval()
+{
+#ifndef NO_USE_SIGACTION
+struct sigaction snmp_sig;
+
+    sigemptyset(&snmp_sig.sa_mask);
+    snmp_sig.sa_flags = 0;
+    snmp_sig.sa_handler = (void (*)())compute_buckets;
+    if (sigaction (SIGALRM, &snmp_sig, NULL) < 0)
+	ap_log_unixerr ("sigaction(SIGALRM)", NULL, NULL, www_services);
+    sigaddset (&snmp_sig.sa_mask, SIGALRM);
+#else
+    signal (SIGALRM, (void (*)())compute_buckets);
+#endif
+}
+#endif /* WWW_DOCUMENTS_GROUP */
+
+void
+snmp_agt_main(server_rec *s, pool *p, pool *ptemp)
+{
+int     count;
+int     snmp_socket;
+int     numfds;
+fd_set  fdset;
+
+    snmpagent_pid = fork();
+    if (snmpagent_pid == -1) { /* Fork error */
+	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, s,
+					"SNMP: unable to fork agent");
+    } else if (snmpagent_pid > 0) { 
+	return;
+    }
+
+    /* Open the network */
+    snmp_socket = snmp_open_connection(snmp_addr, snmp_port);
+    if (snmp_socket == 0) {
+	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, s,
+						"SNMP: cannot open socket");
+	exit(0);
+    }
+    ensure_communities();
+
+    init_SNMPv2_MIB();
+    init_WWW_MIB();
+    init_APACHE_CONFIG_MIB();
+    init_APACHE_SCOREBOARD_MIB();
+    init_wwwServiceOperStatus();
+    init_wwwProtocolStatistics(s, p);
+    www_services = s;
+
+#ifdef WWW_DOCUMENTS_GROUP
+    init_alarm_bucketsTimeInterval();
+    set_alarm_bucketsTimeInterval(s);
+#endif
+
+    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, s,
+                    "SNMP: agent started and listens on port '%s:%d'", snmp_addr, snmp_port);
+
+    /* Listen to the network */
+    while(1){
+        numfds = 0;
+        FD_ZERO(&fdset);
+	FD_SET(snmp_socket, &fdset);
+        FD_SET(http2snmp_socket, &fdset);
+        if (snmp_socket > http2snmp_socket) {
+	    numfds = snmp_socket+1;
+	} else {
+	    numfds = http2snmp_socket+1;
+	}
+        count = select(numfds, &fdset, 0, 0, 0);
+        if (count > 0){
+            if (FD_ISSET(snmp_socket, &fdset)) {
+                snmp_process_message(snmp_socket);
+            } else if (FD_ISSET(http2snmp_socket, &fdset)) {
+		snmp_log_lastDocument(http2snmp_socket);
+	    }
+        } else switch(count){
+            case 0:
+                break;
+            case -1:
+                if (errno == EINTR) {
+		    continue;
+                } else {
+		    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, s,
+				"SNMP: select error '%s'\n", strerror(errno));
+                }
+            default:
+		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, s,
+                		"SNMP: select returned %d\n", count);
+        }
+    }
+}
+
+
+command_rec config_cmds_snmp_module[] = {
+{ "<SNMP", start_snmp_section, NULL, RSRC_CONF, TAKE1, "start of SNMP config section"},
+{ "</SNMP>", end_snmp_section, NULL, RSRC_CONF, NO_ARGS, "end of SNMP config section"},
+{ "SNMPcommunity", snmp_communities, NULL, RSRC_CONF, ITERATE, "error with communities"},
+{ "SNMPbuckets", snmp_buckets, NULL, RSRC_CONF, RAW_ARGS, "error for buckets directory"},
+{ "sysDescr", init_sysDescr, NULL, RSRC_CONF, RAW_ARGS, "incorrect sysDescr"},
+{ "sysContact", init_sysContact, NULL, RSRC_CONF, RAW_ARGS, "incorrect sysContact"},
+{ "sysLocation", init_sysLocation, NULL, RSRC_CONF, RAW_ARGS, "incorrect sysLocation"},
+{ NULL }
+};
+
+module MODULE_VAR_EXPORT snmp_agt_module = {
+    STANDARD_MODULE_STUFF,
+    init_snmp_module,		/* initializer */
+    NULL,			/* create per-directory config structure */
+    NULL,			/* merge per-directory config structure */
+    NULL,			/* create per-server config structure */
+    NULL,			/* merge per-server config structure */
+    config_cmds_snmp_module,	/* command table */
+    NULL,			/* handlers */
+    NULL,			/* translate handlers */
+    NULL,			/* check_user_id */
+    NULL,			/* check auth */
+    NULL,			/* check access */
+    NULL,			/* type_checker */
+    NULL,			/* pre-run fixups */
+    http_log_Document,	 	/* logger */
+    NULL,			/* header parser */
+    NULL,			/* child_init */
+    NULL,			/* child_exit */
+    NULL			/* post read-request */
+};
+
+
diff -ru -ruN apache_1.3.34_orig/src/modules/snmp_agt/mod_snmp.h apache_1.3.34/src/modules/snmp_agt/mod_snmp.h
--- apache_1.3.34_orig/src/modules/snmp_agt/mod_snmp.h	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/src/modules/snmp_agt/mod_snmp.h	2006-05-18 16:49:19.299763192 +0200
@@ -0,0 +1,244 @@
+/* ====================================================================
+ * Copyright (c) 1997-2000 Harrie Hazewinkel.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by Harrie Hazewinkel."
+ *
+ * 4. The name of the Copyright holder must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission.
+ *
+ * 5. Products derived from this software may not be called "MOD-SNMP"
+ *    nor may "MOD-SNMP" appear in their names  without prior written
+ *    permission of the Harrie Hazewinkel.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the Harrie Hazewinkel"
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * The creator of this module is harrie@mod-snmp.com
+ * This file contains generated code of SMASH also created by Harrie.
+ *
+ *
+ */
+
+#ifndef _MOD_SNMP_H_
+#define _MOD_SNMP_H_
+
+/* SNMP required definitions */
+#define SNMP_AGT_VERSION "SNMP module 1.3.6.11"
+
+#define DEFAULT_COMM "public"
+
+
+/* HTTP required definitions */
+extern int	responseTypes[];
+extern char	*full[];
+extern char	*requestTypes[];
+
+typedef struct {
+    unsigned long	count;
+    unsigned long	bytes;
+    unsigned long	lastTime;
+} WwwRequestIn;
+
+typedef struct {
+    unsigned long       count;
+    unsigned long       bytes; 
+    unsigned long       lastTime;
+} WwwRequestOut;
+
+typedef struct {
+    unsigned long       count;
+    unsigned long       bytes; 
+    unsigned long       lastTime;
+} WwwResponseIn;
+
+typedef struct {
+    unsigned long       count;
+    unsigned long       bytes; 
+    unsigned long       lastTime;
+} WwwResponseOut;
+
+#define MAX_DOCNAME     256
+#define MAX_STATMSG     16
+
+#ifndef MAX_LASTNSIZE
+#define MAX_LASTNSIZE		25
+#endif
+#define DEFAULT_LASTNSIZE	25
+
+#ifndef MAX_BUCKETS
+#define MAX_BUCKETS		5
+#endif
+#define DEFAULT_BUCKETS		2
+
+#ifndef	MAX_TOPNSIZE
+#define	MAX_TOPNSIZE		25
+#endif
+#define DEFAULT_TOPNSIZE	25
+
+typedef struct {
+    unsigned char	docName[ MAX_DOCNAME ];
+    time_t		requestTime;
+    int			requestType;
+    int			responseType;
+#ifdef WWW_DOCUMENTS_GROUP
+    unsigned char	statusMsg[ MAX_STATMSG ];
+    unsigned long	docBytes;
+#endif /* WWW_DOCUMENTS_GROUP */
+} WwwDocLastN;
+
+typedef struct {
+    unsigned char	name[ MAX_DOCNAME ];
+    unsigned long	accesses;
+    unsigned long	bytes;
+    int			lastResponseType;
+    time_t		lastAccess; /* This one is only internal used. */
+} WwwDocTopN;
+
+typedef struct {
+    time_t		bucketCreateTime;
+    unsigned long	accesses;
+    unsigned long	documents;
+    unsigned long	bytes;
+    WwwDocTopN		accessTopNTable[ MAX_TOPNSIZE ];
+    WwwDocTopN		bytesTopNTable[ MAX_TOPNSIZE ];
+} WwwDocBucket;
+
+/* Some database defintions that are required for the buckets */
+#ifdef USE_DB
+#include <db_185.h>
+#define BUCKET_DB	DB*
+#define RECORD_INSERT	0
+#define RECORD_REPLACE	0
+#define FIRST_RECORD	R_FIRST
+#define NEXT_RECORD	R_NEXT
+#elif USE_DB2
+#include <db_185.h>
+#define BUCKET_DB	DB*
+#define RECORD_INSERT	0
+#define RECORD_REPLACE	0
+#define FIRST_RECORD	R_FIRST
+#define NEXT_RECORD	R_NEXT
+#elif USE_DBM
+#include <dbm.h>
+#elif USE_NDBM
+#include <ndbm.h>
+#endif
+
+typedef struct {
+    /* www protocol summary statistics */
+    /* wwwSummaryTable */
+    unsigned long	summaryInRequests;
+    unsigned long	summaryOutRequests;
+    unsigned long	summaryInResponses;
+    unsigned long	summaryOutResponses;
+    /*    unsigned long	summaryInBytes; */
+    unsigned long	summaryInLowBytes;
+    /*    unsigned long	summaryOutBytes; */
+    unsigned long	summaryOutLowBytes;
+#ifdef WWW_REQUEST_IN_GROUP
+    WwwRequestIn	requestInEntries[ METHODS - 1 ];
+#endif
+#ifdef WWW_REQUEST_OUT_GROUP
+    WwwRequestOut	requestOutEntries[ METHODS ];
+#endif
+#ifdef WWW_RESPONSE_IN_GROUP
+    WwwResponseIn	responseInEntries[ RESPONSE_CODES ];
+#endif
+#ifdef WWW_RESPONSE_OUT_GROUP
+    WwwResponseOut	responseOutEntries[ RESPONSE_CODES ];
+#endif
+#ifdef WWW_DOCUMENTS_GROUP
+    /* wwwDocCtrlTables */
+    unsigned long      docCtrlLastNSize;
+    unsigned long      snmpset_temp_docCtrlLastNSize;
+    unsigned long      docCtrlLastNLock;
+    unsigned long      snmpset_temp_docCtrlLastNLock;
+    unsigned long      docCtrlBuckets;
+    unsigned long      snmpset_temp_docCtrlBuckets;
+    unsigned long      docCtrlBucketTimeInterval;
+    unsigned long      snmpset_temp_docCtrlBucketTimeInterval;
+    unsigned long      docCtrlTopNSize;
+    unsigned long      snmpset_temp_docCtrlTopNSize;
+    /* wwwDocLastNtable */
+    WwwDocLastN docLastNTable[ MAX_LASTNSIZE ];
+    unsigned long      docLastNIndex;
+    /* wwwDocBucketTables */
+    WwwDocBucket	docBucketTable[ MAX_BUCKETS ];
+    unsigned long	docBucketIndex;
+    /* just internal required */
+    BUCKET_DB		bucket;
+    char		*bucketName;
+#endif
+} WwwStats;
+
+/* Definitions for the HTTP-SNMP API */
+#define HTTP_2_SNMP_SOCKETNAME	"logs/http2snmp_socket"
+
+#define SNMP_AGT_BUCKET_DEFAULT_DIR "logs/"
+
+typedef struct {
+    int 		serviceIndex;
+    time_t		requestTime;
+    unsigned long	requestInType;
+    unsigned long	responseOutType;
+    unsigned long	bytesIn;
+    unsigned long	bytesOut;
+    unsigned char	docName[ MAX_DOCNAME ];
+    unsigned char	statusMsg[ MAX_STATMSG ];
+} ApiMsg;
+
+const char *init_sysDescr(cmd_parms *cmd, void *dummy, char *arg);
+const char *init_sysContact(cmd_parms *cmd, void *dummy, char *arg);
+const char *init_sysLocation(cmd_parms *cmd, void *dummy, char *arg);
+
+extern	command_rec config_cmds_snmp_module[];
+int	log_snmp_module(request_rec *r);
+/*int	http_log_lastDocument(request_rec *r);
+int	snmp_log_lastDocument(int socket);*/
+void	init_snmp_module(server_rec *s, pool *p);
+void	cleanup_snmp_module();
+void	snmp_agt_main(server_rec *s, pool *p, pool *ptemp);
+
+
+/* generic api for bucket handling. Then only buckets.c and mod_snmp.h
+ * requires things for system DB's such as DB or DBM.
+ */
+BUCKET_DB	ap_bucket_open(char *name);
+void		ap_bucket_close(BUCKET_DB bucket);
+WwwDocTopN	*ap_bucket_fetch(BUCKET_DB bucket, char *keystr);
+WwwDocTopN	*ap_bucket_seqfetch(BUCKET_DB bucket, int action);
+int		ap_bucket_store(BUCKET_DB bucket, char *keystr,
+			WwwDocTopN *record, int action);
+const char	*ap_bucket_strerror();
+
+#endif	/* _MOD_SNMP_H_ */
diff -ru -ruN apache_1.3.34_orig/src/modules/snmp_agt/mod_snmp.patch apache_1.3.34/src/modules/snmp_agt/mod_snmp.patch
--- apache_1.3.34_orig/src/modules/snmp_agt/mod_snmp.patch	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/src/modules/snmp_agt/mod_snmp.patch	2006-05-18 16:49:19.296763648 +0200
@@ -0,0 +1,554 @@
+diff -rC 3 ../apache_1.3.12/src/Configuration.tmpl src/Configuration.tmpl
+*** ../apache_1.3.12/src/Configuration.tmpl	Sat Aug 14 10:35:43 1999
+--- src/Configuration.tmpl	Mon Apr 17 05:54:45 2000
+***************
+*** 436,438 ****
+--- 436,443 ----
+  
+  AddModule modules/standard/mod_setenvif.o
+  
++ ## The SNMP Agent with which SNMP access is given to the internal statistics
++ ## of the HTTP Server.
++ 
++ # AddModule modules/snmp_agt/libsnmp_agt.a
++ 
+diff -rC 3 ../apache_1.3.12/src/include/httpd.h src/include/httpd.h
+*** ../apache_1.3.12/src/include/httpd.h	Thu Feb 24 00:01:33 2000
+--- src/include/httpd.h	Mon Apr 17 07:47:25 2000
+***************
+*** 226,231 ****
+--- 226,241 ----
+  #define ACCESS_CONFIG_FILE "conf/access.conf"
+  #endif
+  
++ #ifdef SNMP
++ /* Max to the # of virtual hosts, only needed by the SNMP module
++  * (currently) as it claims a static block in the score board.
++  */
++ #ifndef HARD_VIRTUAL_HOST_MAX
++ #define HARD_VIRTUAL_HOST_MAX 30
++ #endif
++ #endif /* SNMP */
++ 
++ 
+  /* Whether we should enable rfc1413 identity checking */
+  #ifndef DEFAULT_RFC1413
+  #define DEFAULT_RFC1413 0
+***************
+*** 736,741 ****
+--- 746,752 ----
+  
+      int sent_bodyct;		/* byte count in stream is for body */
+      long bytes_sent;		/* body byte count, for easy access */
++     long bytes_recv;		/* body byte count, for easy access */
+      time_t mtime;		/* Time the resource was last modified */
+  
+      /* HTTP/1.1 connection-level features */
+***************
+*** 888,893 ****
+--- 899,909 ----
+  
+      server_rec *next;
+  
++ #ifdef SNMP
++     int vhost_index;		/* fast search/index shortcut		*/  
++     void *snmp_www_stats;	/* snmp data for this virtual host	*/
++ #endif
++ 
+      /* description of where the definition came from */
+      const char *defn_name;
+      unsigned defn_line_number;
+***************
+*** 1182,1186 ****
+  #ifdef __cplusplus
+  }
+  #endif
+! 
+  #endif	/* !APACHE_HTTPD_H */
+--- 1198,1206 ----
+  #ifdef __cplusplus
+  }
+  #endif
+! #ifdef SNMP
+! #define SNMP_SCOREBOARD(var)	ap_scoreboard_image->global.var
+! #else
+! #define SNMP_SCOREBOARD(var)	var
+! #endif
+  #endif	/* !APACHE_HTTPD_H */
+diff -rC 3 ../apache_1.3.12/src/include/scoreboard.h src/include/scoreboard.h
+*** ../apache_1.3.12/src/include/scoreboard.h	Wed Jan 12 16:54:56 2000
+--- src/include/scoreboard.h	Mon Apr 17 16:15:39 2000
+***************
+*** 165,170 ****
+--- 165,184 ----
+  typedef struct {
+      ap_generation_t running_generation;	/* the generation of children which
+                                           * should still be serving requests. */
++ #ifdef SNMP
++     int ap_extended_status;
++     int ap_daemons_limit;
++     int ap_daemons_min_free;
++     int ap_daemons_max_free;
++     int ap_max_requests_per_child;
++     int keep_alive;
++     int keep_alive_requests;
++     int keep_alive_timeout;
++     int hostname_lookup;
++     int log_level;
++     unsigned long operStatus[HARD_VIRTUAL_HOST_MAX];
++     unsigned long lastChange[HARD_VIRTUAL_HOST_MAX];
++ #endif
+  } global_score;
+  
+  /* stuff which the parent generally writes and the children rarely read */
+diff -rC 3 ../apache_1.3.12/src/main/http_main.c src/main/http_main.c
+*** ../apache_1.3.12/src/main/http_main.c	Sat Feb  5 13:01:52 2000
+--- src/main/http_main.c	Mon Apr 17 16:27:53 2000
+***************
+*** 123,128 ****
+--- 123,132 ----
+  #include <bstring.h>		/* for IRIX, FD_SET calls bzero() */
+  #endif
+  
++ #ifdef SNMP
++ #include "../modules/snmp_agt/mod_snmp.h"
++ #endif
++ 
+  #ifdef MULTITHREAD
+  /* special debug stuff -- PCS */
+  
+***************
+*** 2225,2231 ****
+      ++ss->cur_vtime;
+  #endif
+  
+!     if (ap_extended_status) {
+  #ifndef OPTIMIZE_TIMEOUTS
+  	ss->last_used = time(NULL);
+  #endif
+--- 2229,2235 ----
+      ++ss->cur_vtime;
+  #endif
+  
+!     if (SNMP_SCOREBOARD(ap_extended_status)) {
+  #ifndef OPTIMIZE_TIMEOUTS
+  	ss->last_used = time(NULL);
+  #endif
+***************
+*** 2885,2890 ****
+--- 2889,2897 ----
+  	 */
+  	return;
+      }
++ #ifdef SNMP
++     cleanup_snmp_module();
++ #endif
+      shutdown_pending = 1;
+  #else
+      signal_parent(0);	    /* get the parent process to wake up */
+***************
+*** 2899,2904 ****
+--- 2906,2914 ----
+  	/* Probably not an error - don't bother reporting it */
+  	return;
+      }
++ #ifdef SNMP
++     cleanup_snmp_module();
++ #endif
+      restart_pending = 1;
+      is_graceful = graceful;
+  #else
+***************
+*** 3785,3791 ****
+  API_EXPORT(void) ap_child_terminate(request_rec *r)
+  {
+      r->connection->keepalive = 0;
+!     requests_this_child = ap_max_requests_per_child = 1;
+  }
+  
+  static void child_main(int child_num_arg)
+--- 3795,3801 ----
+  API_EXPORT(void) ap_child_terminate(request_rec *r)
+  {
+      r->connection->keepalive = 0;
+!     requests_this_child = SNMP_SCOREBOARD(ap_max_requests_per_child) = 1;
+  }
+  
+  static void child_main(int child_num_arg)
+***************
+*** 3905,3912 ****
+  	}
+  
+  #ifndef WIN32
+! 	if ((ap_max_requests_per_child > 0
+! 	     && requests_this_child++ >= ap_max_requests_per_child)) {
+  	    clean_child_exit(0);
+  	}
+  #else
+--- 3915,3922 ----
+  	}
+  
+  #ifndef WIN32
+! 	if ((SNMP_SCOREBOARD(ap_max_requests_per_child) > 0
+! 	     && requests_this_child++ >= SNMP_SCOREBOARD(ap_max_requests_per_child))) {
+  	    clean_child_exit(0);
+  	}
+  #else
+***************
+*** 4176,4182 ****
+  	    if (r->status == HTTP_OK)
+  		ap_process_request(r);
+  
+! 	    if(ap_extended_status)
+  		increment_counts(my_child_num, r);
+  
+  	    if (!current_conn->keepalive || current_conn->aborted)
+--- 4186,4192 ----
+  	    if (r->status == HTTP_OK)
+  		ap_process_request(r);
+  
+! 	    if (SNMP_SCOREBOARD(ap_extended_status))
+  		increment_counts(my_child_num, r);
+  
+  	    if (!current_conn->keepalive || current_conn->aborted)
+***************
+*** 4356,4362 ****
+      int i;
+      time_t now = time(0);
+  
+!     for (i = 0; number_to_start && i < ap_daemons_limit; ++i) {
+  	if (ap_scoreboard_image->servers[i].status != SERVER_DEAD) {
+  	    continue;
+  	}
+--- 4366,4372 ----
+      int i;
+      time_t now = time(0);
+  
+!     for (i = 0; number_to_start && i < SNMP_SCOREBOARD(ap_daemons_limit); ++i) {
+  	if (ap_scoreboard_image->servers[i].status != SERVER_DEAD) {
+  	    continue;
+  	}
+***************
+*** 4401,4407 ****
+      total_non_dead = 0;
+  
+      ap_sync_scoreboard_image();
+!     for (i = 0; i < ap_daemons_limit; ++i) {
+  	int status;
+  
+  	if (i >= max_daemons_limit && free_length == idle_spawn_rate)
+--- 4411,4417 ----
+      total_non_dead = 0;
+  
+      ap_sync_scoreboard_image();
+!     for (i = 0; i < SNMP_SCOREBOARD(ap_daemons_limit); ++i) {
+  	int status;
+  
+  	if (i >= max_daemons_limit && free_length == idle_spawn_rate)
+***************
+*** 4456,4462 ****
+  	}
+      }
+      max_daemons_limit = last_non_dead + 1;
+!     if (idle_count > ap_daemons_max_free) {
+  	/* kill off one child... we use SIGUSR1 because that'll cause it to
+  	 * shut down gracefully, in case it happened to pick up a request
+  	 * while we were counting
+--- 4466,4472 ----
+  	}
+      }
+      max_daemons_limit = last_non_dead + 1;
+!     if (idle_count > SNMP_SCOREBOARD(ap_daemons_max_free)) {
+  	/* kill off one child... we use SIGUSR1 because that'll cause it to
+  	 * shut down gracefully, in case it happened to pick up a request
+  	 * while we were counting
+***************
+*** 4464,4470 ****
+  	kill(ap_scoreboard_image->parent[to_kill].pid, SIGUSR1);
+  	idle_spawn_rate = 1;
+      }
+!     else if (idle_count < ap_daemons_min_free) {
+  	/* terminate the free list */
+  	if (free_length == 0) {
+  	    /* only report this condition once */
+--- 4474,4480 ----
+  	kill(ap_scoreboard_image->parent[to_kill].pid, SIGUSR1);
+  	idle_spawn_rate = 1;
+      }
+!     else if (idle_count < SNMP_SCOREBOARD(ap_daemons_min_free)) {
+  	/* terminate the free list */
+  	if (free_length == 0) {
+  	    /* only report this condition once */
+***************
+*** 4631,4639 ****
+  #endif
+  
+  	set_signals();
+! 
+! 	if (ap_daemons_max_free < ap_daemons_min_free + 1)	/* Don't thrash... */
+! 	    ap_daemons_max_free = ap_daemons_min_free + 1;
+  
+  	/* If we're doing a graceful_restart then we're going to see a lot
+  	 * of children exiting immediately when we get into the main loop
+--- 4641,4648 ----
+  #endif
+  
+  	set_signals();
+! 	if (SNMP_SCOREBOARD(ap_daemons_max_free) < SNMP_SCOREBOARD(ap_daemons_min_free) + 1)	/* Don't thrash... */
+! 	    SNMP_SCOREBOARD(ap_daemons_max_free) = SNMP_SCOREBOARD(ap_daemons_min_free) + 1;
+  
+  	/* If we're doing a graceful_restart then we're going to see a lot
+  	 * of children exiting immediately when we get into the main loop
+***************
+*** 4644,4651 ****
+  	 * supposed to start up without the 1 second penalty between each fork.
+  	 */
+  	remaining_children_to_start = ap_daemons_to_start;
+! 	if (remaining_children_to_start > ap_daemons_limit) {
+! 	    remaining_children_to_start = ap_daemons_limit;
+  	}
+  	if (!is_graceful) {
+  	    startup_children(remaining_children_to_start);
+--- 4653,4660 ----
+  	 * supposed to start up without the 1 second penalty between each fork.
+  	 */
+  	remaining_children_to_start = ap_daemons_to_start;
+! 	if (remaining_children_to_start > SNMP_SCOREBOARD(ap_daemons_limit)) {
+! 	    remaining_children_to_start = SNMP_SCOREBOARD(ap_daemons_limit);
+  	}
+  	if (!is_graceful) {
+  	    startup_children(remaining_children_to_start);
+***************
+*** 4657,4662 ****
+--- 4666,4676 ----
+  	    hold_off_on_exponential_spawning = 10;
+  	}
+  
++ 	#ifdef SNMP
++ 	    /* starting the SNMP ENTITY */
++ 	    snmp_agt_main(server_conf, pconf, ptrans);
++ 	#endif /* SNMP */
++ 
+  	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, server_conf,
+  		    "%s configured -- resuming normal operations",
+  		    ap_get_server_version());
+***************
+*** 4687,4693 ****
+  		    (void) ap_update_child_status(child_slot, SERVER_DEAD,
+  					       (request_rec *) NULL);
+  		    if (remaining_children_to_start
+! 			&& child_slot < ap_daemons_limit) {
+  			/* we're still doing a 1-for-1 replacement of dead
+  			 * children with new children
+  			 */
+--- 4701,4707 ----
+  		    (void) ap_update_child_status(child_slot, SERVER_DEAD,
+  					       (request_rec *) NULL);
+  		    if (remaining_children_to_start
+! 			&& child_slot < SNMP_SCOREBOARD(ap_daemons_limit)) {
+  			/* we're still doing a 1-for-1 replacement of dead
+  			 * children with new children
+  			 */
+***************
+*** 4797,4803 ****
+  	     * corruption too easily.
+  	     */
+  	    ap_sync_scoreboard_image();
+! 	    for (i = 0; i < ap_daemons_limit; ++i) {
+  		if (ap_scoreboard_image->servers[i].status != SERVER_DEAD) {
+  		    ap_scoreboard_image->servers[i].status = SERVER_GRACEFUL;
+  		}
+--- 4811,4817 ----
+  	     * corruption too easily.
+  	     */
+  	    ap_sync_scoreboard_image();
+! 	    for (i = 0; i < SNMP_SCOREBOARD(ap_daemons_limit); ++i) {
+  		if (ap_scoreboard_image->servers[i].status != SERVER_DEAD) {
+  		    ap_scoreboard_image->servers[i].status = SERVER_GRACEFUL;
+  		}
+***************
+*** 5426,5432 ****
+  	    if (r->status == HTTP_OK)
+  		ap_process_request(r);
+  
+! 	    if (ap_extended_status)
+  		increment_counts(child_num, r);
+  	    if (!current_conn->keepalive || current_conn->aborted)
+  		break;
+--- 5440,5446 ----
+  	    if (r->status == HTTP_OK)
+  		ap_process_request(r);
+  
+! 	    if (SNMP_SCOREBOARD(ap_extended_status))
+  		increment_counts(child_num, r);
+  	    if (!current_conn->keepalive || current_conn->aborted)
+  		break;
+***************
+*** 5835,5841 ****
+      sd = -1;
+      nthreads = ap_threads_per_child;
+      max_jobs_after_exit_request = ap_excess_requests_per_child;
+!     max_jobs_per_exe = ap_max_requests_per_child;
+      if (nthreads <= 0)
+  	nthreads = 40;
+      if (max_jobs_per_exe <= 0)
+--- 5849,5855 ----
+      sd = -1;
+      nthreads = ap_threads_per_child;
+      max_jobs_after_exit_request = ap_excess_requests_per_child;
+!     max_jobs_per_exe = SNMP_SCOREBOARD(ap_max_requests_per_child);
+      if (nthreads <= 0)
+  	nthreads = 40;
+      if (max_jobs_per_exe <= 0)
+diff -rC 3 ../apache_1.3.12/src/main/http_protocol.c src/main/http_protocol.c
+*** ../apache_1.3.12/src/main/http_protocol.c	Sun Feb 20 02:14:47 2000
+--- src/main/http_protocol.c	Mon Apr 17 05:53:50 2000
+***************
+*** 1022,1027 ****
+--- 1022,1029 ----
+  
+      r->sent_bodyct     = 0;                      /* bytect isn't for body */
+  
++     r->bytes_recv      = 0;
++ 
+      r->read_length     = 0;
+      r->read_body       = REQUEST_NO_BODY;
+  
+***************
+*** 2100,2106 ****
+          }
+          ap_hard_timeout("reading request body", r);
+          while ((rv = ap_get_client_block(r, dumpbuf, HUGE_STRING_LEN)) > 0)
+!             continue;
+          ap_kill_timeout(r);
+  
+          if (rv < 0)
+--- 2102,2108 ----
+          }
+          ap_hard_timeout("reading request body", r);
+          while ((rv = ap_get_client_block(r, dumpbuf, HUGE_STRING_LEN)) > 0)
+!             r->bytes_recv += rv;
+          ap_kill_timeout(r);
+  
+          if (rv < 0)
+diff -rC 3 ../apache_1.3.12/src/main/http_request.c src/main/http_request.c
+*** ../apache_1.3.12/src/main/http_request.c	Tue Jan 11 15:13:41 2000
+--- src/main/http_request.c	Mon Apr 17 16:18:06 2000
+***************
+*** 71,77 ****
+--- 71,79 ----
+  #include "http_request.h"
+  #include "http_core.h"
+  #include "http_protocol.h"
++ #ifndef SNMP
+  #include "http_conf_globals.h"	/* for ap_extended_status */
++ #endif
+  #include "http_log.h"
+  #include "http_main.h"
+  #include "scoreboard.h"
+***************
+*** 1225,1231 ****
+  {
+      int old_stat;
+  
+!     if (ap_extended_status)
+  	ap_time_process_request(r->connection->child_num, START_PREQUEST);
+  
+      process_request_internal(r);
+--- 1227,1233 ----
+  {
+      int old_stat;
+  
+!     if (SNMP_SCOREBOARD(ap_extended_status))
+  	ap_time_process_request(r->connection->child_num, START_PREQUEST);
+  
+      process_request_internal(r);
+***************
+*** 1244,1250 ****
+      ap_log_transaction(r);
+  
+      (void) ap_update_child_status(r->connection->child_num, old_stat, r);
+!     if (ap_extended_status)
+  	ap_time_process_request(r->connection->child_num, STOP_PREQUEST);
+  }
+  
+--- 1246,1252 ----
+      ap_log_transaction(r);
+  
+      (void) ap_update_child_status(r->connection->child_num, old_stat, r);
+!     if (SNMP_SCOREBOARD(ap_extended_status))
+  	ap_time_process_request(r->connection->child_num, STOP_PREQUEST);
+  }
+  
+diff -rC 3 ../apache_1.3.12/src/modules/standard/mod_status.c src/modules/standard/mod_status.c
+*** ../apache_1.3.12/src/modules/standard/mod_status.c	Sat Feb  5 13:33:16 2000
+--- src/modules/standard/mod_status.c	Mon Apr 17 16:24:18 2000
+***************
+*** 311,317 ****
+  	    ready++;
+  	else if (res != SERVER_DEAD)
+  	    busy++;
+! 	if (ap_extended_status) {
+  	    lres = score_record.access_count;
+  	    bytes = score_record.bytes_served;
+  	    if (lres != 0 || (res != SERVER_READY && res != SERVER_DEAD)) {
+--- 311,317 ----
+  	    ready++;
+  	else if (res != SERVER_DEAD)
+  	    busy++;
+! 	if (SNMP_SCOREBOARD(ap_extended_status)) {
+  	    lres = score_record.access_count;
+  	    bytes = score_record.bytes_served;
+  	    if (lres != 0 || (res != SERVER_READY && res != SERVER_DEAD)) {
+***************
+*** 356,362 ****
+  	ap_rputs("<br>\n", r);
+      }
+  
+!     if (ap_extended_status) {
+  	if (short_report) {
+  	    ap_rprintf(r, "Total Accesses: %lu\nTotal kBytes: %lu\n",
+  		count, kbcount);
+--- 356,362 ----
+  	ap_rputs("<br>\n", r);
+      }
+  
+!     if (SNMP_SCOREBOARD(ap_extended_status)) {
+  	if (short_report) {
+  	    ap_rprintf(r, "Total Accesses: %lu\nTotal kBytes: %lu\n",
+  		count, kbcount);
+***************
+*** 450,456 ****
+  	ap_rputs("\"<B><code>G</code></B>\" Gracefully finishing, \n", r);
+  	ap_rputs("\"<B><code>.</code></B>\" Open slot with no current process<P>\n", r);
+  	ap_rputs("<P>\n", r);
+! 	if (!ap_extended_status) {
+  	    int j = 0;
+  	    ap_rputs("PID Key: <br>\n", r);
+  	    ap_rputs("<PRE>\n", r);
+--- 450,456 ----
+  	ap_rputs("\"<B><code>G</code></B>\" Gracefully finishing, \n", r);
+  	ap_rputs("\"<B><code>.</code></B>\" Open slot with no current process<P>\n", r);
+  	ap_rputs("<P>\n", r);
+! 	if (! SNMP_SCOREBOARD(ap_extended_status)) {
+  	    int j = 0;
+  	    ap_rputs("PID Key: <br>\n", r);
+  	    ap_rputs("<PRE>\n", r);
+***************
+*** 469,476 ****
+  	    ap_rputs("</PRE>\n", r);
+  	}
+      }
+! 
+!     if (ap_extended_status) {
+  	if (!short_report) {
+  	    if (no_table_report)
+  		ap_rputs("<p><hr><h2>Server Details</h2>\n\n", r);
+--- 469,475 ----
+  	    ap_rputs("</PRE>\n", r);
+  	}
+      }
+!     if (SNMP_SCOREBOARD(ap_extended_status)) {
+  	if (!short_report) {
+  	    if (no_table_report)
+  		ap_rputs("<p><hr><h2>Server Details</h2>\n\n", r);
diff -ru -ruN apache_1.3.34_orig/src/modules/snmp_agt/remake_status apache_1.3.34/src/modules/snmp_agt/remake_status
--- apache_1.3.34_orig/src/modules/snmp_agt/remake_status	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/src/modules/snmp_agt/remake_status	2006-05-18 16:49:19.296763648 +0200
@@ -0,0 +1,47 @@
+#!/bin/sh
+#
+# Quick script to re-generate the status
+# codes and method arrays from the httpd.h
+# file; note the peculiar searching !
+#
+# Dirk.vanGulik@jrc.it
+#
+(
+cat <<EOM
+
+/* Dynamicaly generated HTTP Status Codes and their ascii
+ * representation. Do not edit manually; but delete the
+ * file and do another make (or a make status_codes.h)
+ */
+
+int responseTypes[] = {
+EOM
+
+grep "define HTTP_" ../../include/httpd.h |\
+	grep -v "HTTP_VERSION" |\
+	sed -e "s/HTTP_//g" |\
+	awk '{ printf "%d,",$3 }' |\
+	sort -n |\
+	sed -e "s/,$//g"
+cat <<EOM
+, 0 };
+
+char * requestTypes[] ={
+EOM
+
+grep "define M_" ../../include/httpd.h |\
+	sed -e "s/INVALID/HEAD/g" |\
+	sed -e "s/M_//g" |\
+	awk '{ print length($2) " " $2 }' |\
+	sort -n |\
+	awk '{ printf "\"%s\",",$2 }' |\
+	sort |\
+	sed -e "s/,$//g"
+
+cat <<EOM
+};
+
+EOM
+
+) > status_codes.h
+	
diff -ru -ruN apache_1.3.34_orig/src/modules/snmp_agt/scoreboard-mib.c apache_1.3.34/src/modules/snmp_agt/scoreboard-mib.c
--- apache_1.3.34_orig/src/modules/snmp_agt/scoreboard-mib.c	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/src/modules/snmp_agt/scoreboard-mib.c	2006-05-18 16:49:19.295763800 +0200
@@ -0,0 +1,191 @@
+/* ====================================================================
+ * Copyright (c) 1997-2000 Harrie Hazewinkel.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by Harrie Hazewinkel."
+ *
+ * 4. The name of the Copyright holder must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission.
+ *
+ * 5. Products derived from this software may not be called "MOD-SNMP"
+ *    nor may "MOD-SNMP" appear in their names  without prior written
+ *    permission of the Harrie Hazewinkel.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the Harrie Hazewinkel"
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * The creator of this module is harrie@mod-snmp.com
+ * This file contains generated code of SMASH also created by Harrie.
+ *
+ */
+
+ 
+#include <httpd.h>
+#include "http_config.h"
+#include <http_conf_globals.h>
+#include <scoreboard.h>
+
+/* SNMP includes */
+#include "asn1.h"
+#include "snmp.h"
+#include "agt_mib.h"
+#include "agt_engine.h"
+#include "scoreboard-mib.h"
+#include "snmpv2-mib.h"
+
+#include "mod_snmp.h"
+
+
+/* APACHE_SCOREBOARD_MIB initialisation (must also register the MIB module tree */
+void init_APACHE_SCOREBOARD_MIB()
+{
+
+    register_subtrees_of_APACHE_SCOREBOARD_MIB();
+    /* insert the Object Resource in sysORTable */
+    { static struct sysOREntry_struct value = { NULL, 1, {8, {O_scoreboardMIB}}, "The Scoreboard MIB module", 0};
+      insert_sysOREntry(&value);
+    }
+
+}
+
+int
+create_scoreBoard_Index(int searchType, 
+	Oid *req_oid, Oid *var_oid)
+{
+int     var_oidlen = var_oid->namelen++;
+int	i;
+
+    for ( i=0 ; i < HARD_SERVER_LIMIT; ++i) {
+	if (ap_scoreboard_image->parent[ i ].pid) {
+	    var_oid->name[ var_oidlen ] = (i +1);
+	    if (searchType == NEXT) {
+		if ( 0 > compare(req_oid, var_oid)) {
+		    return(i);
+		}
+	    } else {
+		if ( 0 == compare(req_oid, var_oid)) {
+		    return(i);
+		}
+	    }
+	}
+    }
+    return(-1);
+}	
+
+unsigned char *
+var_scoreBoardEntry(	int *var_len,
+	Oid *newoid, Oid *reqoid, int searchType,
+	snmp_info_t *mesg, int (**write_method)())
+{
+/* Last subOID of COLUMNAR OID is column */
+int		column = newoid->name[(newoid->namelen - 1)];
+int		score_index;
+server_rec	*vh;
+
+    ap_sync_scoreboard_image();
+    score_index = create_scoreBoard_Index(searchType, reqoid, newoid);
+    if (score_index < 0) {
+	return(NULL);
+    }
+    switch (column) {
+	case I_scoreBoardIndex:
+	    return (unsigned char *) NULL;
+	case I_scoreBoardProcessId:
+	    *var_len = sizeof(pid_t);
+	    return (unsigned char *) &(ap_scoreboard_image->parent[ score_index ].pid);
+	case I_scoreBoardStatus:
+	    *var_len = sizeof(long_return);
+	    long_return = ap_scoreboard_image->servers[ score_index ].status;
+	    return (unsigned char *) &(long_return);
+	case I_scoreBoardStartTime:
+	    *var_len = sizeof(long_return);
+            long_return = ap_scoreboard_image->servers[ score_index ].status;
+            return (unsigned char *) &(long_return);
+	case I_scoreBoardAccessCount:
+	    *var_len = sizeof(long_return);
+            long_return = ap_scoreboard_image->servers[ score_index ].access_count;
+            return (unsigned char *) &(long_return);
+	case I_scoreBoardAccessBytes:
+	    *var_len = sizeof(long_return);
+            long_return = ap_scoreboard_image->servers[ score_index ].bytes_served;
+            return (unsigned char *) &(long_return);
+	case I_scoreBoardClient:
+	    *var_len = strlen(ap_scoreboard_image->servers[ score_index ].client);
+	    return (unsigned char *) ap_scoreboard_image->servers[ score_index ].client;
+	case I_scoreBoardRequest:
+	    *var_len = strlen(ap_scoreboard_image->servers[ score_index ].request);
+	    return (unsigned char *) ap_scoreboard_image->servers[ score_index ].request;
+	case I_scoreBoardVirtualHost:
+	    vh = ap_scoreboard_image->servers[ score_index ].vhostrec;
+	    if (vh) {
+		*var_len = sizeof(vh->vhost_index);
+		return (unsigned char *) vh->vhost_index;
+	    } else {
+		*var_len = sizeof(long_return);
+		long_return = 0;
+		return (unsigned char *) &long_return;
+	    }
+        default:
+            return NULL;
+    }
+}
+
+
+static oid scoreBoardEntry_oid[] = { O_scoreBoardEntry };
+static Object scoreBoardEntry_variables[] = {
+    { SNMP_UINTEGER, (RONLY| COLUMN), var_scoreBoardEntry,
+                {1, { I_scoreBoardProcessId }}},
+    { SNMP_INTEGER, (RONLY| COLUMN), var_scoreBoardEntry,
+                {1, { I_scoreBoardStatus }}},
+    { SNMP_TIMETICKS, (RONLY| COLUMN), var_scoreBoardEntry,
+                {1, { I_scoreBoardStartTime }}},
+    { SNMP_UINTEGER, (RONLY| COLUMN), var_scoreBoardEntry,
+                {1, { I_scoreBoardAccessCount }}},
+    { SNMP_UINTEGER, (RONLY| COLUMN), var_scoreBoardEntry,
+                {1, { I_scoreBoardAccessBytes }}},
+    { SNMP_STRING, (RONLY| COLUMN), var_scoreBoardEntry,
+                {1, { I_scoreBoardClient }}},
+    { SNMP_STRING, (RONLY| COLUMN), var_scoreBoardEntry,
+                {1, { I_scoreBoardRequest }}},
+    { SNMP_UINTEGER, (RONLY| COLUMN), var_scoreBoardEntry,
+                {1, { I_scoreBoardVirtualHost }}},
+    { 0, 0, NULL, {0, {0}}}
+    };
+static SubTree scoreBoardEntry_tree =  { NULL, scoreBoardEntry_variables,
+	        (sizeof(scoreBoardEntry_oid)/sizeof(oid)), scoreBoardEntry_oid};
+
+/* This is the MIB registration function. This should be called */
+/* within the init_APACHE_SCOREBOARD_MIB-function */
+void register_subtrees_of_APACHE_SCOREBOARD_MIB()
+{
+    insert_group_in_mib(&scoreBoardEntry_tree);
+}
diff -ru -ruN apache_1.3.34_orig/src/modules/snmp_agt/scoreboard-mib.h apache_1.3.34/src/modules/snmp_agt/scoreboard-mib.h
--- apache_1.3.34_orig/src/modules/snmp_agt/scoreboard-mib.h	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/src/modules/snmp_agt/scoreboard-mib.h	2006-05-18 16:49:19.300763040 +0200
@@ -0,0 +1,137 @@
+/* ====================================================================
+ * Copyright (c) 1997-2000 Harrie Hazewinkel.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by Harrie Hazewinkel."
+ *
+ * 4. The name of the Copyright holder must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission.
+ *
+ * 5. Products derived from this software may not be called "MOD-SNMP"
+ *    nor may "MOD-SNMP" appear in their names  without prior written
+ *    permission of the Harrie Hazewinkel.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the Harrie Hazewinkel"
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * The creator of this module is Harrie.Hazewinkel@bigfoot.com
+ * This file contains generated code of SMASH also created by Harrie.
+ *
+ *
+ */
+
+#ifndef	_APACHE_SCOREBOARD_MIB_
+#define	_APACHE_SCOREBOARD_MIB_
+
+/* required include files (IMPORTS) */
+
+
+void init_APACHE_SCOREBOARD_MIB();
+void register_subtrees_of_APACHE_SCOREBOARD_MIB();
+
+/* defined objects in this module */
+
+/* MIB object scoreboardMIB = universityOfTwente, 5 */
+#define I_scoreboardMIB 5
+#define O_scoreboardMIB 1, 3, 6, 1, 4, 1, 785, 5
+
+/* MIB object universityOfTwente = enterprises, 785 */
+#define I_universityOfTwente    785
+#define O_universityOfTwente    1, 3, 6, 1, 4, 1, 785
+
+/* MIB object scoreboardMIBObjects = scoreboardMIB, 1 */
+#define	I_scoreboardMIBObjects	1
+#define	O_scoreboardMIBObjects	1, 3, 6, 1, 4, 1, 785, 5, 1
+
+/* MIB object scoreBoardTable = scoreboardMIBObjects, 1 */
+#define	I_scoreBoardTable	1
+#define	O_scoreBoardTable	1, 3, 6, 1, 4, 1, 785, 5, 1, 1
+
+/* MIB object scoreBoardEntry = scoreBoardTable, 1 */
+#define	I_scoreBoardEntry	1
+#define	O_scoreBoardEntry	1, 3, 6, 1, 4, 1, 785, 5, 1, 1, 1
+
+/* MIB object scoreBoardIndex = scoreBoardEntry, 1 */
+#define	I_scoreBoardIndex	1
+#define	O_scoreBoardIndex	1, 3, 6, 1, 4, 1, 785, 5, 1, 1, 1, 1
+
+/* MIB object scoreBoardProcessId = scoreBoardEntry, 2 */
+#define	I_scoreBoardProcessId	2
+#define	O_scoreBoardProcessId	1, 3, 6, 1, 4, 1, 785, 5, 1, 1, 1, 2
+
+/* MIB object scoreBoardStatus = scoreBoardEntry, 3 */
+#define	I_scoreBoardStatus	3
+#define	O_scoreBoardStatus	1, 3, 6, 1, 4, 1, 785, 5, 1, 1, 1, 3
+
+/* MIB object scoreBoardStartTime = scoreBoardEntry, 4 */
+#define	I_scoreBoardStartTime	4
+#define	O_scoreBoardStartTime	1, 3, 6, 1, 4, 1, 785, 5, 1, 1, 1, 4
+
+/* MIB object scoreBoardAccessCount = scoreBoardEntry, 5 */
+#define	I_scoreBoardAccessCount	5
+#define	O_scoreBoardAccessCount	1, 3, 6, 1, 4, 1, 785, 5, 1, 1, 1, 5
+
+/* MIB object scoreBoardAccessBytes = scoreBoardEntry, 6 */
+#define	I_scoreBoardAccessBytes	6
+#define	O_scoreBoardAccessBytes	1, 3, 6, 1, 4, 1, 785, 5, 1, 1, 1, 6
+
+/* MIB object scoreBoardClient = scoreBoardEntry, 7 */
+#define	I_scoreBoardClient	7
+#define	O_scoreBoardClient	1, 3, 6, 1, 4, 1, 785, 5, 1, 1, 1, 7
+
+/* MIB object scoreBoardRequest = scoreBoardEntry, 8 */
+#define	I_scoreBoardRequest	8
+#define	O_scoreBoardRequest	1, 3, 6, 1, 4, 1, 785, 5, 1, 1, 1, 8
+
+/* MIB object scoreBoardVirtualHost = scoreBoardEntry, 9 */
+#define	I_scoreBoardVirtualHost	9
+#define	O_scoreBoardVirtualHost	1, 3, 6, 1, 4, 1, 785, 5, 1, 1, 1, 9
+
+/* MIB object scoreboardMIBConformance = scoreboardMIB, 2 */
+#define	I_scoreboardMIBConformance	2
+#define	O_scoreboardMIBConformance	1, 3, 6, 1, 4, 1, 785, 5, 2
+
+/* MIB object scoreboardMIBCompliances = scoreboardMIBConformance, 1 */
+#define	I_scoreboardMIBCompliances	1
+#define	O_scoreboardMIBCompliances	1, 3, 6, 1, 4, 1, 785, 5, 2, 1
+
+/* MIB object scoreboardMIBGroups = scoreboardMIBConformance, 2 */
+#define	I_scoreboardMIBGroups	2
+#define	O_scoreboardMIBGroups	1, 3, 6, 1, 4, 1, 785, 5, 2, 2
+
+/* MIB object scoreBoardGroup = scoreboardMIBGroups, 1 */
+#define	I_scoreBoardGroup	1
+#define	O_scoreBoardGroup	1, 3, 6, 1, 4, 1, 785, 5, 2, 2, 1
+
+/* Put here additional MIB specific include definitions */
+
+#endif	/* _APACHE_SCOREBOARD_MIB_ */
diff -ru -ruN apache_1.3.34_orig/src/modules/snmp_agt/snmpv2-conf.h apache_1.3.34/src/modules/snmp_agt/snmpv2-conf.h
--- apache_1.3.34_orig/src/modules/snmp_agt/snmpv2-conf.h	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/src/modules/snmp_agt/snmpv2-conf.h	2006-05-18 16:49:19.299763192 +0200
@@ -0,0 +1,57 @@
+/* ====================================================================
+ * Copyright (c) 1997-2000 Harrie Hazewinkel.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by Harrie Hazewinkel."
+ *
+ * 4. The name of the Copyright holder must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission.
+ *
+ * 5. Products derived from this software may not be called "MOD-SNMP"
+ *    nor may "MOD-SNMP" appear in their names  without prior written
+ *    permission of the Harrie Hazewinkel.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the Harrie Hazewinkel"
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * The creator of this module is Harrie.Hazewinkel@bigfoot.com
+ * This file contains generated code of SMASH also created by Harrie.
+ *
+ *
+ */
+
+#ifndef	_SNMPv2_CONF_
+#define	_SNMPv2_CONF_
+
+/* required include files (IMPORTS) */
+/* defined objects in this module */
+#endif	/* _SNMPv2_CONF_ */
diff -ru -ruN apache_1.3.34_orig/src/modules/snmp_agt/snmpv2-mib.c apache_1.3.34/src/modules/snmp_agt/snmpv2-mib.c
--- apache_1.3.34_orig/src/modules/snmp_agt/snmpv2-mib.c	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/src/modules/snmp_agt/snmpv2-mib.c	2006-05-18 16:49:19.300763040 +0200
@@ -0,0 +1,912 @@
+/* ====================================================================
+ * Copyright (c) 1997-2000 Harrie Hazewinkel.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by Harrie Hazewinkel."
+ *
+ * 4. The name of the Copyright holder must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission.
+ *
+ * 5. Products derived from this software may not be called "MOD-SNMP"
+ *    nor may "MOD-SNMP" appear in their names  without prior written
+ *    permission of the Harrie Hazewinkel.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the Harrie Hazewinkel"
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * The creator of this module is harrie@mod-snmp.com
+ * This file contains generated code of SMASH also created by Harrie.
+ *
+ *
+ */
+
+
+/* Apache includes */
+#include "httpd.h"
+#include "http_config.h"
+
+/* mod_snmp includes */
+#include "mod_snmp.h"
+
+/* SNMP includes */
+#include "asn1.h"
+#include "snmp.h"
+#include "agt_mib.h"
+#include "agt_engine.h"
+#include "snmpv2-mib.h"
+
+struct timeval snmp_boottime;
+char *sysDescr_value = SERVER_VERSION " - " SERVER_PROTOCOL " - " SNMP_AGT_VERSION;
+char *sysLocation_value = "[no location given]";
+char *sysContact_value = "[no address given]";
+
+/* SNMPv2_MIB initialisation (must also register the MIB module tree */
+void init_SNMPv2_MIB()
+{
+
+    gettimeofday(&snmp_boottime, (struct timezone *)0);
+    register_subtrees_of_SNMPv2_MIB();
+}
+
+const char*
+init_sysDescr(cmd_parms *cmd, void *dummy, char *arg)
+{
+    pool *p = cmd->pool;
+    int i = strlen(arg);
+
+    if (i > MAX_OCTSTR_LEN) {
+	i = MAX_OCTSTR_LEN;
+    }
+    sysDescr_value = (char *)ap_pcalloc (p, i+1);
+    if (sysDescr_value) {
+	strncpy(sysDescr_value, arg, i);
+    }
+    return NULL;
+}
+
+unsigned char *
+var_sysDescr(int *var_len,
+        snmp_info_t *mesg, int (**write_method)() )
+{
+    *write_method = 0;
+    *var_len = strlen(sysDescr_value);
+    /* return the value */
+    return (unsigned char *) sysDescr_value;
+}
+
+unsigned char *
+var_sysObjectID(int *var_len,
+        snmp_info_t *mesg, int (**write_method)() )
+{
+/* OID enterprises.universityOfTwente.4 */
+static int version_oid[] = {O_enterprises, 785, 4};
+
+    *write_method = 0;
+    *var_len = sizeof(version_oid);
+    /* return the value */
+    return (unsigned char *) version_oid;
+}
+
+unsigned long	time2sysUpTime(time_t theTime)
+{
+   return((theTime - snmp_boottime.tv_sec) * 100
+		+ snmp_boottime.tv_usec / 10000);
+}
+
+unsigned long    current_sysUpTime()
+{
+struct timeval  now;
+
+    gettimeofday(&now, (struct timezone *)0);
+    return ((now.tv_sec - snmp_boottime.tv_sec) * 100
+	 	+ (now.tv_usec - snmp_boottime.tv_usec) / 10000);
+}
+
+
+
+
+unsigned char *
+var_sysUpTime(int *var_len,
+        snmp_info_t *mesg, int (**write_method)() )
+{
+    *write_method = 0;
+    *var_len = sizeof(long);
+    /* return the value */
+    long_return = current_sysUpTime();
+    return (unsigned char *) &long_return;
+}
+
+const char*
+init_sysContact(cmd_parms *cmd, void *dummy, char *arg)
+{
+    pool *p = cmd->pool;
+    int i = strlen(arg);
+
+    if (i > MAX_OCTSTR_LEN) {
+	i = MAX_OCTSTR_LEN;
+    }
+    sysContact_value = (char *)ap_pcalloc (p, i+1);
+    if (sysContact_value) {
+	strncpy(sysContact_value, arg, i);
+    }
+    return NULL;
+}
+
+/* NOT implemented
+int	write_sysContact(int action,
+	unsigned char *var_val, unsigned char varval_type, int var_val_len
+	unsigned char *statP, oid *name, int name_len)
+{
+    switch (action) {
+    case RESERVE1:
+    case RESERVE2:
+    case COMMIT:
+    case FREE:
+    }
+}
+*/
+
+unsigned char *
+var_sysContact(int *var_len,
+        snmp_info_t *mesg, int (**write_method)() )
+{
+    *write_method = 0;
+    *var_len = strlen(sysContact_value);
+    /* return the value */
+    return (unsigned char *) sysContact_value;
+}
+
+/* NOT implemented
+int	write_sysName(int action,
+	unsigned char *var_val, unsigned char varval_type, int var_val_len
+	unsigned char *statP, oid *name, int name_len)
+{
+    switch (action) {
+    case RESERVE1:
+    case RESERVE2:
+    case COMMIT:
+    case FREE:
+    }
+}
+*/
+
+unsigned char *
+var_sysName(int *var_len,
+        snmp_info_t *mesg, int (**write_method)() )
+{
+    *write_method = 0;
+    *var_len = sizeof(long);
+    if (0 == gethostname(return_buf, 50)) {
+	*var_len = strlen(return_buf);
+	return (unsigned char *) return_buf;
+	}
+    /* Should be GENERR */
+    *var_len = sizeof(long);
+    long_return = 0;
+    return (unsigned char *) &long_return;
+}
+
+const char*
+init_sysLocation(cmd_parms *cmd, void *dummy, char *arg)
+{
+    pool *p = cmd->pool;
+    int i = strlen(arg);
+
+    if (i > MAX_OCTSTR_LEN) {
+	i = MAX_OCTSTR_LEN;
+    }
+    sysLocation_value = (char *)ap_pcalloc (p, i+1);
+    if (sysLocation_value) {
+	strncpy(sysLocation_value, arg, i);
+    }
+    return NULL;
+}
+
+/* NOT implemented
+int	write_sysLocation(int action,
+	unsigned char *var_val, unsigned char varval_type, int var_val_len
+	unsigned char *statP, oid *name, int name_len)
+{
+    switch (action) {
+    case RESERVE1:
+    case RESERVE2:
+    case COMMIT:
+    case FREE:
+    }
+}
+*/
+
+unsigned char *
+var_sysLocation(int *var_len,
+        snmp_info_t *mesg, int (**write_method)() )
+{
+    *write_method = 0;
+    *var_len = strlen(sysLocation_value);
+    return (unsigned char *) sysLocation_value;
+}
+
+/* loosely defined OSI layers :-) of the sysService
+ * field in systemgroup in SNMPv2
+ */
+#define SS_PHYS         1
+#define SS_DATALINK     2
+#define SS_INET         4
+#define SS_END2END      8
+#define SS_SMTP         64
+
+unsigned char *
+var_sysServices(int *var_len,
+        snmp_info_t *mesg, int (**write_method)() )
+{
+    *write_method = 0;
+    *var_len = sizeof(long);
+    long_return = (long) SS_SMTP | SS_END2END | SS_INET ;
+    return (unsigned char *) &long_return;
+}
+
+unsigned long sysORLastChange_value = 0;
+
+unsigned char *
+var_sysORLastChange(int *var_len,
+        snmp_info_t *mesg, int (**write_method)() )
+{
+    *write_method = 0;
+    *var_len = sizeof(sysORLastChange_value);
+    return (unsigned char *) &sysORLastChange_value;
+}
+
+struct sysOREntry_struct sysOREntry_snmpV2_value = { NULL, 1, {7, {O_snmpMIB}}, "The MIB module for SNMPv2 entities", 0};
+struct sysOREntry_struct *sysOREntry_root = &sysOREntry_snmpV2_value;
+
+int insert_sysOREntry(struct sysOREntry_struct *value)  
+{
+struct sysOREntry_struct *current = sysOREntry_root;
+
+    while (current->next) {
+            current = current->next;
+    }
+    value->index = current->index + 1;
+    current->next = value;
+    sysORLastChange_value = current_sysUpTime();
+    current->lastChange = sysORLastChange_value;
+    return(0); 
+}   
+
+unsigned char *
+var_sysOREntry( int *var_len,
+	Oid *newoid, Oid *reqoid, int searchType,
+	snmp_info_t *mesg, int (**write_method)() )
+{
+/* Last subOID of COLUMNAR OID is column */
+int     column = newoid->name[(newoid->namelen - 1)];
+int     sysORIndex = newoid->namelen++;
+/* Variables defined */
+int     result;
+struct sysOREntry_struct *current = sysOREntry_root;
+
+    while (current) { 
+	newoid->name[ sysORIndex ] = current->index;
+	result = compare(reqoid, newoid);
+	if (((searchType == EXACT) && (result == 0)) ||
+		((searchType == NEXT) && (result < 0))) {
+	   break;
+        }
+	current = current->next;
+    }
+    if (current == NULL) return(NULL);
+
+    *write_method = 0;
+
+    switch (column) {
+	case I_sysORIndex:
+	    return (unsigned char *) NULL;
+	case I_sysORID:
+	    *var_len = current->oid_value.namelen * sizeof(oid);
+	    return (unsigned char *) &(current->oid_value.name);
+	case I_sysORDescr:
+	    *var_len = strlen(current->descr);
+	    return (unsigned char *) current->descr;
+	case I_sysORUpTime:
+	    *var_len = sizeof(unsigned long);
+            return (unsigned char *) &(current->lastChange);
+	default:
+	    return NULL;
+    }
+}
+
+unsigned char *
+var_snmpInPkts(int *var_len,
+	snmp_info_t *mesg, int (**write_method)()	)
+{
+extern long	snmpInPkts_instance;
+
+    *write_method = 0;
+    *var_len = sizeof(long);
+    return (unsigned char *) &snmpInPkts_instance;
+}
+
+unsigned char *
+var_snmpInBadVersions(int *var_len,
+	snmp_info_t *mesg, int (**write_method)()	)
+{
+extern long	snmpInBadVersions_instance;
+
+    *write_method = 0;
+    *var_len = sizeof(long);
+    return (unsigned char *) &snmpInBadVersions_instance;
+}
+
+
+unsigned char *
+var_snmpInBadCommunityNames(int *var_len,
+	snmp_info_t *mesg, int (**write_method)()	)
+{
+extern long	snmpInBadCommunityNames_instance;
+
+    *write_method = 0;
+    *var_len = sizeof(long);
+    return (unsigned char *) &snmpInBadCommunityNames_instance;
+}
+
+
+unsigned char *
+var_snmpInBadCommunityUses(int *var_len,
+	snmp_info_t *mesg, int (**write_method)()	)
+{
+extern long	snmpInBadCommunityUses_instance;
+
+    *write_method = 0;
+    *var_len = sizeof(long);
+    return (unsigned char *) &snmpInBadCommunityUses_instance;
+}
+
+
+unsigned char *
+var_snmpInASNParseErrs(int *var_len,
+	snmp_info_t *mesg, int (**write_method)()	)
+{
+extern long	snmpInASNParseErrs_instance;
+
+    *write_method = 0;
+    *var_len = sizeof(long);
+    return (unsigned char *) &snmpInASNParseErrs_instance;
+}
+
+/*
+int	write_snmpEnableAuthenTraps(int action,
+	unsigned char *var_val, unsigned char varval_type, int var_val_len
+	unsigned char *statP, oid *name, int name_len)
+{
+    switch (action) {
+    case RESERVE1:
+    case RESERVE2:
+    case COMMIT:
+    case FREE:
+    }
+}
+*/
+
+unsigned char *
+var_snmpEnableAuthenTraps(int *var_len,
+	snmp_info_t *mesg, int (**write_method)()	)
+{
+extern long	snmpEnableAuthenTraps_instance;
+
+/* Set now only to disabled TBD */
+    snmpEnableAuthenTraps_instance = 2;
+    *write_method = 0;
+    *var_len = sizeof(long);
+    return (unsigned char *) &snmpEnableAuthenTraps_instance;
+}
+
+unsigned char *
+var_snmpSilentDrops(int *var_len,
+	snmp_info_t *mesg, int (**write_method)()	)
+{
+ extern long	snmpSilentDrops_instance;
+ 
+    *write_method = 0;
+    *var_len = sizeof(long);
+    return (unsigned char *) &snmpSilentDrops_instance;
+}
+
+unsigned char *
+var_snmpProxyDrops(int *var_len,
+	snmp_info_t *mesg, int (**write_method)()	)
+{
+extern long	snmpProxyDrops_instance;
+
+    *write_method = 0;
+    *var_len = sizeof(long);
+    return (unsigned char *) &snmpProxyDrops_instance;
+}
+
+unsigned char *
+var_snmpTrapOID(int *var_len,
+	snmp_info_t *mesg, int (**write_method)()	)
+{
+    /* Determine additional access-rights */
+    /* Add additional value computations */
+
+    /* Set write-function */
+    *write_method = 0;
+    /* Set size of the variable (in bytes) */
+    *var_len = sizeof(long);
+    /* Return the value (address pointer)*/
+    return (unsigned char *) NULL;
+}
+
+unsigned char *
+var_snmpTrapEnterprise(int *var_len,
+	snmp_info_t *mesg, int (**write_method)()	)
+{
+    /* Determine additional access-rights */
+    /* Add additional value computations */
+
+    /* Set write-function */
+    *write_method = 0;
+    /* Set size of the variable (in bytes) */
+    *var_len = sizeof(long);
+    /* Return the value (address pointer)*/
+    return (unsigned char *) NULL;
+}
+/*
+int	write_snmpSetSerialNo(int action,
+	unsigned char *var_val, unsigned char varval_type, int var_val_len
+	unsigned char *statP, oid *name, int name_len)
+{
+    switch (action) {
+    case RESERVE1:
+    case RESERVE2:
+    case COMMIT:
+    case FREE:
+    }
+}
+*/
+
+unsigned char *
+var_snmpSetSerialNo(int *var_len,
+	snmp_info_t *mesg, int (**write_method)()	)
+{
+    /* Determine additional access-rights */
+    /* Add additional value computations */
+
+    /* Set write-function */
+    *write_method = 0;
+    /* Set size of the variable (in bytes) */
+    *var_len = sizeof(long);
+    /* Return the value (address pointer)*/
+    return (unsigned char *) NULL;
+}
+
+unsigned char *
+var_snmpOutPkts(int *var_len,
+	snmp_info_t *mesg, int (**write_method)()	)
+{
+    /* Determine additional access-rights */
+    /* Add additional value computations */
+
+    /* Set write-function */
+    *write_method = 0;
+    /* Set size of the variable (in bytes) */
+    *var_len = sizeof(long);
+    /* Return the value (address pointer)*/
+    return (unsigned char *) NULL;
+}
+
+unsigned char *
+var_snmpInTooBigs(int *var_len,
+	snmp_info_t *mesg, int (**write_method)()	)
+{
+    /* Determine additional access-rights */
+    /* Add additional value computations */
+
+    /* Set write-function */
+    *write_method = 0;
+    /* Set size of the variable (in bytes) */
+    *var_len = sizeof(long);
+    /* Return the value (address pointer)*/
+    return (unsigned char *) NULL;
+}
+
+unsigned char *
+var_snmpInNoSuchNames(int *var_len,
+	snmp_info_t *mesg, int (**write_method)()	)
+{
+    /* Determine additional access-rights */
+    /* Add additional value computations */
+
+    /* Set write-function */
+    *write_method = 0;
+    /* Set size of the variable (in bytes) */
+    *var_len = sizeof(long);
+    /* Return the value (address pointer)*/
+    return (unsigned char *) NULL;
+}
+
+unsigned char *
+var_snmpInBadValues(int *var_len,
+	snmp_info_t *mesg, int (**write_method)()	)
+{
+    /* Determine additional access-rights */
+    /* Add additional value computations */
+
+    /* Set write-function */
+    *write_method = 0;
+    /* Set size of the variable (in bytes) */
+    *var_len = sizeof(long);
+    /* Return the value (address pointer)*/
+    return (unsigned char *) NULL;
+}
+
+unsigned char *
+var_snmpInReadOnlys(int *var_len,
+	snmp_info_t *mesg, int (**write_method)()	)
+{
+    /* Determine additional access-rights */
+    /* Add additional value computations */
+
+    /* Set write-function */
+    *write_method = 0;
+    /* Set size of the variable (in bytes) */
+    *var_len = sizeof(long);
+    /* Return the value (address pointer)*/
+    return (unsigned char *) NULL;
+}
+
+unsigned char *
+var_snmpInGenErrs(int *var_len,
+	snmp_info_t *mesg, int (**write_method)()	)
+{
+    /* Determine additional access-rights */
+    /* Add additional value computations */
+
+    /* Set write-function */
+    *write_method = 0;
+    /* Set size of the variable (in bytes) */
+    *var_len = sizeof(long);
+    /* Return the value (address pointer)*/
+    return (unsigned char *) NULL;
+}
+
+unsigned char *
+var_snmpInTotalReqVars(int *var_len,
+	snmp_info_t *mesg, int (**write_method)()	)
+{
+    /* Determine additional access-rights */
+    /* Add additional value computations */
+
+    /* Set write-function */
+    *write_method = 0;
+    /* Set size of the variable (in bytes) */
+    *var_len = sizeof(long);
+    /* Return the value (address pointer)*/
+    return (unsigned char *) NULL;
+}
+
+unsigned char *
+var_snmpInTotalSetVars(int *var_len,
+	snmp_info_t *mesg, int (**write_method)()	)
+{
+    /* Determine additional access-rights */
+    /* Add additional value computations */
+
+    /* Set write-function */
+    *write_method = 0;
+    /* Set size of the variable (in bytes) */
+    *var_len = sizeof(long);
+    /* Return the value (address pointer)*/
+    return (unsigned char *) NULL;
+}
+
+unsigned char *
+var_snmpInGetRequests(int *var_len,
+	snmp_info_t *mesg, int (**write_method)()	)
+{
+    /* Determine additional access-rights */
+    /* Add additional value computations */
+
+    /* Set write-function */
+    *write_method = 0;
+    /* Set size of the variable (in bytes) */
+    *var_len = sizeof(long);
+    /* Return the value (address pointer)*/
+    return (unsigned char *) NULL;
+}
+
+unsigned char *
+var_snmpInGetNexts(int *var_len,
+	snmp_info_t *mesg, int (**write_method)()	)
+{
+    /* Determine additional access-rights */
+    /* Add additional value computations */
+
+    /* Set write-function */
+    *write_method = 0;
+    /* Set size of the variable (in bytes) */
+    *var_len = sizeof(long);
+    /* Return the value (address pointer)*/
+    return (unsigned char *) NULL;
+}
+
+unsigned char *
+var_snmpInSetRequests(int *var_len,
+	snmp_info_t *mesg, int (**write_method)()	)
+{
+    /* Determine additional access-rights */
+    /* Add additional value computations */
+
+    /* Set write-function */
+    *write_method = 0;
+    /* Set size of the variable (in bytes) */
+    *var_len = sizeof(long);
+    /* Return the value (address pointer)*/
+    return (unsigned char *) NULL;
+}
+
+unsigned char *
+var_snmpInGetResponses(int *var_len,
+	snmp_info_t *mesg, int (**write_method)()	)
+{
+    /* Determine additional access-rights */
+    /* Add additional value computations */
+
+    /* Set write-function */
+    *write_method = 0;
+    /* Set size of the variable (in bytes) */
+    *var_len = sizeof(long);
+    /* Return the value (address pointer)*/
+    return (unsigned char *) NULL;
+}
+
+unsigned char *
+var_snmpInTraps(int *var_len,
+	snmp_info_t *mesg, int (**write_method)()	)
+{
+    /* Determine additional access-rights */
+    /* Add additional value computations */
+
+    /* Set write-function */
+    *write_method = 0;
+    /* Set size of the variable (in bytes) */
+    *var_len = sizeof(long);
+    /* Return the value (address pointer)*/
+    return (unsigned char *) NULL;
+}
+
+unsigned char *
+var_snmpOutTooBigs(int *var_len,
+	snmp_info_t *mesg, int (**write_method)()	)
+{
+    /* Determine additional access-rights */
+    /* Add additional value computations */
+
+    /* Set write-function */
+    *write_method = 0;
+    /* Set size of the variable (in bytes) */
+    *var_len = sizeof(long);
+    /* Return the value (address pointer)*/
+    return (unsigned char *) NULL;
+}
+
+unsigned char *
+var_snmpOutNoSuchNames(int *var_len,
+	snmp_info_t *mesg, int (**write_method)()	)
+{
+    /* Determine additional access-rights */
+    /* Add additional value computations */
+
+    /* Set write-function */
+    *write_method = 0;
+    /* Set size of the variable (in bytes) */
+    *var_len = sizeof(long);
+    /* Return the value (address pointer)*/
+    return (unsigned char *) NULL;
+}
+
+unsigned char *
+var_snmpOutBadValues(int *var_len,
+	snmp_info_t *mesg, int (**write_method)()	)
+{
+    /* Determine additional access-rights */
+    /* Add additional value computations */
+
+    /* Set write-function */
+    *write_method = 0;
+    /* Set size of the variable (in bytes) */
+    *var_len = sizeof(long);
+    /* Return the value (address pointer)*/
+    return (unsigned char *) NULL;
+}
+
+unsigned char *
+var_snmpOutGenErrs(int *var_len,
+	snmp_info_t *mesg, int (**write_method)()	)
+{
+    /* Determine additional access-rights */
+    /* Add additional value computations */
+
+    /* Set write-function */
+    *write_method = 0;
+    /* Set size of the variable (in bytes) */
+    *var_len = sizeof(long);
+    /* Return the value (address pointer)*/
+    return (unsigned char *) NULL;
+}
+
+unsigned char *
+var_snmpOutGetRequests(int *var_len,
+	snmp_info_t *mesg, int (**write_method)()	)
+{
+    /* Determine additional access-rights */
+    /* Add additional value computations */
+
+    /* Set write-function */
+    *write_method = 0;
+    /* Set size of the variable (in bytes) */
+    *var_len = sizeof(long);
+    /* Return the value (address pointer)*/
+    return (unsigned char *) NULL;
+}
+
+unsigned char *
+var_snmpOutGetNexts(int *var_len,
+	snmp_info_t *mesg, int (**write_method)()	)
+{
+    /* Determine additional access-rights */
+    /* Add additional value computations */
+
+    /* Set write-function */
+    *write_method = 0;
+    /* Set size of the variable (in bytes) */
+    *var_len = sizeof(long);
+    /* Return the value (address pointer)*/
+    return (unsigned char *) NULL;
+}
+
+unsigned char *
+var_snmpOutSetRequests(int *var_len,
+	snmp_info_t *mesg, int (**write_method)()	)
+{
+    /* Determine additional access-rights */
+    /* Add additional value computations */
+
+    /* Set write-function */
+    *write_method = 0;
+    /* Set size of the variable (in bytes) */
+    *var_len = sizeof(long);
+    /* Return the value (address pointer)*/
+    return (unsigned char *) NULL;
+}
+
+unsigned char *
+var_snmpOutGetResponses(int *var_len,
+	snmp_info_t *mesg, int (**write_method)()	)
+{
+    /* Determine additional access-rights */
+    /* Add additional value computations */
+
+    /* Set write-function */
+    *write_method = 0;
+    /* Set size of the variable (in bytes) */
+    *var_len = sizeof(long);
+    /* Return the value (address pointer)*/
+    return (unsigned char *) NULL;
+}
+
+unsigned char *
+var_snmpOutTraps(int *var_len,
+	snmp_info_t *mesg, int (**write_method)()	)
+{
+    /* Determine additional access-rights */
+    /* Add additional value computations */
+
+    /* Set write-function */
+    *write_method = 0;
+    /* Set size of the variable (in bytes) */
+    *var_len = sizeof(long);
+    /* Return the value (address pointer)*/
+    return (unsigned char *) NULL;
+}
+
+
+
+static oid system_oid[] = { O_system };
+static Object system_variables[] = {
+    { SNMP_STRING, (RONLY| SCALAR), var_sysDescr,
+                 {2, { I_sysDescr, 0 }}},
+    { SNMP_OBJID, (RONLY| SCALAR), var_sysObjectID,
+                 {2, { I_sysObjectID, 0 }}},
+    { SNMP_TIMETICKS, (RONLY| SCALAR), var_sysUpTime,
+                 {2, { I_sysUpTime, 0 }}},
+    { SNMP_STRING, (RWRITE| SCALAR), var_sysContact,
+                 {2, { I_sysContact, 0 }}},
+    { SNMP_STRING, (RWRITE| SCALAR), var_sysName,
+                 {2, { I_sysName, 0 }}},
+    { SNMP_STRING, (RWRITE| SCALAR), var_sysLocation,
+                 {2, { I_sysLocation, 0 }}},
+    { SNMP_INTEGER, (RONLY| SCALAR), var_sysServices,
+                 {2, { I_sysServices, 0 }}},
+    { SNMP_TIMETICKS, (RONLY| SCALAR), var_sysORLastChange,
+                 {2, { I_sysORLastChange, 0 }}},
+    { SNMP_OBJID, (RONLY| COLUMN), var_sysOREntry,
+                {3, { I_sysORTable, I_sysOREntry, I_sysORID }}},
+    { SNMP_STRING, (RONLY| COLUMN), var_sysOREntry,
+                {3, { I_sysORTable, I_sysOREntry, I_sysORDescr }}},
+    { SNMP_TIMETICKS, (RONLY| COLUMN), var_sysOREntry,
+                {3, { I_sysORTable, I_sysOREntry, I_sysORUpTime }}},
+    { 0, 0, NULL, {0, {0}} }
+    };
+static SubTree system_tree =  { NULL, system_variables,
+	        (sizeof(system_oid)/sizeof(oid)), system_oid};
+
+static oid snmp_oid[] = { O_snmp };
+static Object snmp_variables[] = {
+    { SNMP_COUNTER, (RONLY| SCALAR), var_snmpInPkts,
+                 {2, { I_snmpInPkts, 0 }}},
+    { SNMP_COUNTER, (RONLY| SCALAR), var_snmpInBadVersions,
+                 {2, { I_snmpInBadVersions, 0 }}},
+    { SNMP_COUNTER, (RONLY| SCALAR), var_snmpInBadCommunityNames,
+                 {2, { I_snmpInBadCommunityNames, 0 }}},
+    { SNMP_COUNTER, (RONLY| SCALAR), var_snmpInBadCommunityUses,
+                 {2, { I_snmpInBadCommunityUses, 0 }}},
+    { SNMP_COUNTER, (RONLY| SCALAR), var_snmpInASNParseErrs,
+                 {2, { I_snmpInASNParseErrs, 0 }}},
+    { SNMP_INTEGER, (RWRITE| SCALAR), var_snmpEnableAuthenTraps,
+                 {2, { I_snmpEnableAuthenTraps, 0 }}},
+    { SNMP_COUNTER, (RONLY| SCALAR), var_snmpSilentDrops,
+                 {2, { I_snmpSilentDrops, 0 }}},
+    { SNMP_COUNTER, (RONLY| SCALAR), var_snmpProxyDrops,
+                 {2, { I_snmpProxyDrops, 0 }}},
+    { 0, 0, NULL, {0, {0}}}
+    };
+static SubTree snmp_tree =  { NULL, snmp_variables,
+	        (sizeof(snmp_oid)/sizeof(oid)), snmp_oid};
+/*
+ * static oid snmpSet_oid[] = { O_snmpSet };
+ * static Object snmpSet_variables[] = {
+ *     { SNMP_INTEGER, (RWRITE| SCALAR), var_snmpSetSerialNo,
+ *                  {2, { I_snmpSetSerialNo, 0 }}},
+ *     { NULL }
+ *     };
+ * static SubTree snmpSet_tree =  { NULL, snmpSet_variables,
+ *                  (sizeof(snmpSet_oid)/sizeof(oid)), snmpSet_oid};
+ */
+
+/* This is the MIB registration function. This should be called */
+/* within the init_SNMPv2_MIB-function */
+void register_subtrees_of_SNMPv2_MIB()
+{
+    insert_group_in_mib(&system_tree);
+    insert_group_in_mib(&snmp_tree);
+/*  insert_group_in_mib(&snmpSet_tree); */
+}
diff -ru -ruN apache_1.3.34_orig/src/modules/snmp_agt/snmpv2-mib.h apache_1.3.34/src/modules/snmp_agt/snmpv2-mib.h
--- apache_1.3.34_orig/src/modules/snmp_agt/snmpv2-mib.h	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/src/modules/snmp_agt/snmpv2-mib.h	2006-05-18 16:49:19.299763192 +0200
@@ -0,0 +1,355 @@
+/* ====================================================================
+ * Copyright (c) 1997-2000 Harrie Hazewinkel.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by Harrie Hazewinkel."
+ *
+ * 4. The name of the Copyright holder must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission.
+ *
+ * 5. Products derived from this software may not be called "MOD-SNMP"
+ *    nor may "MOD-SNMP" appear in their names  without prior written
+ *    permission of the Harrie Hazewinkel.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the Harrie Hazewinkel"
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * The creator of this module is Harrie.Hazewinkel@bigfoot.com
+ * This file contains generated code of SMASH also created by Harrie.
+ *
+ *
+ */
+
+#ifndef _SNMPv2_MIB_
+#define	_SNMPv2_MIB_
+
+/* required include files (IMPORTS) */
+#include        "snmpv2-conf.h"
+#include        "snmpv2-tc.h"
+#include        "snmpv2-smi.h"
+
+
+void init_SNMPv2_MIB();
+void register_subtrees_of_SNMPv2_MIB();
+
+/* defined objects in this module */
+
+void init_snmpv2_mib();
+
+/* MIB object snmpMIB = snmpModules, 1 */
+#define	I_snmpMIB	1
+#define	O_snmpMIB	1, 3, 6, 1, 6, 3, 1
+
+/* MIB object snmpMIBObjects = snmpMIB, 1 */
+#define	I_snmpMIBObjects	1
+#define	O_snmpMIBObjects	1, 3, 6, 1, 6, 3, 1, 1
+
+/* MIB object system = mib_2, 1 */
+#define	I_system	1
+#define	O_system	1, 3, 6, 1, 2, 1, 1
+
+/* MIB object sysDescr = system, 1 */
+#define	I_sysDescr	1
+#define	O_sysDescr	1, 3, 6, 1, 2, 1, 1, 1
+
+/* MIB object sysObjectID = system, 2 */
+#define	I_sysObjectID	2
+#define	O_sysObjectID	1, 3, 6, 1, 2, 1, 1, 2
+
+/* MIB object sysUpTime = system, 3 */
+#define	I_sysUpTime	3
+#define	O_sysUpTime	1, 3, 6, 1, 2, 1, 1, 3
+unsigned long	current_sysUpTime();
+unsigned long	time2sysUpTime(time_t theTime);
+int	sysUpTime2DateAndTime(unsigned long sysUpTime, char *dateAndTime);
+
+/* MIB object sysContact = system, 4 */
+#define	I_sysContact	4
+#define	O_sysContact	1, 3, 6, 1, 2, 1, 1, 4
+
+/* MIB object sysName = system, 5 */
+#define	I_sysName	5
+#define	O_sysName	1, 3, 6, 1, 2, 1, 1, 5
+
+/* MIB object sysLocation = system, 6 */
+#define	I_sysLocation	6
+#define	O_sysLocation	1, 3, 6, 1, 2, 1, 1, 6
+
+/* MIB object sysServices = system, 7 */
+#define	I_sysServices	7
+#define	O_sysServices	1, 3, 6, 1, 2, 1, 1, 7
+
+/* MIB object sysORLastChange = system, 8 */
+#define	I_sysORLastChange	8
+#define	O_sysORLastChange	1, 3, 6, 1, 2, 1, 1, 8
+
+/* MIB object sysORTable = system, 9 */
+#define	I_sysORTable	9
+#define	O_sysORTable	1, 3, 6, 1, 2, 1, 1, 9
+
+/* MIB object sysOREntry = sysORTable, 1 */
+#define	I_sysOREntry	1
+#define	O_sysOREntry	1, 3, 6, 1, 2, 1, 1, 9, 1
+struct sysOREntry_struct {
+    struct sysOREntry_struct *next;
+    int                      index;
+    Oid                      oid_value;
+    char                     *descr;
+    unsigned long            lastChange;
+};
+int insert_sysOREntry(struct sysOREntry_struct *value);
+
+#define REGISTER_OBJECT_RESOURCE(objectId_length, objectId, descr) \
+	{ \
+	static struct sysOREntry_struct value = { NULL, 1, {objectId_length, {objectId}}, descr, 0}; \
+	insert_sysOREntry(&value); \
+	}
+
+
+/* MIB object sysORIndex = sysOREntry, 1 */
+#define	I_sysORIndex	1
+#define	O_sysORIndex	1, 3, 6, 1, 2, 1, 1, 9, 1, 1
+
+/* MIB object sysORID = sysOREntry, 2 */
+#define	I_sysORID	2
+#define	O_sysORID	1, 3, 6, 1, 2, 1, 1, 9, 1, 2
+
+/* MIB object sysORDescr = sysOREntry, 3 */
+#define	I_sysORDescr	3
+#define	O_sysORDescr	1, 3, 6, 1, 2, 1, 1, 9, 1, 3
+
+/* MIB object sysORUpTime = sysOREntry, 4 */
+#define	I_sysORUpTime	4
+#define	O_sysORUpTime	1, 3, 6, 1, 2, 1, 1, 9, 1, 4
+
+/* MIB object snmp = mib_2, 11 */
+#define	I_snmp	11
+#define	O_snmp	1, 3, 6, 1, 2, 1, 11
+
+/* MIB object snmpInPkts = snmp, 1 */
+#define	I_snmpInPkts	1
+#define	O_snmpInPkts	1, 3, 6, 1, 2, 1, 11, 1
+
+
+/* MIB object snmpInBadVersions = snmp, 3 */
+#define	I_snmpInBadVersions	3
+#define	O_snmpInBadVersions	1, 3, 6, 1, 2, 1, 11, 3
+
+/* MIB object snmpInBadCommunityNames = snmp, 4 */
+#define	I_snmpInBadCommunityNames	4
+#define	O_snmpInBadCommunityNames	1, 3, 6, 1, 2, 1, 11, 4
+
+/* MIB object snmpInBadCommunityUses = snmp, 5 */
+#define	I_snmpInBadCommunityUses	5
+#define	O_snmpInBadCommunityUses	1, 3, 6, 1, 2, 1, 11, 5
+
+/* MIB object snmpInASNParseErrs = snmp, 6 */
+#define	I_snmpInASNParseErrs	6
+#define	O_snmpInASNParseErrs	1, 3, 6, 1, 2, 1, 11, 6
+
+/* MIB object snmpEnableAuthenTraps = snmp, 30 */
+#define	I_snmpEnableAuthenTraps	30
+#define	O_snmpEnableAuthenTraps	1, 3, 6, 1, 2, 1, 11, 30
+
+/* MIB object snmpSilentDrops = snmp, 31 */
+#define	I_snmpSilentDrops	31
+#define	O_snmpSilentDrops	1, 3, 6, 1, 2, 1, 11, 31
+
+/* MIB object snmpProxyDrops = snmp, 32 */
+#define	I_snmpProxyDrops	32
+#define	O_snmpProxyDrops	1, 3, 6, 1, 2, 1, 11, 32
+
+/* MIB object snmpTrap = snmpMIBObjects, 4 */
+#define	I_snmpTrap	4
+#define	O_snmpTrap	1, 3, 6, 1, 6, 3, 1, 1, 4
+
+/* MIB object snmpTrapOID = snmpTrap, 1 */
+#define	I_snmpTrapOID	1
+#define	O_snmpTrapOID	1, 3, 6, 1, 6, 3, 1, 1, 4, 1
+
+/* MIB object snmpTrapEnterprise = snmpTrap, 3 */
+#define	I_snmpTrapEnterprise	3
+#define	O_snmpTrapEnterprise	1, 3, 6, 1, 6, 3, 1, 1, 4, 3
+
+/* MIB object snmpTraps = snmpMIBObjects, 5 */
+#define	I_snmpTraps	5
+#define	O_snmpTraps	1, 3, 6, 1, 6, 3, 1, 1, 5
+
+/* MIB object coldStart = snmpTraps, 1 */
+#define	I_coldStart	1
+#define	O_coldStart	1, 3, 6, 1, 6, 3, 1, 1, 5, 1
+
+/* MIB object warmStart = snmpTraps, 2 */
+#define	I_warmStart	2
+#define	O_warmStart	1, 3, 6, 1, 6, 3, 1, 1, 5, 2
+
+/* MIB object authenticationFailure = snmpTraps, 5 */
+#define	I_authenticationFailure	5
+#define	O_authenticationFailure	1, 3, 6, 1, 6, 3, 1, 1, 5, 5
+
+/* MIB object snmpSet = snmpMIBObjects, 6 */
+#define	I_snmpSet	6
+#define	O_snmpSet	1, 3, 6, 1, 6, 3, 1, 1, 6
+
+/* MIB object snmpSetSerialNo = snmpSet, 1 */
+#define	I_snmpSetSerialNo	1
+#define	O_snmpSetSerialNo	1, 3, 6, 1, 6, 3, 1, 1, 6, 1
+
+/* MIB object snmpMIBConformance = snmpMIB, 2 */
+#define	I_snmpMIBConformance	2
+#define	O_snmpMIBConformance	1, 3, 6, 1, 6, 3, 1, 2
+
+/* MIB object snmpMIBCompliances = snmpMIBConformance, 1 */
+#define	I_snmpMIBCompliances	1
+#define	O_snmpMIBCompliances	1, 3, 6, 1, 6, 3, 1, 2, 1
+
+/* MIB object snmpMIBGroups = snmpMIBConformance, 2 */
+#define	I_snmpMIBGroups	2
+#define	O_snmpMIBGroups	1, 3, 6, 1, 6, 3, 1, 2, 2
+
+/* MIB object snmpBasicCompliance = snmpMIBCompliances, 2 */
+#define	I_snmpBasicCompliance	2
+#define	O_snmpBasicCompliance	1, 3, 6, 1, 6, 3, 1, 2, 1, 2
+
+/* MIB object snmpGroup = snmpMIBGroups, 8 */
+#define	I_snmpGroup	8
+#define	O_snmpGroup	1, 3, 6, 1, 6, 3, 1, 2, 2, 8
+
+/* MIB object snmpCommunityGroup = snmpMIBGroups, 9 */
+#define	I_snmpCommunityGroup	9
+#define	O_snmpCommunityGroup	1, 3, 6, 1, 6, 3, 1, 2, 2, 9
+
+/* MIB object snmpSetGroup = snmpMIBGroups, 5 */
+#define	I_snmpSetGroup	5
+#define	O_snmpSetGroup	1, 3, 6, 1, 6, 3, 1, 2, 2, 5
+
+/* MIB object systemGroup = snmpMIBGroups, 6 */
+#define	I_systemGroup	6
+#define	O_systemGroup	1, 3, 6, 1, 6, 3, 1, 2, 2, 6
+
+/* MIB object snmpBasicNotificationsGroup = snmpMIBGroups, 7 */
+#define	I_snmpBasicNotificationsGroup	7
+#define	O_snmpBasicNotificationsGroup	1, 3, 6, 1, 6, 3, 1, 2, 2, 7
+
+/* MIB object snmpOutPkts = snmp, 2 */
+#define	I_snmpOutPkts	2
+#define	O_snmpOutPkts	1, 3, 6, 1, 2, 1, 11, 2
+
+/* MIB object snmpInTooBigs = snmp, 8 */
+#define	I_snmpInTooBigs	8
+#define	O_snmpInTooBigs	1, 3, 6, 1, 2, 1, 11, 8
+
+/* MIB object snmpInNoSuchNames = snmp, 9 */
+#define	I_snmpInNoSuchNames	9
+#define	O_snmpInNoSuchNames	1, 3, 6, 1, 2, 1, 11, 9
+
+/* MIB object snmpInBadValues = snmp, 10 */
+#define	I_snmpInBadValues	10
+#define	O_snmpInBadValues	1, 3, 6, 1, 2, 1, 11, 10
+
+/* MIB object snmpInReadOnlys = snmp, 11 */
+#define	I_snmpInReadOnlys	11
+#define	O_snmpInReadOnlys	1, 3, 6, 1, 2, 1, 11, 11
+
+/* MIB object snmpInGenErrs = snmp, 12 */
+#define	I_snmpInGenErrs	12
+#define	O_snmpInGenErrs	1, 3, 6, 1, 2, 1, 11, 12
+
+/* MIB object snmpInTotalReqVars = snmp, 13 */
+#define	I_snmpInTotalReqVars	13
+#define	O_snmpInTotalReqVars	1, 3, 6, 1, 2, 1, 11, 13
+
+/* MIB object snmpInTotalSetVars = snmp, 14 */
+#define	I_snmpInTotalSetVars	14
+#define	O_snmpInTotalSetVars	1, 3, 6, 1, 2, 1, 11, 14
+
+/* MIB object snmpInGetRequests = snmp, 15 */
+#define	I_snmpInGetRequests	15
+#define	O_snmpInGetRequests	1, 3, 6, 1, 2, 1, 11, 15
+
+/* MIB object snmpInGetNexts = snmp, 16 */
+#define	I_snmpInGetNexts	16
+#define	O_snmpInGetNexts	1, 3, 6, 1, 2, 1, 11, 16
+
+/* MIB object snmpInSetRequests = snmp, 17 */
+#define	I_snmpInSetRequests	17
+#define	O_snmpInSetRequests	1, 3, 6, 1, 2, 1, 11, 17
+
+/* MIB object snmpInGetResponses = snmp, 18 */
+#define	I_snmpInGetResponses	18
+#define	O_snmpInGetResponses	1, 3, 6, 1, 2, 1, 11, 18
+
+/* MIB object snmpInTraps = snmp, 19 */
+#define	I_snmpInTraps	19
+#define	O_snmpInTraps	1, 3, 6, 1, 2, 1, 11, 19
+
+/* MIB object snmpOutTooBigs = snmp, 20 */
+#define	I_snmpOutTooBigs	20
+#define	O_snmpOutTooBigs	1, 3, 6, 1, 2, 1, 11, 20
+
+/* MIB object snmpOutNoSuchNames = snmp, 21 */
+#define	I_snmpOutNoSuchNames	21
+#define	O_snmpOutNoSuchNames	1, 3, 6, 1, 2, 1, 11, 21
+
+/* MIB object snmpOutBadValues = snmp, 22 */
+#define	I_snmpOutBadValues	22
+#define	O_snmpOutBadValues	1, 3, 6, 1, 2, 1, 11, 22
+
+/* MIB object snmpOutGenErrs = snmp, 24 */
+#define	I_snmpOutGenErrs	24
+#define	O_snmpOutGenErrs	1, 3, 6, 1, 2, 1, 11, 24
+
+/* MIB object snmpOutGetRequests = snmp, 25 */
+#define	I_snmpOutGetRequests	25
+#define	O_snmpOutGetRequests	1, 3, 6, 1, 2, 1, 11, 25
+
+/* MIB object snmpOutGetNexts = snmp, 26 */
+#define	I_snmpOutGetNexts	26
+#define	O_snmpOutGetNexts	1, 3, 6, 1, 2, 1, 11, 26
+
+/* MIB object snmpOutSetRequests = snmp, 27 */
+#define	I_snmpOutSetRequests	27
+#define	O_snmpOutSetRequests	1, 3, 6, 1, 2, 1, 11, 27
+
+/* MIB object snmpOutGetResponses = snmp, 28 */
+#define	I_snmpOutGetResponses	28
+#define	O_snmpOutGetResponses	1, 3, 6, 1, 2, 1, 11, 28
+
+/* MIB object snmpOutTraps = snmp, 29 */
+#define	I_snmpOutTraps	29
+#define	O_snmpOutTraps	1, 3, 6, 1, 2, 1, 11, 29
+
+/* MIB object snmpObsoleteGroup = snmpMIBGroups, 10 */
+#define	I_snmpObsoleteGroup	10
+#define	O_snmpObsoleteGroup	1, 3, 6, 1, 6, 3, 1, 2, 2, 10
+
+#endif	/* _SNMPv2_MIB_ */
diff -ru -ruN apache_1.3.34_orig/src/modules/snmp_agt/snmpv2-smi.h apache_1.3.34/src/modules/snmp_agt/snmpv2-smi.h
--- apache_1.3.34_orig/src/modules/snmp_agt/snmpv2-smi.h	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/src/modules/snmp_agt/snmpv2-smi.h	2006-05-18 16:49:19.294763952 +0200
@@ -0,0 +1,115 @@
+/* ====================================================================
+ * Copyright (c) 1997-2000 Harrie Hazewinkel.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by Harrie Hazewinkel."
+ *
+ * 4. The name of the Copyright holder must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission.
+ *
+ * 5. Products derived from this software may not be called "MOD-SNMP"
+ *    nor may "MOD-SNMP" appear in their names  without prior written
+ *    permission of the Harrie Hazewinkel.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the Harrie Hazewinkel"
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * The creator of this module is Harrie.Hazewinkel@bigfoot.com
+ * This file contains generated code of SMASH also created by Harrie.
+ *
+ *
+ */
+
+#ifndef	_SNMPv2_SMI_
+#define	_SNMPv2_SMI_
+
+/* required include files (IMPORTS) */
+/* defined objects in this module */
+
+
+/* MIB object org = iso, 3 */
+#define	I_org	3
+#define	O_org	1, 3
+
+/* MIB object dod = org, 6 */
+#define	I_dod	6
+#define	O_dod	1, 3, 6
+
+/* MIB object internet = dod, 1 */
+#define	I_internet	1
+#define	O_internet	1, 3, 6, 1
+
+/* MIB object directory = internet, 1 */
+#define	I_directory	1
+#define	O_directory	1, 3, 6, 1, 1
+
+/* MIB object mgmt = internet, 2 */
+#define	I_mgmt	2
+#define	O_mgmt	1, 3, 6, 1, 2
+
+/* MIB object mib_2 = mgmt, 1 */
+#define	I_mib_2	1
+#define	O_mib_2	1, 3, 6, 1, 2, 1
+
+/* MIB object experimental = internet, 3 */
+#define	I_experimental	3
+#define	O_experimental	1, 3, 6, 1, 3
+
+/* MIB object private = internet, 4 */
+#define	I_private	4
+#define	O_private	1, 3, 6, 1, 4
+
+/* MIB object enterprises = private, 1 */
+#define	I_enterprises	1
+#define	O_enterprises	1, 3, 6, 1, 4, 1
+
+/* MIB object security = internet, 5 */
+#define	I_security	5
+#define	O_security	1, 3, 6, 1, 5
+
+/* MIB object snmpV2 = internet, 6 */
+#define	I_snmpV2	6
+#define	O_snmpV2	1, 3, 6, 1, 6
+
+/* MIB object snmpDomains = snmpV2, 1 */
+#define	I_snmpDomains	1
+#define	O_snmpDomains	1, 3, 6, 1, 6, 1
+
+/* MIB object snmpProxys = snmpV2, 2 */
+#define	I_snmpProxys	2
+#define	O_snmpProxys	1, 3, 6, 1, 6, 2
+
+/* MIB object snmpModules = snmpV2, 3 */
+#define	I_snmpModules	3
+#define	O_snmpModules	1, 3, 6, 1, 6, 3
+
+#endif	/* _SNMPv2_SMI_ */
diff -ru -ruN apache_1.3.34_orig/src/modules/snmp_agt/snmpv2-tc.c apache_1.3.34/src/modules/snmp_agt/snmpv2-tc.c
--- apache_1.3.34_orig/src/modules/snmp_agt/snmpv2-tc.c	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/src/modules/snmp_agt/snmpv2-tc.c	2006-05-18 16:49:19.296763648 +0200
@@ -0,0 +1,80 @@
+/* ====================================================================
+ * Copyright (c) 1997-2000 Harrie Hazewinkel.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by Harrie Hazewinkel."
+ *
+ * 4. The name of the Copyright holder must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission.
+ *
+ * 5. Products derived from this software may not be called "MOD-SNMP"
+ *    nor may "MOD-SNMP" appear in their names  without prior written
+ *    permission of the Harrie Hazewinkel.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the Harrie Hazewinkel"
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * The creator of this module is harrie@mod-snmp.com
+ * This file contains generated code of SMASH also created by Harrie.
+ *
+ *
+ */
+#include <time.h>
+
+#include "httpd.h"
+
+#include "snmpv2-tc.h"
+
+int
+snmp_time2DateAndTime(time_t theTime, char *dateAndTime)
+{
+struct tm       *gmt;
+
+    if (theTime) {
+	gmt = gmtime(&theTime); 
+
+	dateAndTime[0] = (char)((gmt->tm_year + 1900) / 256);
+	dateAndTime[1] = (char)((gmt->tm_year + 1900) % 256);
+	dateAndTime[2] = (char)gmt->tm_mon + 1;
+	dateAndTime[3] = (char)gmt->tm_mday;
+	dateAndTime[4] = (char)gmt->tm_hour;
+	dateAndTime[5] = (char)gmt->tm_min;
+	dateAndTime[6] = (gmt->tm_sec<60?gmt->tm_sec:60);
+	dateAndTime[7] = 0;
+    } else {
+	memset(dateAndTime, 0, 8);
+	dateAndTime[2] = 1;
+	dateAndTime[3] = 1;
+    }
+    return(8);
+}
+
diff -ru -ruN apache_1.3.34_orig/src/modules/snmp_agt/snmpv2-tc.h apache_1.3.34/src/modules/snmp_agt/snmpv2-tc.h
--- apache_1.3.34_orig/src/modules/snmp_agt/snmpv2-tc.h	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/src/modules/snmp_agt/snmpv2-tc.h	2006-05-18 16:49:19.296763648 +0200
@@ -0,0 +1,61 @@
+/* ====================================================================
+ * Copyright (c) 1997-2000 Harrie Hazewinkel.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by Harrie Hazewinkel."
+ *
+ * 4. The name of the Copyright holder must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission.
+ *
+ * 5. Products derived from this software may not be called "MOD-SNMP"
+ *    nor may "MOD-SNMP" appear in their names  without prior written
+ *    permission of the Harrie Hazewinkel.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the Harrie Hazewinkel"
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * The creator of this module is Harrie.Hazewinkel@bigfoot.com
+ * This file contains generated code of SMASH also created by Harrie.
+ *
+ *
+ */
+#ifndef	_SNMPv2_TC_
+#define	_SNMPv2_TC_
+
+/* required include files (IMPORTS) */
+#include	"snmpv2-smi.h"
+/* defined objects in this module */
+
+int snmp_time2DateAndTime(time_t theTime, char *dateAndTime);
+
+
+#endif	/* _SNMPv2_TC_ */
diff -ru -ruN apache_1.3.34_orig/src/modules/snmp_agt/src_snmp/agt_engine.c apache_1.3.34/src/modules/snmp_agt/src_snmp/agt_engine.c
--- apache_1.3.34_orig/src/modules/snmp_agt/src_snmp/agt_engine.c	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/src/modules/snmp_agt/src_snmp/agt_engine.c	2006-05-18 16:49:19.297763496 +0200
@@ -0,0 +1,805 @@
+/* ====================================================================
+ * Copyright (c) 1997-2000
+ *                      SMASH, Harrie Hazewinkel.  All rights reserved.
+ *
+ * This product is developed by Harrie Hazewinkel and updates the
+ * original SMUT compiler made as his graduation project at the
+ * University of Twente.
+ *
+ * SMASH is a software package containing an SNMP MIB compiler and
+ * an SNMP agent system. The package can be used for development
+ * of monolithic SNMP agents and contains a compiler which compiles
+ * MIB definitions into C-code to developed an SNMP agent.
+ * More information about him and this software product can
+ * be found on http://www.simpleweb.org/software/packages/smash/.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by Harrie Hazewinkel"
+ *
+ * 4. The name of the Copyright holder must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission.
+ *
+ * 5. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by Harrie Hazewinkel"
+ *    Also thanked are:
+ *    - The Simple group of the University of Twente,
+ *          http://www.simpleweb.org/
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR, ITS DISTRIBUTORS
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================*/
+
+/* Apache configuration include */
+#include "ap_config.h"
+
+/* General includes */
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <errno.h>
+#include <ctype.h>
+#include <string.h>
+
+/* SNMP engine includes */
+#include "snmp_config.h"
+#include "asn1.h"
+#include "snmp.h"
+#include "agt_mib.h"
+#include "agt_engine.h"
+#include "snmp_community.h"
+
+#ifdef SNMP_GROUP
+long	snmpInPkts_instance;
+long	snmpInBadVersions_instance;
+long	snmpInBadCommunityNames_instance;
+long	snmpInBadCommunityUses_instance;
+long	snmpInASNParseErrs_instance;
+long	snmpEnableAuthenTraps_instance;
+long	snmpSilentDrops_instance;
+long	snmpProxyDrops_instance;
+#endif
+
+int	debug_packet = 0;
+
+void	snmp_print_message(unsigned char *msg, int msglength)
+{
+int     i = 0;
+
+    if (!(msglength)) {
+        msglength = 10;
+    }
+
+    for (i=0; i< msglength ; i++) {
+        if (!(i % 10)) fprintf(stderr, "\n%4.0d : ", i);
+        if ( isprint(*msg) ) {
+	     fprintf(stderr, "%02X '%c'  ", *msg, *msg);
+        } else {
+	     fprintf(stderr, "%02X '_'  ", *msg);
+        }
+        msg++;
+    }
+    fprintf(stderr, "\n");
+}
+
+/*
+ * snmp_parse_version(unsigned char *snmp_data, int *length, long *version)
+ * Parses SEQUENCE hedaer and first integer (should be version)
+ * On success it returns a pointer to the next ASN.1 field
+ * If it fails it returns NULL.
+ * The SNMP-version is returned in the 'version'-variable
+ */
+unsigned char  *
+snmp_parse_version(unsigned char *snmp_data, int *length, long *version)
+{
+unsigned char    type;
+
+    snmp_data = asn_parse_header(snmp_data, length, &type);
+    if (snmp_data == NULL){
+	PRINT_ERROR("bad header");
+	return NULL;
+    }
+    if (type != (ASN_SEQUENCE | ASN_CONSTRUCTOR)){
+	PRINT_ERROR("wrong auth header type");
+	return NULL;
+    }
+    snmp_data = asn_parse_int(snmp_data, length, &type,
+					version, sizeof(*version));
+    return (unsigned char *)snmp_data;
+}
+
+void map_types_smiv2_to_smiv1(unsigned char *smi_type)
+{
+/* This is empty, but need to be sorted out. */
+}
+
+void map_errorstatus_snmpv2_to_snmpv1(long *error_status)
+{
+    switch (*error_status) {
+	case SNMP_ERROR_WRONGTYPE:
+	case SNMP_ERROR_WRONGLENGTH:
+	case SNMP_ERROR_WRONGENCODING:
+	case SNMP_ERROR_WRONGVALUE:
+	case SNMP_ERROR_INCONSISTENTVALUE:
+	    *error_status = SNMP_ERROR_BADVALUE;
+	    break;
+	case SNMP_ERROR_NOACCESS:
+	case SNMP_ERROR_NOTWRITABLE:
+	case SNMP_ERROR_NOCREATION:
+	case SNMP_ERROR_INCONSISTENTNAME:
+	case SNMP_ERROR_AUTHORIZATIONERROR:
+	    *error_status = SNMP_ERROR_NOSUCHNAME;
+	    break;
+	case SNMP_ERROR_RESOURCEUNAVAILABLE:
+	case SNMP_ERROR_COMMITFAILED:
+	case SNMP_ERROR_UNDOFAILED:
+	    *error_status = SNMP_ERROR_GENERR;
+	    break;
+	default:
+            break;
+    }
+}
+
+int
+goodValue( unsigned char inType, int inLen,
+    unsigned char actualType, int actualLen)
+{
+    if (inLen > actualLen)
+	return FALSE;
+    return (inType == actualType);
+}
+
+
+/*
+ * snmp_parse_list_of_varbindings(
+ *    unsigned char *data, int length,
+ *    unsigned char *out_data, int out_length,
+ *   long non_repeaters, long *error_index,
+ *   raw_snmp_info_t *raw_mesg, int action)
+ *
+ * NOTE: error_index CONTAINS in the beginning the max_repetitions!!!!!!!
+ */
+int
+snmp_parse_list_of_varbindings(
+    unsigned char *data, int length,
+    unsigned char *out_data, int out_length,
+    long non_repeaters, long *error_index,
+    raw_snmp_info_t *raw_mesg, int action)
+{
+long			max_repetitions = *error_index;
+unsigned char		*out_data_save;
+int			out_length_save;
+Oid			var_oid[10];
+int			var_val_len;
+unsigned char		var_val_type, *var_val, statType;
+register unsigned char	*statP;
+int			statLen;
+unsigned short		acl;
+int			searchType, err;
+int			(*write_method)();
+int			noSuchObject;
+int			msg_full = FALSE;
+int			repeaterIndex;
+int			number_of_repeaters;
+snmp_info_t		*mesg = &(raw_mesg->mesg);
+
+    if ((mesg->pdutype == SNMP_GETNEXT_REQ_PDU) ||
+        (mesg->pdutype == SNMP_GETBULK_REQ_PDU)) {
+	searchType = NEXT;
+    } else {
+	searchType = EXACT;
+    }
+    
+
+    *error_index = 1;
+    while(((int)length > 0) && (non_repeaters > 0)){     
+	var_oid[0].namelen = MAX_OID_LEN;
+	data = snmp_parse_varbind(data, &(var_oid[0]), &var_val_type,
+				 &var_val_len, &var_val, (int *)&length);
+	if (data == NULL)
+	    return PARSE_ERROR;
+	    
+	write_method = NULL;	
+	statP = getStatPtr(&(var_oid[0]), &statType, &statLen, &acl, 
+		searchType, &write_method, mesg, &noSuchObject);
+
+	if ( mesg->pdutype == SNMP_SET_REQ_PDU ){
+	    if (!(acl & RWRITE)) {
+		return(SNMP_ERROR_NOTWRITABLE);
+	    }
+	    if (write_method == NULL) {
+		if (statP == NULL) {
+		    return(SNMP_ERROR_NOTWRITABLE);
+		} else {
+		    if (!goodValue(var_val_type, var_val_len, statType, statLen)){
+			return(SNMP_ERROR_WRONGTYPE);
+		    }
+		    return(SNMP_ERROR_NOTWRITABLE);
+		}
+	    } else {
+		err = (*write_method)(action, var_val, var_val_type,
+				     var_val_len, statP, &(var_oid[0]));
+		if (err != SNMP_ERROR_NOERROR) {
+		    return(err);
+		}
+	    }
+	} else {
+	    if (statP == NULL){
+		statLen = 0;
+		if (searchType == EXACT){
+		    if (noSuchObject == TRUE){
+			statType = SNMP_NOSUCHOBJECT;
+		    } else {
+			statType = SNMP_NOSUCHINSTANCE;
+		    }
+		} else {
+		    statType = SNMP_ENDOFMIBVIEW;
+		}
+	    }
+	    if (mesg->version == SNMP_VERSION_1) {
+		map_types_smiv2_to_smiv1(&statType);
+	    }
+            out_data = snmp_build_varbind(out_data, &(var_oid[0]),
+					 statType, statLen, statP,
+					 &out_length);
+	    if (out_data == NULL){
+	        return SNMP_ERROR_TOOBIG;
+	    }
+	}
+	(*error_index)++;
+	non_repeaters--;
+    }
+
+    /* Now we start working on the repeater list */
+    for (number_of_repeaters = 0; ((int)length > 0) && !msg_full && number_of_repeaters < 10 ; number_of_repeaters++) {
+        var_oid[number_of_repeaters].namelen = MAX_OID_LEN;
+        data = snmp_parse_varbind(data, &(var_oid[number_of_repeaters]),
+                                 &var_val_type, &var_val_len, &var_val,
+                                 (int *)&length);
+	RETURN_ON_PARSE_ERROR(data, "");
+
+	statP = getStatPtr(&(var_oid[number_of_repeaters]), &statType, &statLen,
+                           &acl, NEXT, &write_method, mesg, &noSuchObject);
+        if (statP == NULL) {
+            statType = SNMP_ENDOFMIBVIEW;
+	    statLen = 0;
+	}
+
+        out_data_save = out_data;
+        out_length_save = out_length;
+	if (mesg->version == SNMP_VERSION_1) {
+	    map_types_smiv2_to_smiv1(&statType);
+	}
+        out_data = snmp_build_varbind(out_data, &(var_oid[number_of_repeaters]),
+                                     statType, statLen, statP,
+                                     &out_length);
+	if (statType == SNMP_ENDOFMIBVIEW) {
+	    var_oid[number_of_repeaters].namelen = 0;
+	}
+        if (out_data == NULL){
+            out_data = out_data_save;
+            out_length = out_length_save;
+            msg_full = TRUE;
+        }
+    }
+
+    while (--max_repetitions > 0) {
+        for (repeaterIndex = 0; repeaterIndex < number_of_repeaters  && !msg_full ; repeaterIndex++) {
+	    if (var_oid[repeaterIndex].namelen != 0) {
+        	statP = getStatPtr(&(var_oid[repeaterIndex]), &statType, &statLen,
+                               &acl, NEXT, &write_method, mesg, &noSuchObject);
+        	if (statP == NULL)
+		    statType = SNMP_ENDOFMIBVIEW;
+
+		out_data_save = out_data;
+		out_length_save = out_length;
+		if (mesg->version == SNMP_VERSION_1) {
+		    map_types_smiv2_to_smiv1(&statType);
+		}
+		out_data = snmp_build_varbind(out_data, &(var_oid[repeaterIndex]),
+                                         statType, statLen, statP,
+                                         &out_length);
+		if (statType == SNMP_ENDOFMIBVIEW) {
+		    var_oid[repeaterIndex].namelen = 0;
+		}
+		if (out_data == NULL){
+		    out_data = out_data_save;
+		    out_length = out_length_save;
+		    msg_full = TRUE;
+		}
+            }
+        }
+    }
+    raw_mesg->response_packet_end = out_data;
+    *error_index = 0;
+    return SNMP_ERROR_NOERROR;
+}
+
+
+unsigned char *build_snmp_response_without_list_of_varbind(raw_snmp_info_t *pi)
+{
+unsigned char *out_data = pi->response;
+int out_length = SNMP_MAX_MSG_LENGTH;
+long zero = 0;
+
+
+    out_data = asn_build_sequence(out_data, &out_length,
+                (unsigned char)(ASN_SEQUENCE | ASN_CONSTRUCTOR),
+                0);
+    RETURN_ON_BUILD_ERROR (out_data, "build sequence header");
+
+    pi->response_version = out_data;
+    out_data = asn_build_int(out_data, &out_length,
+                (unsigned char)(ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER),
+                &(pi->mesg.version), sizeof(pi->mesg.version));
+    RETURN_ON_BUILD_ERROR (out_data, "build snmp-version");
+
+    out_data = asn_build_string(out_data, &out_length,
+                (unsigned char)(ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_OCTET_STR),
+		pi->mesg.community, pi->mesg.community_length);
+    RETURN_ON_BUILD_ERROR (out_data, "build snmp-version");
+
+    pi->response_pdu = out_data;
+    out_data = asn_build_sequence(out_data, &out_length,
+		(unsigned char)SNMP_GET_RSP_PDU, 0);
+
+    pi->response_request_id = out_data;
+    out_data = asn_build_int(out_data, &out_length, 
+		(unsigned char)(ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER),
+		&(pi->mesg.request_id), sizeof(pi->mesg.request_id));
+    RETURN_ON_BUILD_ERROR(out_data, "build request-id");
+
+    pi->response_error_status = out_data;
+    out_data = asn_build_int(out_data, &out_length, 
+		(unsigned char)(ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER),
+		&zero, sizeof(zero));
+    RETURN_ON_BUILD_ERROR(out_data, "build error_status");
+    
+    pi->response_error_index = out_data;
+    out_data = asn_build_int(out_data, &out_length, 
+		(unsigned char)(ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER),
+		&zero, sizeof(zero));
+    RETURN_ON_BUILD_ERROR(out_data, "build error_index");
+
+    pi->response_varbind_sequence = out_data;
+    out_data = asn_build_sequence(out_data, &out_length,
+                (unsigned char)(ASN_SEQUENCE | ASN_CONSTRUCTOR),
+                0);
+    RETURN_ON_BUILD_ERROR (out_data, "build sequence header");
+
+    return (unsigned char *)out_data;
+}
+
+int correct_snmp_response_with_lengths(raw_snmp_info_t *pi, long error_status, long error_index)
+{
+unsigned char *out_data;
+int out_length;
+
+    if (error_status == SNMP_ERROR_NOERROR) {
+	    out_length = 4;
+	    out_data = asn_build_sequence(pi->response_varbind_sequence, &out_length,
+			(unsigned char)(ASN_SEQUENCE | ASN_CONSTRUCTOR),
+			((pi->response_packet_end - pi->response_varbind_sequence) - 4));
+	    RETURN_ON_BUILD_ERROR(out_data, "correction error varbind length");
+    } else if (error_status == SNMP_ERROR_TOOBIG) {
+	    if (pi->mesg.version == SNMP_VERSION_1) {
+		fprintf(stderr, "Cannot return SNMP_TOOBIG in V1");
+		return(0);
+	    }
+	    error_index = 0; /* Just to make sure it is '0' */
+	    pi->response_packet_end = pi->response_varbind_sequence + 4;
+
+	    out_length = 3;
+	    out_data = asn_build_int(pi->response_error_status, &out_length, 
+		(unsigned char)(ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER),
+		&error_status, sizeof(error_status));
+	    RETURN_ON_BUILD_ERROR(out_data, "build error_status");
+
+	    out_length = 3;
+	    out_data = asn_build_int(pi->response_error_index, &out_length, 
+		(unsigned char)(ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER),
+		&error_index, sizeof(error_index));
+	    RETURN_ON_BUILD_ERROR(out_data, "build error_index");
+    } else if (error_status == PARSE_ERROR) {
+	    #ifdef SNMP_GROUP
+		snmpInASNParseErrs_instance++;
+	    #endif
+	    return(NULL);
+    } else {
+	    /* Make varbindlist identical								*/
+	    /* This is done for the errors as well the SNMP SET (error_status==CREATE_IDENTICAL)	*/
+	    if (error_status == CREATE_IDENTICAL) {
+		error_status = 0;
+	    }
+	    memcpy(pi->response_varbind_sequence, pi->request_varbind_sequence,
+		pi->request_varbind_sequence_length);
+	    pi->response_packet_end = pi->response_varbind_sequence + pi->request_varbind_sequence_length;
+
+	    out_length = 3;
+	    out_data = asn_build_int(pi->response_error_status, &out_length, 
+		(unsigned char)(ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER),
+		&error_status, sizeof(error_status));
+	    RETURN_ON_BUILD_ERROR(out_data, "build error_status");
+
+	    out_length = 3;
+	    out_data = asn_build_int(pi->response_error_index, &out_length, 
+		(unsigned char)(ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER),
+		&error_index, sizeof(error_index));
+	    RETURN_ON_BUILD_ERROR(out_data, "build error_index");
+    }
+
+    out_length = 4;
+    out_data = asn_build_sequence(pi->response, &out_length,
+		(unsigned char)(ASN_SEQUENCE | ASN_CONSTRUCTOR),
+		(pi->response_packet_end - pi->response_version));
+    RETURN_ON_BUILD_ERROR(out_data, "correction error message sequence");
+
+    out_length = 4;
+    out_data = asn_build_sequence(pi->response_pdu, &out_length,
+			SNMP_GET_RSP_PDU,
+			pi->response_packet_end - pi->response_request_id);
+    RETURN_ON_BUILD_ERROR(out_data, "correction error request-id");
+
+    pi->response_length = pi->response_packet_end - pi->response;
+    return pi->response_length;
+}
+
+int	snmp_parse_message(raw_snmp_info_t *pi)
+{
+unsigned char		*in_data = pi->request;
+int			in_length = pi->request_length;
+unsigned char		*out_data = pi->response;
+int			out_length = SNMP_MAX_MSG_LENGTH;
+char			type;
+long			error_status, error_index, dummyindex;
+
+    #ifdef SNMP_GROUP
+	snmpInPkts_instance++;
+    #endif
+
+    in_data = asn_parse_header(in_data, &in_length, &type);
+    RETURN_ON_PARSE_ERROR(in_data, "bad header");
+    if (type != (ASN_SEQUENCE | ASN_CONSTRUCTOR)){
+        PRINT_ERROR("wrong header type");
+        return NULL;
+    }
+    in_data = asn_parse_int(in_data, &in_length, &type,
+                                        &(pi->mesg.version), sizeof(pi->mesg.version));
+    RETURN_ON_PARSE_ERROR(in_data, "");
+
+    switch (pi->mesg.version) {
+	case SNMP_VERSION_1	:
+	case SNMP_VERSION_2C	:
+	    pi->mesg.community_length = MAX_COMMUNITY_LEN;
+	    in_data = snmp_parse_community(in_data, &in_length, &(pi->mesg));
+	    RETURN_ON_PARSE_ERROR(in_data, "");
+	    break;	
+	case SNMP_VERSION_2	:
+	default			:
+	    #ifdef SNMP_GROUP
+		snmpInBadVersions_instance++;
+	    #endif
+	    PRINT_ERROR("Wrong version");
+	    return(0);
+    }
+    in_data = asn_parse_header(in_data, &in_length, &pi->mesg.pdutype);
+    RETURN_ON_PARSE_ERROR(in_data, "");
+
+    switch (pi->mesg.pdutype) {
+	case SNMP_GETBULK_REQ_PDU	:
+	    if (pi->mesg.version == SNMP_VERSION_1) {
+	        PRINT_ERROR("Version 1 does not support a GETBULK");
+	        return(0);
+	    }
+	case SNMP_GET_REQ_PDU	:
+	case SNMP_GETNEXT_REQ_PDU	:
+	case SNMP_SET_REQ_PDU	:
+	    in_data = asn_parse_int(in_data, &in_length, &type, &(pi->mesg.request_id), sizeof(pi->mesg.request_id));
+	    RETURN_ON_PARSE_ERROR(in_data, "");
+	    in_data = asn_parse_int(in_data, &in_length, &type, &error_status, sizeof(error_status));
+	    RETURN_ON_PARSE_ERROR(in_data, "");
+	    in_data = asn_parse_int(in_data, &in_length, &type, &error_index, sizeof(error_index));
+	    RETURN_ON_PARSE_ERROR(in_data, "");
+	    break;
+ 	default			:
+	    PRINT_ERROR("Message type is not supported");
+	    return(0);
+    }
+    pi->request_varbind_sequence = in_data;
+    pi->request_varbind_sequence_length = in_length;
+    in_data = asn_parse_header(in_data, &in_length, &type);
+    RETURN_ON_PARSE_ERROR(in_data, "not enough space for varlist");
+    if (type != (unsigned char)(ASN_SEQUENCE | ASN_CONSTRUCTOR)){
+	PRINT_ERROR("wrong type");
+	return PARSE_ERROR;
+    }
+
+    out_data = build_snmp_response_without_list_of_varbind(pi);
+    RETURN_ON_BUILD_ERROR(out_data, "build error");
+
+    switch (pi->mesg.pdutype) {
+	case SNMP_GETBULK_REQ_PDU:
+	    error_status = snmp_parse_list_of_varbindings(in_data, in_length,
+				out_data, out_length,
+				error_status, &error_index, pi, RESERVE1);
+	    break;
+	case SNMP_GET_REQ_PDU	:
+	case SNMP_GETNEXT_REQ_PDU	:
+	    error_status = snmp_parse_list_of_varbindings(in_data, in_length,
+				out_data, out_length, 9999,
+				&error_index, pi, RESERVE1);
+	    break;
+	case SNMP_SET_REQ_PDU :
+	    error_status = snmp_parse_list_of_varbindings(in_data, in_length,
+				out_data, out_length, 9999,
+				&error_index, pi, CHECK);
+            if (error_status == SNMP_ERROR_NOERROR) {
+	    	error_status = snmp_parse_list_of_varbindings(in_data, in_length,
+				out_data, out_length, 9999,
+				&error_index, pi, COMMIT);
+	    }
+	    if (error_status == SNMP_ERROR_NOERROR) {
+		snmp_parse_list_of_varbindings(in_data, in_length,
+				out_data, out_length,
+				9999, &dummyindex, pi, ACTION);
+		return(correct_snmp_response_with_lengths(pi, CREATE_IDENTICAL, 0));
+	    } else {
+	        snmp_parse_list_of_varbindings(in_data, in_length,
+				out_data, out_length,
+				9999, &dummyindex, pi, FREE);
+	    }
+	    break;
+ 	default :
+ 	    /* This should be not neccessary, because this is earlier checked. */
+	    PRINT_ERROR("Message type is not supported");
+	    return(0);
+    }
+    if (pi->mesg.version == SNMP_VERSION_1) {
+	map_errorstatus_snmpv2_to_snmpv1(&error_status);
+    }
+    return(correct_snmp_response_with_lengths(pi, error_status, error_index));
+}
+
+
+
+
+/*
+ * snmp_process_message(int socket)
+ * Processes an SNMP message.
+ */
+int	snmp_process_message(int snmp_socket)
+{
+    raw_snmp_info_t message;
+
+    memset(&message, 0, sizeof(message));
+
+    /* Read SNMP request */
+    message.originatorAddressLength = sizeof(message.originatorAddress);
+    message.request_length = recvfrom(snmp_socket, message.request, SNMP_MAX_MSG_LENGTH, 0,
+                (struct sockaddr *)&message.originatorAddress, 
+                &message.originatorAddressLength);
+
+    if (message.request_length < 0) {
+        perror("recvfrom");
+        return(0);
+    }
+    if (debug_packet) {
+        fprintf(stderr, "Recieved %d bytes from %s:\n", message.request_length,
+                                inet_ntoa(message.originatorAddress.sin_addr));
+        snmp_print_message(message.request, message.request_length);
+        fprintf(stderr, "\n\n");
+    }
+
+
+    /* process the SNMP request */
+    if (snmp_parse_message(&message) > 0){
+        if (debug_packet){
+            fprintf(stderr, "Return %d bytes to %s:\n", message.response_length,
+                                inet_ntoa(message.originatorAddress.sin_addr));
+            snmp_print_message(message.response, message.response_length);
+            fprintf(stderr, "\n\n");
+        }
+        
+        /* return SNMP response */
+        if (sendto(snmp_socket, (char *)message.response,
+			message.response_length, 0,
+                        (struct sockaddr *)&message.originatorAddress, 
+                        message.originatorAddressLength) < 0){
+                perror("sendto");
+                return(0);
+        }
+
+    }
+    return 1;
+}
+
+
+/*
+ * snmp_open_connection
+ * opens the transport connections used for SNMP.
+ * It opens a UDP port to the network.
+ */
+int     snmp_open_connection(char* snmp_addr, int snmp_port)
+{
+int                     socketDescriptor;
+struct sockaddr_in      mySocketAddress;
+
+#ifdef WIN32
+WSADATA dontcare;
+#endif
+
+    if ( !snmp_port ) {
+        printf("The specified port is '0'\n");
+        exit(1);
+    }
+
+#ifdef WIN32
+    if (WSAStartup (0x0101,&dontcare)) {
+	printf ("error calling stupid Microsoft \"WSAStartup()\" function.\n");
+	exit (1);
+    }
+#endif
+
+    socketDescriptor = socket(AF_INET, SOCK_DGRAM, 0);
+    if (socketDescriptor < 0){
+        perror("socket");
+	printf ("error calling \"socket()\"\n.");
+        exit(2);
+    }
+    
+    mySocketAddress.sin_family = AF_INET;
+    mySocketAddress.sin_addr.s_addr = inet_addr(snmp_addr);
+    if (sizeof (mySocketAddress.sin_port) == 2) {
+	*(short *)&mySocketAddress.sin_port = htons((short) snmp_port);
+    } else if (sizeof (mySocketAddress.sin_port) == 4) {
+      *(long *)&mySocketAddress.sin_port = htonl(snmp_port);
+    } else {
+	abort ();
+    }
+    if (bind(socketDescriptor, (struct sockaddr *)&mySocketAddress,
+                                        sizeof(mySocketAddress))){
+        perror("bind");
+	printf ("error calling \"bind()\"\n.");
+        exit(2);
+    }
+    printf("Port %u succesfully opened.\n", snmp_port);
+
+    return (socketDescriptor);
+}
+
+unsigned char	*
+snmp_parse_varbind(unsigned char *data, Oid *var,
+	unsigned char *var_val_type, int *var_val_len, unsigned char **var_val,
+	int *listlength)
+{
+    unsigned char	varbind_type;
+    int			varbind_len = *listlength;
+    unsigned char	*varbind_start = data;
+
+    data = asn_parse_header(data, &varbind_len, &varbind_type);
+    RETURN_ON_PARSE_ERROR(data, "");
+
+    if (varbind_type != (unsigned char)(ASN_SEQUENCE | ASN_CONSTRUCTOR))
+	return NULL;
+    data = asn_parse_objid(data, &varbind_len, &varbind_type, var->name, &(var->namelen));
+    RETURN_ON_PARSE_ERROR(data, "");
+
+    if (varbind_type != (unsigned char)(ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_OBJECT_ID))
+	return NULL;
+    *var_val = data;	/* save pointer to this object */
+    /* find out what type of object this is */
+    data = asn_parse_header(data, &varbind_len, var_val_type);
+    RETURN_ON_PARSE_ERROR(data, "");
+
+    *var_val_len = varbind_len;
+    data += varbind_len;
+    *listlength -= (int)(data - varbind_start);
+    return data;
+}
+
+unsigned char *
+snmp_build_varbind(data, var_oid, var_val_type, var_val_len,
+		  var_val, listlength)
+    register unsigned char *data;	/* IN - pointer to the beginning of the output buffer */
+    Oid		*var_oid;	/* IN - object id of variable */
+    unsigned char	var_val_type;	/* IN - type of variable */
+    int		var_val_len;	/* IN - length of variable */
+    unsigned char	*var_val;	/* IN - value of variable */
+    register int *listlength;   /* IN/OUT - number of valid bytes left in
+				   output buffer */
+{
+    int		    dummyLen, headerLen;
+    unsigned char	    *dataPtr;
+
+    dummyLen = *listlength;
+    dataPtr = data;
+    data += 4;
+    dummyLen -=4;
+    if (dummyLen < 0)
+	return NULL;
+
+    headerLen = data - dataPtr;
+    *listlength -= headerLen;
+    data = asn_build_objid(data, listlength,
+	    (unsigned char)(ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_OBJECT_ID),
+	    var_oid->name, var_oid->namelen);
+    RETURN_ON_BUILD_ERROR (data, "cannot add objectId in varbind");
+    switch(var_val_type){
+	case ASN_INTEGER:
+	    data = asn_build_int(data, listlength, var_val_type,
+		    (long *)var_val, var_val_len);
+	    break;
+	case SNMP_GAUGE:
+	case SNMP_COUNTER:
+	case SNMP_TIMETICKS:
+	/* case SNMP_UINTEGER: this is covered by SNMP_GAUGE */
+	    data = asn_build_unsigned_int(data, listlength, var_val_type,
+					  (unsigned long *)var_val, var_val_len);
+	    break;
+	case SNMP_COUNTER64:
+	    data = asn_build_unsigned_int64(data, listlength, var_val_type,
+					   (struct counter64 *)var_val,
+					    var_val_len);
+	    break;
+	case ASN_OCTET_STR:
+	case SNMP_IPADDRESS:
+	case SNMP_OPAQUE:
+        case SNMP_NSAP:
+	    data = asn_build_string(data, listlength, var_val_type,
+		    var_val, var_val_len);
+	    break;
+	case ASN_OBJECT_ID:
+	    data = asn_build_objid(data, listlength, var_val_type,
+		    (oid *)var_val, var_val_len / sizeof(oid));
+	    break;
+	case ASN_NULL:
+	    data = asn_build_null(data, listlength, var_val_type);
+	    break;
+	case ASN_BIT_STR:
+	    data = asn_build_bitstring(data, listlength, var_val_type,
+		    var_val, var_val_len);
+	    break;
+	case SNMP_NOSUCHOBJECT:
+	case SNMP_NOSUCHINSTANCE:
+	case SNMP_ENDOFMIBVIEW:
+	    data = asn_build_null(data, listlength, var_val_type);
+	    break;
+	default:
+	    PRINT_ERROR("wrong type");
+	    return NULL;
+    }
+    RETURN_ON_BUILD_ERROR(data, "Wrong ASN.1 sequence built\n");
+    dummyLen = (data - dataPtr) - headerLen;
+
+    asn_build_sequence(dataPtr, &dummyLen,
+		       (unsigned char)(ASN_SEQUENCE | ASN_CONSTRUCTOR), dummyLen);
+    return data;
+}
+
+
diff -ru -ruN apache_1.3.34_orig/src/modules/snmp_agt/src_snmp/agt_engine.h apache_1.3.34/src/modules/snmp_agt/src_snmp/agt_engine.h
--- apache_1.3.34_orig/src/modules/snmp_agt/src_snmp/agt_engine.h	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/src/modules/snmp_agt/src_snmp/agt_engine.h	2006-05-18 16:49:19.298763344 +0200
@@ -0,0 +1,169 @@
+/* ====================================================================
+ * Copyright (c) 1997, 1998,
+ *                      SMASH, Harrie Hazewinkel.  All rights reserved.
+ *
+ * This product is developed by Harrie Hazewinkel and updates the
+ * original SMUT compiler made as his graduation project at the
+ * University of Twente.
+ *
+ * SMASH is a software package containing an SNMP MIB compiler and
+ * an SNMP agent system. The package can be used for development
+ * of monolithic SNMP agents and contains a compiler which compiles
+ * MIB definitions into C-code to developed an SNMP agent.
+ * More information about him and this software product can
+ * be found on http://www-musiq.jrc.it/~harrie/SMASH/.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by Harrie Hazewinkel"
+ *
+ * 4. The name of the Copyright holder must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission.
+ *
+ * 5. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by Harrie Hazewinkel"
+ *    Also acknowledged are:
+ *    - The Simple group of the University of Twente,
+ *          http://wwwsnmp.cs.utwente.nl/
+ *    - The MUSIQ workpackage of the DESIRE project,
+ *          http://www-musiq.jrc.it/
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR, ITS DISTRIBUTORS
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================*/
+ 
+#ifndef _AGT_ENGINE_H_
+#define _AGT_ENGINE_H_
+
+#include "agt_mib.h"
+
+typedef struct {
+    long        version;
+    unsigned char      pdutype;
+
+    /* Access identification info */
+    union {
+	/* SNMPv1 and SNMPv2c community based info */
+	struct {
+	    char                        string[ 64 ];
+	    int                         length;
+	    int                         number;
+	} community_based;
+    } access_info;
+
+    /* message variables */
+    long        request_id;	/* Identifying Request number */
+} snmp_info_t;
+
+#define community		access_info.community_based.string
+#define community_length	access_info.community_based.length
+#define community_id		access_info.community_based.number
+    
+typedef struct {
+    snmp_info_t mesg;
+
+    /* originator address */
+    struct sockaddr_in  originatorAddress;
+    int                 originatorAddressLength;
+
+    /* The SNMP request (BER-encoded data) */
+    int			request_length;
+    unsigned char	request[ SNMP_MAX_MSG_LENGTH ];
+    unsigned char	*request_varbind_sequence;
+    int			request_varbind_sequence_length;
+    
+    /* The SNMP response (BER-encoded data) */
+    unsigned char	*response_version;
+    unsigned char	*response_pdu;
+    unsigned char	*response_request_id;
+    unsigned char	*response_error_index;
+    unsigned char	*response_error_status;
+    unsigned char	*response_varbind_sequence;
+    unsigned char	*response_first_varbind;
+    unsigned char	*response_packet_end;
+    int			response_length;
+    unsigned char	response[ SNMP_MAX_MSG_LENGTH * 2 ];
+} raw_snmp_info_t;
+
+
+int     snmp_open_connection(char* snmp_addr, int snmp_socket);
+int	snmp_process_message(int socket);
+
+/*
+ * Error codes which must not clash with SNMP error codes (all positive).
+ */
+#define CREATE_IDENTICAL	-1
+#define PARSE_ERROR	-2
+#define BUILD_ERROR	-3
+#define GEN_ERROR	-4
+
+#ifndef TRUE
+#define TRUE	1
+#endif
+#ifndef FALSE
+#define FALSE	0
+#endif
+
+#ifdef DEBUG
+#define PRINT_ERROR(string)	fprintf(stderr, "%s(%d): %s\n",__FILE__, __LINE__, string);
+#else
+#define PRINT_ERROR(string)
+#endif
+
+#ifdef SNMP_GROUP
+#define INCR_PARSE_ERRORS		snmpInASNParseErrs_instance++
+#else
+#define INCR_PARSE_ERRORS
+#endif
+
+#define RETURN_ON_PARSE_ERROR(value, s)	if (value == NULL) { \
+						INCR_PARSE_ERRORS; \
+						PRINT_ERROR(s); \
+						return(PARSE_ERROR); \
+					}
+
+#define RETURN_ON_BUILD_ERROR(value, s)	if (value == NULL) { \
+						PRINT_ERROR(s); \
+						return NULL; \
+					}
+#define RETURN_ON_ERROR(value, s)	if (value == NULL) { \
+						PRINT_ERROR(s); \
+						return NULL; \
+					}
+
+
+unsigned char   *
+snmp_parse_varbind(register unsigned char *data, Oid *var_oid,
+                unsigned char *var_val_type, int *var_val_len, unsigned char **var_val,
+                int *listlength);
+
+unsigned char *
+snmp_build_varbind(register unsigned char *data, Oid *var_oid,
+                unsigned char var_val_type, int var_val_len, unsigned char *var_val,
+                register int *listlength);
+
+#endif /* _AGT_ENGINE_H_ */
diff -ru -ruN apache_1.3.34_orig/src/modules/snmp_agt/src_snmp/agt_mib.c apache_1.3.34/src/modules/snmp_agt/src_snmp/agt_mib.c
--- apache_1.3.34_orig/src/modules/snmp_agt/src_snmp/agt_mib.c	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/src/modules/snmp_agt/src_snmp/agt_mib.c	2006-05-18 16:49:19.297763496 +0200
@@ -0,0 +1,251 @@
+/* ====================================================================
+ * Copyright (c) 1997-2000
+ *                      SMASH, Harrie Hazewinkel.  All rights reserved.
+ *
+ * This product is developed by Harrie Hazewinkel and updates the
+ * original SMUT compiler made as his graduation project at the
+ * University of Twente.
+ *
+ * SMASH is a software package containing an SNMP MIB compiler and
+ * an SNMP agent system. The package can be used for development
+ * of monolithic SNMP agents and contains a compiler which compiles
+ * MIB definitions into C-code to developed an SNMP agent.
+ * More information about him and this software product can
+ * be found on http://www.simpleweb.org/packages/software/smash/.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by Harrie Hazewinkel"
+ *
+ * 4. The name of the Copyright holder must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission.
+ *
+ * 5. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by Harrie Hazewinkel"
+ *    Also acknowledged are:
+ *    - The Simple group of the University of Twente,
+ *          http://www.simpleweb.org/
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR, ITS DISTRIBUTORS
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================*/
+/* Apache configuration include */
+#include "ap_config.h"
+
+/* General includes */
+#include <stdio.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+
+/* SNMP engine includes */
+#include "asn1.h"
+#include "snmp.h"
+#include "agt_engine.h"
+#include "agt_mib.h"
+
+oid	null_oid[] = {0, 0};
+long	long_return;
+unsigned char	return_buf[MAX_OCTSTR_LEN];
+
+SubTree *mib_tree = NULL;
+
+int
+internal_compare(int len1, oid *name1, int len2, oid *name2)
+{
+    register int    len;
+
+    /* len = minimum of len1 and len2 */
+    if (len1 < len2)
+	len = len1;
+    else
+	len = len2;
+    /* find first non-matching byte */
+    while(len-- > 0){
+	if (*name1 < *name2)
+	    return -1;
+	if (*name2++ < *name1++)
+	    return 1;
+    }
+    /* bytes match up to length of shorter string */
+    if (len1 < len2)
+	return -1;  /* name1 shorter, so it is "less" */
+    if (len2 < len1)
+	return 1;
+    return 0;	/* both strings are equal */
+}
+
+int
+compare(Oid *var1, Oid *var2)
+{
+    return(internal_compare(var1->namelen, var1->name, var2->namelen, var2->name));
+}
+
+int
+internal_compare_tree(int len1, oid *name1, int len2, oid *name2)
+{
+    register int    len;
+
+    /* len = minimum of len1 and len2 */
+    if (len1 < len2) {
+	len = len1;
+    } else {
+	len = len2;
+    }
+    /* find first non-matching byte */
+    while(len-- > 0){
+	if (*name1 < *name2) {
+	    return -1;
+	}
+	if (*name2++ < *name1++) {
+	    return 1;
+	}
+    }
+    /* bytes match up to length of shorter string */
+    if (len1 < len2) {
+	return -1;  /* name1 shorter, so it is "less" */
+    }
+    /* name1 matches name2 for length of name2, or they are equal */
+    return 0;
+}
+
+int
+compare_tree(Oid *var1, Oid *var2)
+{
+    return(internal_compare_tree(var1->namelen, var1->name, var2->namelen, var2->name));
+}
+
+
+int insert_group_in_mib(SubTree *tree)
+{
+SubTree *current = mib_tree;
+SubTree *prev = NULL;
+int result;
+
+    if (current == NULL) {
+	mib_tree = tree;
+	tree->next = NULL;
+	return(0);
+    }
+    while (current) {
+	result = internal_compare_tree(current->prefix_length, current->prefix, tree->prefix_length, tree->prefix);
+	if (result < 0) {
+	    prev = current;
+	    current = current->next;
+	} else if (result == 0) {
+	    fprintf(stderr, "Cannot insert existing subtree (skip)\n");
+	    return(1);
+	} else {
+	    if (prev) {
+		tree->next = current;
+		prev->next = tree;
+	    } else {
+		mib_tree = tree;
+		tree->next = current;
+	    }
+	    return(0);
+	}
+    }
+    prev->next = tree;
+    return(0);
+}
+
+
+unsigned char  *getStatPtr(Oid *req_oid,
+        unsigned char *type, int *len, unsigned short *acl,
+        int searchType, int (**write_method)(),
+        snmp_info_t *mesg, int *noSuchObject)
+{
+register SubTree   *curr_subtree;
+register Object    *curr_var;
+Oid                object;
+register unsigned char    *access = NULL;
+int                result, treeresult;
+int                prefix_length;
+Oid                save;
+
+  if (searchType == EXACT){
+    memcpy(save.name, req_oid->name, req_oid->namelen * sizeof(oid));
+    save.namelen = req_oid->namelen;
+  }
+  *write_method = NULL;
+  for (curr_subtree = mib_tree; curr_subtree ; curr_subtree = curr_subtree->next) {
+    treeresult = internal_compare_tree(req_oid->namelen, req_oid->name, curr_subtree->prefix_length, curr_subtree->prefix);
+    /* if (searchType == EXACT and treeresult == 0) OR
+     *    (searchType == NEXT  and treeresult <= 0) */
+    if (treeresult == 0 || ((searchType == NEXT) && treeresult < 0)){
+      prefix_length = curr_subtree->prefix_length;
+      memcpy((char *)object.name, curr_subtree->prefix,
+                  (prefix_length*sizeof(oid)));
+      object.namelen = prefix_length;
+      for(curr_var = curr_subtree->variables; curr_var->syntax ; curr_var++) {
+          memcpy((char *)(object.name + prefix_length), curr_var->oidSuffix.name,
+                  curr_var->oidSuffix.namelen * sizeof(oid));
+          object.namelen = prefix_length + curr_var->oidSuffix.namelen;
+          if (curr_var->acl_sort & SCALAR) {
+            result = compare(req_oid, &object);
+            /* if (searchType == EXACT AND result == 0 ) OR
+             *    (searchType == NEXT  AND result <  0 ) */
+            if (((searchType == EXACT) && (result == 0)) ||
+                ((searchType == NEXT)  && (result <  0))){
+              access = (*(curr_var->findVar))(len,
+                       mesg, write_method);
+            }
+          } else {
+            result = compare_tree(req_oid, &object);
+            /* if (searchType == EXACT and result == 0) OR
+             *    (searchType == NEXT  and result <= 0) */
+            if (result == 0 || ((searchType == NEXT) && result < 0)){
+              access = (*(curr_var->findVar))(len,
+                        &object, req_oid, searchType,
+                        mesg, write_method);
+            }
+          }
+          if (access) {
+            memcpy(req_oid->name, object.name,
+                      (int)(object.namelen*sizeof(oid)));
+            req_oid->namelen = object.namelen;
+            *type = curr_var->syntax;
+            *acl = curr_var->acl_sort;
+            *noSuchObject = FALSE;
+            return(access);
+          } else {
+            *noSuchObject = TRUE;
+          }
+      }
+    }
+  }
+  if (EXACT) {
+    memcpy(req_oid->name, save.name, save.namelen * sizeof(oid));
+    req_oid->namelen = save.namelen;
+    *noSuchObject = FALSE;
+  }
+  return access;
+}
+
+
diff -ru -ruN apache_1.3.34_orig/src/modules/snmp_agt/src_snmp/agt_mib.h apache_1.3.34/src/modules/snmp_agt/src_snmp/agt_mib.h
--- apache_1.3.34_orig/src/modules/snmp_agt/src_snmp/agt_mib.h	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/src/modules/snmp_agt/src_snmp/agt_mib.h	2006-05-18 16:49:19.298763344 +0200
@@ -0,0 +1,170 @@
+/* ====================================================================
+ * Copyright (c) 1997-1999
+ *                      SMASH, Harrie Hazewinkel.  All rights reserved.
+ *
+ * This product is developed by Harrie Hazewinkel and updates the
+ * original SMUT compiler made as his graduation project at the
+ * University of Twente.
+ *
+ * SMASH is a software package containing an SNMP MIB compiler and
+ * an SNMP agent system. The package can be used for development
+ * of monolithic SNMP agents and contains a compiler which compiles
+ * MIB definitions into C-code to developed an SNMP agent.
+ * More information about him and this software product can
+ * be found on http://operations.ceo.org/~harrie/smash/.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by Harrie Hazewinkel"
+ *
+ * 4. The name of the Copyright holder must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission.
+ *
+ * 5. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by Harrie Hazewinkel"
+ *    Also acknowledged are:
+ *    - The Simple group of the University of Twente,
+ *          http://wwwsnmp.cs.utwente.nl/
+ *    - The MUSIQ workpackage of the DESIRE project,
+ *          http://www-musiq.jrc.it/
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR, ITS DISTRIBUTORS
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================*/
+
+#ifndef _AGT_MIB_H_
+#define _AGT_MIB_H_
+
+extern oid	null_oid[];
+extern long	long_return;
+extern unsigned char	return_buf[];
+
+#define MAX_OCTSTR_LEN	256
+
+/* MIB search types */
+#define EXACT	0
+#define NEXT	1
+#define INDEX	2
+
+#define READ	1
+#define WRITE	0
+
+/* MIB parse phases */
+#define RESERVE1	0
+#define CHECK	0
+#define RESERVE2	1
+#define COMMIT		2
+#define ACTION		3
+#define FREE		4
+
+/* MIB access control list for variable and sort of variable	*/
+#define SCALAR		1	/* Variable is scalar		*/
+#define COLUMN		2	/* variable is column in table	*/
+#define SORT		3	/* Variable is scalar or column n table */
+#define RONLY		4	/* variable has only read access	*/
+#define RWRITE		8	/* variable has write access	*/
+#define NOACCESS	16	/* variable is not accessible	*/
+#define ACCESS		28	/* Variable its access		*/
+#define	OLDSTUB		32	/* Variable is implemented with old stub api */
+
+#define MAX_OID_LEN	32
+typedef struct {
+   int		namelen;
+   oid		name[ MAX_OID_LEN ];
+} Oid;
+
+#define	MAX_SUFFIX_LEN	4
+typedef struct {
+    int		namelen;
+    oid		name[ MAX_SUFFIX_LEN ];
+} Oid_suffix;
+
+typedef struct {
+    char	syntax;		/* syntaxtype of object */
+    char	acl_sort;	/* access control list and sort of object */
+    unsigned char	*(*findVar)();  /* function that finds value of the object */
+    Oid_suffix	oidSuffix;	/* suffix oid part of object */
+} Object;
+
+#define MAX_PREFIX_LEN	16
+typedef struct {
+    int		namelen;
+    oid		name[ MAX_PREFIX_LEN ];
+} Oid_prefix;
+
+struct subtree_t {
+    struct subtree_t *next;	/* Next sub tree */
+    Object	*variables;	/* pointer to variables array */
+				/* The following are similar to the type of Oid */
+				/* but this is only internal and safes spaces. */
+    int		prefix_length;	/* length of objid */
+    oid         *prefix;	/* value of objid */
+};
+
+typedef struct subtree_t SubTree;
+
+/* Only defined for use in BACKWARDS mode
+   Should not be used otherwise!! */
+struct variable {
+    unsigned char          magic;          /* passed to function as a hint */
+    char            type;           /* type of variable */
+/* See important comment in snmp_vars.c relating to acl */
+    unsigned short         acl;            /* access control list for variable */
+    unsigned char          *(*findVar)();  /* function that finds variable */
+    unsigned char          namelen;        /* length of above */
+    oid             name[32];       /* object identifier of variable */
+};
+
+unsigned char  *getStatPtr();
+int insert_group_in_mib(SubTree *tree);
+int	compare(Oid *var1,Oid *var2);
+int	compare_tree(Oid *var1, Oid *var2);
+void	print_objid(char *str, Oid *var);
+
+#define INSERT_IN_MIB(vars, objectId) \
+	{ \
+	static SubTree value =  { NULL, vars, (sizeof(objectId)/sizeof(oid)), objectId}; \
+	insert_group_in_mib(&value); \
+	} \
+
+#ifndef TRUE
+#define TRUE	1
+#endif
+#ifndef FALSE
+#define	FALSE	0
+#endif
+
+/* The root oid required for the MIB */
+#define O_ctitt	0
+#define	O_iso	1
+
+#define MIB_GEN_ERROR	(unsigned char*)-1
+#define NO_MIBINSTANCE	NULL
+
+#define Access_rec void
+
+#endif	/* _AGT_MIB_H_ */
diff -ru -ruN apache_1.3.34_orig/src/modules/snmp_agt/src_snmp/asn1.c apache_1.3.34/src/modules/snmp_agt/src_snmp/asn1.c
--- apache_1.3.34_orig/src/modules/snmp_agt/src_snmp/asn1.c	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/src/modules/snmp_agt/src_snmp/asn1.c	2006-05-18 16:49:19.298763344 +0200
@@ -0,0 +1,967 @@
+ /*
+ * Abstract Syntax Notation One, ASN.1
+ * As defined in ISO/IS 8824 and ISO/IS 8825
+ * This implements a subset of the above International Standards that
+ * is sufficient to implement SNMP.
+ *
+ * Encodes abstract data types into a machine independent stream of bytes.
+ *
+ */
+/**********************************************************************
+	Copyright 1988, 1989, 1991, 1992 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of CMU not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+CMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+******************************************************************/
+/* Apache includes */
+#include "ap_config.h"
+
+/* General includes */
+#include <sys/types.h>
+#include <netinet/in.h>
+
+/* SNMP engine includes */
+#include "snmp_config.h"
+#include "asn1.h"
+#include "agt_mib.h"
+
+/*
+ * asn_parse_int - pulls a long out of an ASN int type.
+ *  On entry, datalength is input as the number of valid bytes following
+ *   "data".  On exit, it is returned as the number of valid bytes
+ *   following the end of this object.
+ *
+ *  Returns a pointer to the first byte past the end
+ *   of this object (i.e. the start of the next object).
+ *  Returns NULL on any error.
+ */
+unsigned char *
+asn_parse_int(data, datalength, type, intp, intsize)
+    register unsigned char	    *data;	/* IN - pointer to start of object */
+    register int	    *datalength;/* IN/OUT - number of valid bytes left in buffer */
+    unsigned char		    *type;	/* OUT - asn type of object */
+    long		    *intp;	/* IN/OUT - pointer to start of output buffer */
+    int			    intsize;    /* IN - size of output buffer */
+{
+/*
+ * ASN.1 integer ::= 0x02 asnlength byte {byte}*
+ */
+    register unsigned char *bufp = data;
+    unsigned long	    asn_length;
+    register long   value = 0;
+
+    if (intsize != sizeof (long)){
+	SNMP_DEBUG("not long");
+	return NULL;
+    }
+    *type = *bufp++;
+    bufp = asn_parse_length(bufp, &asn_length);
+    if (bufp == NULL){
+	SNMP_DEBUG("bad length");
+	return NULL;
+    }
+    if ((int)asn_length + (bufp - data) > *datalength){
+	SNMP_DEBUG("overflow of message");
+	return NULL;
+    }
+    if ((int)asn_length > intsize){
+	SNMP_DEBUG("I don't support such large integers");
+	return NULL;
+    }
+    *datalength -= (int)asn_length + (bufp - data);
+    if (*bufp & 0x80)
+	value = -1; /* integer is negative */
+    while(asn_length--)
+	value = (value << 8) | *bufp++;
+    *intp = value;
+    return bufp;
+}
+
+
+/*
+ * asn_parse_unsigned_int - pulls an unsigned long out of an ASN int type.
+ *  On entry, datalength is input as the number of valid bytes following
+ *   "data".  On exit, it is returned as the number of valid bytes
+ *   following the end of this object.
+ *
+ *  Returns a pointer to the first byte past the end
+ *   of this object (i.e. the start of the next object).
+ *  Returns NULL on any error.
+ */
+unsigned char *
+asn_parse_unsigned_int(data, datalength, type, intp, intsize)
+    register unsigned char	    *data;	/* IN - pointer to start of object */
+    register int	    *datalength;/* IN/OUT - number of valid bytes left in buffer */
+    unsigned char		    *type;	/* OUT - asn type of object */
+    unsigned long		    *intp;	/* IN/OUT - pointer to start of output buffer */
+    int			    intsize;    /* IN - size of output buffer */
+{
+/*
+ * ASN.1 integer ::= 0x02 asnlength byte {byte}*
+ */
+    register unsigned char *bufp = data;
+    unsigned long	    asn_length;
+    register unsigned long value = 0;
+
+    if (intsize != sizeof (long)){
+	SNMP_DEBUG("not long");
+	return NULL;
+    }
+    *type = *bufp++;
+    bufp = asn_parse_length(bufp, &asn_length);
+    if (bufp == NULL){
+	SNMP_DEBUG("bad length");
+	return NULL;
+    }
+    if ((int)asn_length + (bufp - data) > *datalength){
+	SNMP_DEBUG("overflow of message");
+	return NULL;
+    }
+    if (((int)asn_length > (intsize + 1)) ||
+	(((int)asn_length == intsize + 1) && *bufp != 0x00)){
+	SNMP_DEBUG("I don't support such large integers");
+	return NULL;
+    }
+    *datalength -= (int)asn_length + (bufp - data);
+    if (*bufp & 0x80)
+	value = -1; /* integer is negative */
+    while(asn_length--)
+	value = (value << 8) | *bufp++;
+    *intp = value;
+    return bufp;
+}
+
+
+/*
+ * asn_build_int - builds an ASN object containing an integer.
+ *  On entry, datalength is input as the number of valid bytes following
+ *   "data".  On exit, it is returned as the number of valid bytes
+ *   following the end of this object.
+ *
+ *  Returns a pointer to the first byte past the end
+ *   of this object (i.e. the start of the next object).
+ *  Returns NULL on any error.
+ */
+unsigned char *
+asn_build_int(data, datalength, type, intp, intsize)
+    register unsigned char *data;	/* IN - pointer to start of output buffer */
+    register int    *datalength;/* IN/OUT - number of valid bytes left in buffer */
+    unsigned char	    type;	/* IN - asn type of object */
+    register long   *intp;	/* IN - pointer to start of long integer */
+    register int    intsize;    /* IN - size of *intp */
+{
+/*
+ * ASN.1 integer ::= 0x02 asnlength byte {byte}*
+ */
+
+    register long integer;
+    register unsigned long mask;
+
+    if (intsize != sizeof (long))
+	return NULL;
+    integer = *intp;
+    /*
+     * Truncate "unnecessary" bytes off of the most significant end of this
+     * 2's complement integer.  There should be no sequence of 9
+     * consecutive 1's or 0's at the most significant end of the
+     * integer.
+     */
+    mask = 0x1FF << ((8 * (sizeof(long) - 1)) - 1);
+    /* mask is 0xFF800000 on a big-endian machine */
+    while((((integer & mask) == 0) || ((integer & mask) == mask))
+	  && intsize > 1){
+	intsize--;
+	integer <<= 8;
+    }
+    data = asn_build_header(data, datalength, type, intsize);
+    if (data == NULL)
+	return NULL;
+    if (*datalength < intsize)
+	return NULL;
+    *datalength -= intsize;
+    mask = 0xFF << (8 * (sizeof(long) - 1));
+    /* mask is 0xFF000000 on a big-endian machine */
+    while(intsize--){
+	*data++ = (unsigned char)((integer & mask) >> (8 * (sizeof(long) - 1)));
+	integer <<= 8;
+    }
+    return data;
+}
+
+
+/*
+ * asn_build_unsigned_int - builds an ASN object containing an integer.
+ *  On entry, datalength is input as the number of valid bytes following
+ *   "data".  On exit, it is returned as the number of valid bytes
+ *   following the end of this object.
+ *
+ *  Returns a pointer to the first byte past the end
+ *   of this object (i.e. the start of the next object).
+ *  Returns NULL on any error.
+ */
+unsigned char *
+asn_build_unsigned_int(data, datalength, type, intp, intsize)
+    register unsigned char *data;	/* IN - pointer to start of output buffer */
+    register int    *datalength;/* IN/OUT - number of valid bytes left in buffer */
+    unsigned char	    type;	/* IN - asn type of object */
+    register unsigned long *intp;	/* IN - pointer to start of long integer */
+    register int    intsize;    /* IN - size of *intp */
+{
+/*
+ * ASN.1 integer ::= 0x02 asnlength byte {byte}*
+ */
+
+    register unsigned long integer;
+    register unsigned long mask;
+    int add_null_byte = 0;
+
+    if (intsize != sizeof (long))
+	return NULL;
+    integer = *intp;
+    mask = 0xFF << (8 * (sizeof(long) - 1));
+    /* mask is 0xFF000000 on a big-endian machine */
+    if ((unsigned char)((integer & mask) >> (8 * (sizeof(long) - 1))) & 0x80){
+	/* if MSB is set */
+	add_null_byte = 1;
+	intsize++;
+    }
+    /*
+     * Truncate "unnecessary" bytes off of the most significant end of this 2's complement integer.
+     * There should be no sequence of 9 consecutive 1's or 0's at the most significant end of the
+     * integer.
+     */
+    mask = 0x1FF << ((8 * (sizeof(long) - 1)) - 1);
+    /* mask is 0xFF800000 on a big-endian machine */
+    while((((integer & mask) == 0) || ((integer & mask) == mask)) && intsize > 1){
+	intsize--;
+	integer <<= 8;
+    }
+    data = asn_build_header(data, datalength, type, intsize);
+    if (data == NULL)
+	return NULL;
+    if (*datalength < intsize)
+	return NULL;
+    *datalength -= intsize;
+    if (add_null_byte == 1){
+	*data++ = '\0';
+	intsize--;
+    }
+    mask = 0xFF << (8 * (sizeof(long) - 1));
+    /* mask is 0xFF000000 on a big-endian machine */
+    while(intsize--){
+	*data++ = (unsigned char)((integer & mask) >> (8 * (sizeof(long) - 1)));
+	integer <<= 8;
+    }
+    return data;
+}
+
+
+/*
+ * asn_parse_string - pulls an octet string out of an ASN octet string type.
+ *  On entry, datalength is input as the number of valid bytes following
+ *   "data".  On exit, it is returned as the number of valid bytes
+ *   following the beginning of the next object.
+ *
+ *  "string" is filled with the octet string.
+ *
+ *  Returns a pointer to the first byte past the end
+ *   of this object (i.e. the start of the next object).
+ *  Returns NULL on any error.
+ */
+unsigned char *
+asn_parse_string(data, datalength, type, string, strlength)
+    unsigned char	    *data;	    /* IN - pointer to start of object */
+    register int    *datalength;    /* IN/OUT - number of valid bytes left in buffer */
+    unsigned char	    *type;	    /* OUT - asn type of object */
+    unsigned char	    *string;	    /* IN/OUT - pointer to start of output buffer */
+    register int    *strlength;     /* IN/OUT - size of output buffer */
+{
+/*
+ * ASN.1 octet string ::= primstring | cmpdstring
+ * primstring ::= 0x04 asnlength byte {byte}*
+ * cmpdstring ::= 0x24 asnlength string {string}*
+ */
+    register unsigned char *bufp = data;
+    unsigned long	    asn_length;
+
+    *type = *bufp++;
+    bufp = asn_parse_length(bufp, &asn_length);
+    if (bufp == NULL)
+	return NULL;
+    if ((int)asn_length + (bufp - data) > *datalength){
+	SNMP_DEBUG("overflow of message");
+	return NULL;
+    }
+    if ((int)asn_length > *strlength){
+	SNMP_DEBUG("I don't support such long strings");
+	return NULL;
+    }
+    memcpy((char *)string, (char *)bufp, (int)asn_length);
+    *strlength = (int)asn_length;
+    *datalength -= (int)asn_length + (bufp - data);
+    return bufp + asn_length;
+}
+
+
+/*
+ * asn_build_string - Builds an ASN octet string object containing the input string.
+ *  On entry, datalength is input as the number of valid bytes following
+ *   "data".  On exit, it is returned as the number of valid bytes
+ *   following the beginning of the next object.
+ *
+ *  Returns a pointer to the first byte past the end
+ *   of this object (i.e. the start of the next object).
+ *  Returns NULL on any error.
+ */
+unsigned char *
+asn_build_string(data, datalength, type, string, strlength)
+    unsigned char	    *data;	    /* IN - pointer to start of object */
+    register int    *datalength;    /* IN/OUT - number of valid bytes left in buffer */
+    unsigned char	    type;	    /* IN - ASN type of string */
+    unsigned char	    *string;	    /* IN - pointer to start of input buffer */
+    register int    strlength;	    /* IN - size of input buffer */
+{
+/*
+ * ASN.1 octet string ::= primstring | cmpdstring
+ * primstring ::= 0x04 asnlength byte {byte}*
+ * cmpdstring ::= 0x24 asnlength string {string}*
+ * This code will never send a compound string.
+ */
+    data = asn_build_header(data, datalength, type, strlength);
+    if (data == NULL)
+	return NULL;
+    if (*datalength < strlength)
+	return NULL;
+    memcpy((char *)data, (char *)string, strlength);
+    *datalength -= strlength;
+    return data + strlength;
+}
+
+
+/*
+ * asn_parse_header - interprets the ID and length of the current object.
+ *  On entry, datalength is input as the number of valid bytes following
+ *   "data".  On exit, it is returned as the number of valid bytes
+ *   in this object following the id and length.
+ *
+ *  Returns a pointer to the first byte of the contents of this object.
+ *  Returns NULL on any error.
+ */
+unsigned char *
+asn_parse_header(data, datalength, type)
+    unsigned char	    *data;	/* IN - pointer to start of object */
+    int		    *datalength;/* IN/OUT - number of valid bytes left in buffer */
+    unsigned char	    *type;	/* OUT - ASN type of object */
+{
+    register unsigned char *bufp = data;
+    register unsigned long header_len;
+    unsigned long	    asn_length;
+
+    /* this only works on data types < 30, i.e. no extension octets */
+    if (IS_EXTENSION_ID(*bufp)){
+	SNMP_DEBUG("can't process ID >= 30");
+	return NULL;
+    }
+    *type = *bufp;
+    bufp = asn_parse_length(bufp + 1, &asn_length);
+    if (bufp == NULL)
+	return NULL;
+    header_len = bufp - data;
+    if ((int)header_len + (int)asn_length > *datalength){
+	SNMP_DEBUG("asn length too long");
+	return NULL;
+    }
+    *datalength = (int)asn_length;
+    return bufp;
+}
+
+/*
+ * asn_build_header - builds an ASN header for an object with the ID and
+ * length specified.
+ *  On entry, datalength is input as the number of valid bytes following
+ *   "data".  On exit, it is returned as the number of valid bytes
+ *   in this object following the id and length.
+ *
+ *  This only works on data types < 30, i.e. no extension octets.
+ *  The maximum length is 0xFFFF;
+ *
+ *  Returns a pointer to the first byte of the contents of this object.
+ *  Returns NULL on any error.
+ */
+unsigned char *
+asn_build_header(data, datalength, type, length)
+    register unsigned char *data;	/* IN - pointer to start of object */
+    int		    *datalength;/* IN/OUT - number of valid bytes left in buffer */
+    unsigned char	    type;	/* IN - ASN type of object */
+    int		    length;	/* IN - length of object */
+{
+    if (*datalength < 1)
+	return NULL;
+    *data++ = type;
+    (*datalength)--;
+    return asn_build_length(data, datalength, length);
+    
+}
+
+/*
+ * asn_build_sequence - builds an ASN header for a sequence with the ID and
+ * length specified.
+ *  On entry, datalength is input as the number of valid bytes following
+ *   "data".  On exit, it is returned as the number of valid bytes
+ *   in this object following the id and length.
+ *
+ *  This only works on data types < 30, i.e. no extension octets.
+ *  The maximum length is 0xFFFF;
+ *
+ *  Returns a pointer to the first byte of the contents of this object.
+ *  Returns NULL on any error.
+ */
+unsigned char *
+asn_build_sequence(data, datalength, type, length)
+    register unsigned char *data;	/* IN - pointer to start of object */
+    int		    *datalength;/* IN/OUT - number of valid bytes left in buffer */
+    unsigned char	    type;	/* IN - ASN type of object */
+    int		    length;	/* IN - length of object */
+{
+    *datalength -= 4;
+    if (*datalength < 0){
+	*datalength += 4;	/* fix up before punting */
+	return NULL;
+    }
+    *data++ = type;
+    *data++ = (unsigned char)(0x02 | ASN_LONG_LEN);
+    *data++ = (unsigned char)((length >> 8) & 0xFF);
+    *data++ = (unsigned char)(length & 0xFF);
+    return data;
+}
+
+/*
+ * asn_parse_length - interprets the length of the current object.
+ *  On exit, length contains the value of this length field.
+ *
+ *  Returns a pointer to the first byte after this length
+ *  field (aka: the start of the data field).
+ *  Returns NULL on any error.
+ */
+unsigned char *
+asn_parse_length(data, datalength)
+    unsigned char  *data;	/* IN - pointer to start of length field */
+    unsigned long  *datalength;	/* OUT - value of length field */
+{
+    register unsigned char lengthbyte = *data;
+
+    if (lengthbyte & ASN_LONG_LEN){
+	lengthbyte &= ~ASN_LONG_LEN;	/* turn MSb off */
+	if (lengthbyte == 0){
+	    SNMP_DEBUG("We don't support indefinite lengths");
+	    return NULL;
+	}
+	if (lengthbyte > sizeof(long)){
+	    SNMP_DEBUG("we can't support data lengths that long");
+	    return NULL;
+	}
+	memcpy((char *)datalength, (char *)data + 1, (int)lengthbyte);
+	*datalength = ntohl(*datalength);
+	*datalength >>= (8 * ((sizeof *datalength) - lengthbyte));
+	return data + lengthbyte + 1;
+    } else { /* short asnlength */
+	*datalength = (long)lengthbyte;
+	return data + 1;
+    }
+}
+
+unsigned char *
+asn_build_length(data, datalength, length)
+    register unsigned char *data;	/* IN - pointer to start of object */
+    int		    *datalength;/* IN/OUT - number of valid bytes left in buffer */
+    register int    length;	/* IN - length of object */
+{
+    unsigned char    *start_data = data;
+
+    /* no indefinite lengths sent */
+    if (length < 0x80){
+	if (*datalength < 1){
+	    SNMP_DEBUG("build_length");
+	    return NULL;
+	}	    
+	*data++ = (unsigned char)length;
+    } else if (length <= 0xFF){
+	if (*datalength < 2){
+	    SNMP_DEBUG("build_length");
+	    return NULL;
+	}	    
+	*data++ = (unsigned char)(0x01 | ASN_LONG_LEN);
+	*data++ = (unsigned char)length;
+    } else { /* 0xFF < length <= 0xFFFF */
+	if (*datalength < 3){
+	    SNMP_DEBUG("build_length");
+	    return NULL;
+	}	    
+	*data++ = (unsigned char)(0x02 | ASN_LONG_LEN);
+	*data++ = (unsigned char)((length >> 8) & 0xFF);
+	*data++ = (unsigned char)(length & 0xFF);
+    }
+    *datalength -= (data - start_data);
+    return data;
+
+}
+
+/*
+ * asn_parse_objid - pulls an object indentifier out of an ASN object identifier type.
+ *  On entry, datalength is input as the number of valid bytes following
+ *   "data".  On exit, it is returned as the number of valid bytes
+ *   following the beginning of the next object.
+ *
+ *  "objid" is filled with the object identifier.
+ *
+ *  Returns a pointer to the first byte past the end
+ *   of this object (i.e. the start of the next object).
+ *  Returns NULL on any error.
+ */
+unsigned char *
+asn_parse_objid(data, datalength, type, objid, objidlength)
+    unsigned char	    *data;	    /* IN - pointer to start of object */
+    int		    *datalength;    /* IN/OUT - number of valid bytes left in buffer */
+    unsigned char	    *type;	    /* OUT - ASN type of object */
+    oid		    *objid;	    /* IN/OUT - pointer to start of output buffer */
+    int		    *objidlength;     /* IN/OUT - number of sub-id's in objid */
+{
+/*
+ * ASN.1 objid ::= 0x06 asnlength subidentifier {subidentifier}*
+ * subidentifier ::= {leadingbyte}* lastbyte
+ * leadingbyte ::= 1 7bitvalue
+ * lastbyte ::= 0 7bitvalue
+ */
+    register unsigned char *bufp = data;
+    register oid *oidp = objid + 1;
+    register unsigned long subidentifier;
+    register long   length;
+    unsigned long	    asn_length;
+
+    *type = *bufp++;
+    bufp = asn_parse_length(bufp, &asn_length);
+    if (bufp == NULL)
+	return NULL;
+    if ((int)asn_length + (bufp - data) > *datalength){
+	SNMP_DEBUG("overflow of message");
+	return NULL;
+    }
+    *datalength -= (int)asn_length + (bufp - data);
+
+    /* Handle invalid object identifier encodings of the form 06 00 robustly */
+    if (asn_length == 0)
+	objid[0] = objid[1] = 0;
+
+    length = asn_length;
+    (*objidlength)--;	/* account for expansion of first byte */
+    while (length > 0 && (*objidlength)-- > 0){
+	subidentifier = 0;
+	do {	/* shift and add in low order 7 bits */
+	    subidentifier = (subidentifier << 7) + (*(unsigned char *)bufp & ~ASN_BIT8);
+	    length--;
+	} while (*(unsigned char *)bufp++ & ASN_BIT8);	/* last byte has high bit clear */
+	if (subidentifier > (unsigned long)MAX_SUBID){
+	    SNMP_DEBUG("subidentifier too long");
+	    return NULL;
+	}
+	*oidp++ = (oid)subidentifier;
+    }
+
+    /*
+     * The first two subidentifiers are encoded into the first component
+     * with the value (X * 40) + Y, where:
+     *	X is the value of the first subidentifier.
+     *  Y is the value of the second subidentifier.
+     */
+    subidentifier = (unsigned long)objid[1];
+    if (subidentifier == 0x2B){
+	objid[0] = 1;
+	objid[1] = 3;
+    } else {
+	objid[1] = (unsigned char)(subidentifier % 40);
+	objid[0] = (unsigned char)((subidentifier - objid[1]) / 40);
+    }
+
+    *objidlength = (int)(oidp - objid);
+    return bufp;
+}
+
+/*
+ * asn_build_objid - Builds an ASN object identifier object containing the
+ * input string.
+ *  On entry, datalength is input as the number of valid bytes following
+ *   "data".  On exit, it is returned as the number of valid bytes
+ *   following the beginning of the next object.
+ *
+ *  Returns a pointer to the first byte past the end
+ *   of this object (i.e. the start of the next object).
+ *  Returns NULL on any error.
+ */
+unsigned char *
+asn_build_objid(data, datalength, type, objid, objidlength)
+    register unsigned char *data;	    /* IN - pointer to start of object */
+    int		    *datalength;    /* IN/OUT - number of valid bytes left in buffer */
+    unsigned char	    type;	    /* IN - ASN type of object */
+    oid		    *objid;	    /* IN - pointer to start of input buffer */
+    int		    objidlength;    /* IN - number of sub-id's in objid */
+{
+/*
+ * ASN.1 objid ::= 0x06 asnlength subidentifier {subidentifier}*
+ * subidentifier ::= {leadingbyte}* lastbyte
+ * leadingbyte ::= 1 7bitvalue
+ * lastbyte ::= 0 7bitvalue
+ */
+    unsigned char buf[MAX_OID_LEN];
+    register unsigned char *bp = buf;
+    register oid *op = objid;
+    int    asnlength;
+    register unsigned long subid, mask, testmask;
+    register int bits, testbits;
+
+    if (objidlength < 2){
+	*bp++ = 0;
+	objidlength = 0;
+    } else {
+	*bp++ = (unsigned char) (op[1] + (op[0] * 40));
+	objidlength -= 2;
+	op += 2;
+    }
+
+    while(objidlength-- > 0){
+	subid = *op++;
+	if (subid < 127){ /* off by one? */
+	    *bp++ = (unsigned char) subid;
+	} else {
+	    mask = 0x7F; /* handle subid == 0 case */
+	    bits = 0;
+	    /* testmask *MUST* !!!! be of an unsigned type */
+	    for(testmask = 0x7F, testbits = 0; testmask != 0;
+		testmask <<= 7, testbits += 7){
+		if (subid & testmask){	/* if any bits set */
+		    mask = testmask;
+		    bits = testbits;
+		}
+	    }
+	    /* mask can't be zero here */
+	    for(;mask != 0x7F; mask >>= 7, bits -= 7){
+		/* fix a mask that got truncated above */
+		if (mask == 0x1E00000)  
+		    mask = 0xFE00000;
+		*bp++ = (unsigned char)(((subid & mask) >> bits) | ASN_BIT8);
+	    }
+	    *bp++ = (unsigned char)(subid & mask);
+	}
+    }
+    asnlength = bp - buf;
+    data = asn_build_header(data, datalength, type, asnlength);
+    if (data == NULL)
+	return NULL;
+    if (*datalength < asnlength)
+	return NULL;
+    memcpy((char *)data, (char *)buf, asnlength);
+    *datalength -= asnlength;
+    return data + asnlength;
+}
+
+/*
+ * asn_parse_null - Interprets an ASN null type.
+ *  On entry, datalength is input as the number of valid bytes following
+ *   "data".  On exit, it is returned as the number of valid bytes
+ *   following the beginning of the next object.
+ *
+ *  Returns a pointer to the first byte past the end
+ *   of this object (i.e. the start of the next object).
+ *  Returns NULL on any error.
+ */
+unsigned char *
+asn_parse_null(data, datalength, type)
+    unsigned char	    *data;	    /* IN - pointer to start of object */
+    int		    *datalength;    /* IN/OUT - number of valid bytes left in buffer */
+    unsigned char	    *type;	    /* OUT - ASN type of object */
+{
+/*
+ * ASN.1 null ::= 0x05 0x00
+ */
+    register unsigned char   *bufp = data;
+    unsigned long	    asn_length;
+
+    *type = *bufp++;
+    bufp = asn_parse_length(bufp, &asn_length);
+    if (bufp == NULL)
+	return NULL;
+    if (asn_length != 0){
+	SNMP_DEBUG("Malformed NULL");
+	return NULL;
+    }
+    *datalength -= (bufp - data);
+    return bufp + asn_length;
+}
+
+
+/*
+ * asn_build_null - Builds an ASN null object.
+ *  On entry, datalength is input as the number of valid bytes following
+ *   "data".  On exit, it is returned as the number of valid bytes
+ *   following the beginning of the next object.
+ *
+ *  Returns a pointer to the first byte past the end
+ *   of this object (i.e. the start of the next object).
+ *  Returns NULL on any error.
+ */
+unsigned char *
+asn_build_null(data, datalength, type)
+    unsigned char	    *data;	    /* IN - pointer to start of object */
+    int		    *datalength;    /* IN/OUT - number of valid bytes left in buffer */
+    unsigned char	    type;	    /* IN - ASN type of object */
+{
+/*
+ * ASN.1 null ::= 0x05 0x00
+ */
+    return asn_build_header(data, datalength, type, 0);
+}
+
+/*
+ * asn_parse_bitstring - pulls a bitstring out of an ASN bitstring type.
+ *  On entry, datalength is input as the number of valid bytes following
+ *   "data".  On exit, it is returned as the number of valid bytes
+ *   following the beginning of the next object.
+ *
+ *  "string" is filled with the bit string.
+ *
+ *  Returns a pointer to the first byte past the end
+ *   of this object (i.e. the start of the next object).
+ *  Returns NULL on any error.
+ */
+unsigned char *
+asn_parse_bitstring(data, datalength, type, string, strlength)
+    unsigned char	    *data;	    /* IN - pointer to start of object */
+    register int    *datalength;    /* IN/OUT - number of valid bytes left in buffer */
+    unsigned char	    *type;	    /* OUT - asn type of object */
+    unsigned char	    *string;	    /* IN/OUT - pointer to start of output buffer */
+    register int    *strlength;     /* IN/OUT - size of output buffer */
+{
+/*
+ * bitstring ::= 0x03 asnlength unused {byte}*
+ */
+    register unsigned char *bufp = data;
+    unsigned long	    asn_length;
+
+    *type = *bufp++;
+    bufp = asn_parse_length(bufp, &asn_length);
+    if (bufp == NULL)
+	return NULL;
+    if ((int)asn_length + (bufp - data) > *datalength){
+	SNMP_DEBUG("overflow of message");
+	return NULL;
+    }
+    if ((int)asn_length > *strlength){
+	SNMP_DEBUG("I don't support such long bitstrings");
+	return NULL;
+    }
+    if (asn_length < 1){
+	SNMP_DEBUG("Invalid bitstring");
+	return NULL;
+    }
+    /* Someone mention this should be '(*bufp > 7)' instaed of */
+    /* '(*bufp < 0 || *bufp > 7)'. Harrie doesn't know why?? */
+    if (*bufp < 0 || *bufp > 7){
+	SNMP_DEBUG("Invalid bitstring");
+	return NULL;
+    }
+    memcpy((char *)string, (char *)bufp, (int)asn_length);
+    *strlength = (int)asn_length;
+    *datalength -= (int)asn_length + (bufp - data);
+    return bufp + asn_length;
+}
+
+
+/*
+ * asn_build_bitstring - Builds an ASN bit string object containing the
+ * input string.
+ *  On entry, datalength is input as the number of valid bytes following
+ *   "data".  On exit, it is returned as the number of valid bytes
+ *   following the beginning of the next object.
+ *
+ *  Returns a pointer to the first byte past the end
+ *   of this object (i.e. the start of the next object).
+ *  Returns NULL on any error.
+ */
+unsigned char *
+asn_build_bitstring(data, datalength, type, string, strlength)
+    unsigned char	    *data;	    /* IN - pointer to start of object */
+    register int    *datalength;    /* IN/OUT - number of valid bytes left in buffer */
+    unsigned char	    type;	    /* IN - ASN type of string */
+    unsigned char	    *string;	    /* IN - pointer to start of input buffer */
+    register int    strlength;	    /* IN - size of input buffer */
+{
+/*
+ * ASN.1 bit string ::= 0x03 asnlength unused {byte}*
+ */
+    /* someone mentioned that '(strlength < 1 || *string < 0 || *string > 7)' */
+    /* should be '(strlength < 1 || *string > 7)' Harrie doesn't know why ?? */
+    if (strlength < 1 || *string < 0 || *string > 7){
+	SNMP_DEBUG("Building invalid bitstring");
+	return NULL;
+    }
+    data = asn_build_header(data, datalength, type, strlength);
+    if (data == NULL)
+	return NULL;
+    if (*datalength < strlength)
+	return NULL;
+    memcpy((char *)data, (char *)string, strlength);
+    *datalength -= strlength;
+    return data + strlength;
+}
+
+
+/*
+ * asn_parse_unsigned_int64 - pulls a 64 bit unsigned long out of an ASN int
+ * type.
+ *  On entry, datalength is input as the number of valid bytes following
+ *   "data".  On exit, it is returned as the number of valid bytes
+ *   following the end of this object.
+ *
+ *  Returns a pointer to the first byte past the end
+ *   of this object (i.e. the start of the next object).
+ *  Returns NULL on any error.
+ */
+unsigned char *
+asn_parse_unsigned_int64(data, datalength, type, cp, countersize)
+    register unsigned char	    *data;	/* IN - pointer to start of object */
+    register int	    *datalength;/* IN/OUT - number of valid bytes left in buffer */
+    unsigned char		    *type;	/* OUT - asn type of object */
+    Counter64		    *cp;	/* IN/OUT -pointer to counter struct */
+    int			    countersize;/* IN - size of output buffer */
+{
+/*
+ * ASN.1 integer ::= 0x02 asnlength byte {byte}*
+ */
+    register unsigned char *bufp = data;
+    unsigned long	    asn_length;
+    register unsigned long low = 0, high = 0;
+    int intsize = 4;
+    
+    if (countersize != sizeof(Counter64)){
+	SNMP_DEBUG("not right size");
+	return NULL;
+    }
+    *type = *bufp++;
+    bufp = asn_parse_length(bufp, &asn_length);
+    if (bufp == NULL){
+	SNMP_DEBUG("bad length");
+	return NULL;
+    }
+    if ((int)asn_length + (bufp - data) > *datalength){
+	SNMP_DEBUG("overflow of message");
+	return NULL;
+    }
+    if (((int)asn_length > (intsize * 2 + 1)) ||
+	(((int)asn_length == (intsize * 2) + 1) && *bufp != 0x00)){
+	SNMP_DEBUG("I don't support such large integers");
+	return NULL;
+    }
+    *datalength -= (int)asn_length + (bufp - data);
+    if (*bufp & 0x80){
+	low = -1; /* integer is negative */
+	high = -1;
+    }
+    while(asn_length--){
+	high = (high << 8) | ((low & 0xFF000000) >> 24);
+	low = (low << 8) | *bufp++;
+    }
+    cp->low = low;
+    cp->high = high;
+    return bufp;
+}
+
+
+/*
+ * asn_build_unsigned_int64 - builds an ASN object containing a 64 bit integer.
+ *  On entry, datalength is input as the number of valid bytes following
+ *   "data".  On exit, it is returned as the number of valid bytes
+ *   following the end of this object.
+ *
+ *  Returns a pointer to the first byte past the end
+ *   of this object (i.e. the start of the next object).
+ *  Returns NULL on any error.
+ */
+unsigned char *
+asn_build_unsigned_int64(data, datalength, type, cp, countersize)
+    register unsigned char *data;	/* IN - pointer to start of output buffer */
+    register int    *datalength;/* IN/OUT - number of valid bytes left in buffer */
+    unsigned char	    type;	/* IN - asn type of object */
+    Counter64 *cp;	/* IN - pointer to counter struct */
+    register int    countersize; /* IN - size of *intp */
+{
+/*
+ * ASN.1 integer ::= 0x02 asnlength byte {byte}*
+ */
+
+    register unsigned long low, high;
+    register unsigned long mask, mask2;
+    int add_null_byte = 0;
+    int intsize;
+
+    if (countersize != sizeof (Counter64))
+	return NULL;
+    intsize = 8;
+    low = cp->low;
+    high = cp->high;
+    mask = 0xFF << (8 * (sizeof(long) - 1));
+    /* mask is 0xFF000000 on a big-endian machine */
+    if ((unsigned char)((high & mask) >> (8 * (sizeof(long) - 1))) & 0x80){
+	/* if MSB is set */
+	add_null_byte = 1;
+	intsize++;
+    }
+    /*
+     * Truncate "unnecessary" bytes off of the most significant end of this 2's
+     * complement integer.
+     * There should be no sequence of 9 consecutive 1's or 0's at the most
+     * significant end of the integer.
+     */
+    mask2 = 0x1FF << ((8 * (sizeof(long) - 1)) - 1);
+    /* mask2 is 0xFF800000 on a big-endian machine */
+    while((((high & mask2) == 0) || ((high & mask2) == mask2))
+	  && intsize > 1){
+	intsize--;
+	high = (high << 8)
+	    | ((low & mask) >> (8 * (sizeof(long) - 1)));
+	low <<= 8;
+    }
+    data = asn_build_header(data, datalength, type, intsize);
+    if (data == NULL)
+	return NULL;
+    if (*datalength < intsize)
+	return NULL;
+    *datalength -= intsize;
+    if (add_null_byte == 1){
+	*data++ = '\0';
+	intsize--;
+    }
+    while(intsize--){
+	*data++ = (unsigned char)((high & mask) >> (8 * (sizeof(long) - 1)));
+	high = (high << 8)
+	    | ((low & mask) >> (8 * (sizeof(long) - 1)));
+	low <<= 8;
+	
+    }
+    return data;
+}
+
+
diff -ru -ruN apache_1.3.34_orig/src/modules/snmp_agt/src_snmp/asn1.h apache_1.3.34/src/modules/snmp_agt/src_snmp/asn1.h
--- apache_1.3.34_orig/src/modules/snmp_agt/src_snmp/asn1.h	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/src/modules/snmp_agt/src_snmp/asn1.h	2006-05-18 16:49:19.297763496 +0200
@@ -0,0 +1,95 @@
+/*
+ * Definitions for Abstract Syntax Notation One, ASN.1
+ * As defined in ISO/IS 8824 and ISO/IS 8825
+ *
+ *
+ */
+/***********************************************************
+	Copyright 1988, 1989 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of CMU not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+CMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+******************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "snmp_config.h"
+#endif
+
+/* changed by H.H. */
+typedef struct {
+    unsigned long high;
+    unsigned long low;
+} Counter64;
+
+/* added by H.H. */
+#ifndef SMALL_SUBIDS
+typedef unsigned long  oid;
+#define MAX_SUBID   0xFFFFFFFF
+#else
+typedef unsigned char  oid;
+#define MAX_SUBID   0xFF
+#endif
+
+#define ASN_BOOLEAN	    (0x01)
+#define ASN_INTEGER	    (0x02)
+#define ASN_BIT_STR	    (0x03)
+#define ASN_OCTET_STR	    (0x04)
+#define ASN_NULL	    (0x05)
+#define ASN_OBJECT_ID	    (0x06)
+#define ASN_SEQUENCE	    (0x10)
+
+#define ASN_UNIVERSAL	    (0x00)
+#define ASN_APPLICATION     (0x40)
+#define ASN_CONTEXT	    (0x80)
+#define ASN_PRIVATE	    (0xC0)
+
+#define ASN_PRIMITIVE	    (0x00)
+#define ASN_CONSTRUCTOR	    (0x20)
+
+#define ASN_LONG_LEN	    (0x80)
+#define ASN_EXTENSION_ID    (0x1F)
+#define ASN_BIT8	    (0x80)
+
+#define IS_CONSTRUCTOR(byte)	((byte) & ASN_CONSTRUCTOR)
+#define IS_EXTENSION_ID(byte)	(((byte) & ASN_EXTENSION_ID) == ASN_EXTENSION_ID)
+
+unsigned char	*asn_parse_int(unsigned char *data, int *datalength,
+		unsigned char *type, long *intp, int intsize);
+unsigned char	*asn_build_int(unsigned char *data, int *datalength,
+		unsigned char type, long *intp, int intsize);
+unsigned char	*asn_parse_unsigned_int(unsigned char *data, int *datalength,
+		unsigned char *type, unsigned long *intp, int intsize);
+unsigned char	*asn_build_unsigned_int(unsigned char *data, int *datalength,
+		unsigned char type, unsigned long *intp, int intsize);
+unsigned char	*asn_parse_string(unsigned char *data, int *datalength,
+		unsigned char *type, unsigned char *string, int *strlength);
+unsigned char	*asn_build_string(unsigned char *data, int *datalength,
+		unsigned char type, unsigned char *string, int strlength);
+unsigned char	*asn_parse_header(unsigned char *data, int *datalength, unsigned char *type);
+unsigned char	*asn_build_header(unsigned char *data, int *datalength, unsigned char type, int length);
+unsigned char	*asn_build_sequence(unsigned char *data, int *datalength, unsigned char type, int length);
+unsigned char	*asn_parse_length(unsigned char *data, unsigned long *datalength);
+unsigned char	*asn_build_length(unsigned char *data, int *datalength, int length);
+unsigned char	*asn_parse_objid(unsigned char	*data, int *datalength, unsigned char *type, oid *objid, int *objidlength);
+unsigned char	*asn_build_objid(unsigned char	*data, int *datalength, unsigned char type, oid *objid, int objidlength);
+unsigned char	*asn_parse_null(unsigned char *data, int *datalength, unsigned char *type);
+unsigned char	*asn_build_null(unsigned char *data, int *datalength, unsigned char type);
+unsigned char	*asn_parse_bitstring();
+unsigned char	*asn_build_bitstring();
+unsigned char	*asn_parse_unsigned_int64();
+unsigned char	*asn_build_unsigned_int64();
diff -ru -ruN apache_1.3.34_orig/src/modules/snmp_agt/src_snmp/snmp.h apache_1.3.34/src/modules/snmp_agt/src_snmp/snmp.h
--- apache_1.3.34_orig/src/modules/snmp_agt/src_snmp/snmp.h	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/src/modules/snmp_agt/src_snmp/snmp.h	2006-05-18 16:49:19.298763344 +0200
@@ -0,0 +1,141 @@
+/* ====================================================================
+ * Copyright (c) 1997 - 2000 
+ *                      SMASH, Harrie Hazewinkel.  All rights reserved.
+ *
+ * This product is developed by Harrie Hazewinkel and updates the
+ * original SMUT compiler made as his graduation project at the
+ * University of Twente.
+ *
+ * SMASH is a software package containing an SNMP MIB compiler and
+ * an SNMP agent system. The package can be used for development
+ * of monolithic SNMP agents and contains a compiler which compiles
+ * MIB definitions into C-code to developed an SNMP agent.
+ * More information about him and this software product can
+ * be found on http://www.simpleweb.org/software/packages/smash.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by Harrie Hazewinkel"
+ *
+ * 4. The name of the Copyright holder must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission.
+ *
+ * 5. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by Harrie Hazewinkel"
+ *    Also acknowledged are:
+ *    - The Simple group of the University of Twente,
+ *          http://www.simpleweb.org/
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR, ITS DISTRIBUTORS
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================*/
+#ifndef _SNMP_H_
+#define _SNMP_H_
+
+/* The standard SNMP-ports */
+#define SNMP_PORT               161
+#define SNMP_TRAP_PORT          162
+
+/* The maximum accepted packet length */
+#define SNMP_MAX_MSG_LENGTH		1500
+#define SNMP_MAX_COMMUNITY_LENGTH	1500
+
+
+/* SNMP versions */
+#define SNMP_VERSION_1      0
+#define SNMP_VERSION_2C     1
+#define SNMP_VERSION_2      2
+#define SNMP_VERSION_3      3
+
+/* The SNMP Protocol Data Units */
+#define SNMP_GET_REQ_PDU		(ASN_CONTEXT | ASN_CONSTRUCTOR | 0x0)
+#define SNMP_GETNEXT_REQ_PDU		(ASN_CONTEXT | ASN_CONSTRUCTOR | 0x1)
+#define SNMP_GET_RSP_PDU		(ASN_CONTEXT | ASN_CONSTRUCTOR | 0x2)
+#define SNMP_SET_REQ_PDU		(ASN_CONTEXT | ASN_CONSTRUCTOR | 0x3)
+#define SNMP_TRP_REQ_PDU		(ASN_CONTEXT | ASN_CONSTRUCTOR | 0x4)
+#define SNMP_GETBULK_REQ_PDU		(ASN_CONTEXT | ASN_CONSTRUCTOR | 0x5)
+#define SNMP_INFORM_REQ_PDU		(ASN_CONTEXT | ASN_CONSTRUCTOR | 0x6)
+#define SNMP_TRP2_REQ_PDU		(ASN_CONTEXT | ASN_CONSTRUCTOR | 0x7)
+#define SNMP_REPORT_PDU			(ASN_CONTEXT | ASN_CONSTRUCTOR | 0x8)
+
+/* SNMP version 1 error-codes */
+#define SNMP_ERROR_NOERROR		(0x0)
+#define SNMP_ERROR_TOOBIG		(0x1)
+#define SNMP_ERROR_NOSUCHNAME		(0x2)
+#define SNMP_ERROR_BADVALUE		(0x3)
+#define SNMP_ERROR_READONLY		(0x4)
+#define SNMP_ERROR_GENERR		(0x5)
+
+/* SNMP version 2 error-codes */
+#define SNMP_ERROR_NOACCESS		(0x6)
+#define SNMP_ERROR_WRONGTYPE		(0x7)
+#define SNMP_ERROR_WRONGLENGTH		(0x8)
+#define SNMP_ERROR_WRONGENCODING	(0x9)
+#define SNMP_ERROR_WRONGVALUE		(0x10)
+#define SNMP_ERROR_NOCREATION		(0x11)
+#define SNMP_ERROR_INCONSISTENTVALUE	(0x12)
+#define SNMP_ERROR_RESOURCEUNAVAILABLE	(0x13)
+#define SNMP_ERROR_COMMITFAILED		(0x14)
+#define SNMP_ERROR_UNDOFAILED		(0x15)
+#define SNMP_ERROR_AUTHORIZATIONERROR	(0x16)
+#define SNMP_ERROR_NOTWRITABLE		(0x17)
+#define SNMP_ERROR_INCONSISTENTNAME	(0x18)
+
+#define SNMP_TRAP_COLDSTART		(0x0)
+#define SNMP_TRAP_WARMSTART		(0x1)
+#define SNMP_TRAP_LINKDOWN		(0x2)
+#define SNMP_TRAP_LINKUP		(0x3)
+#define SNMP_TRAP_AUTHFAIL		(0x4)
+#define SNMP_TRAP_EGPNEIGHBORLOSS	(0x5)
+#define SNMP_TRAP_ENTERPRISESPECIFIC	(0x6)
+
+/* SNMP VarBinds. */
+#define SNMP_NOSUCHOBJECT    (ASN_CONTEXT | ASN_PRIMITIVE | 0x0)
+#define SNMP_NOSUCHINSTANCE  (ASN_CONTEXT | ASN_PRIMITIVE | 0x1)
+#define SNMP_ENDOFMIBVIEW    (ASN_CONTEXT | ASN_PRIMITIVE | 0x2)
+
+
+/* Object Syntax - universal types */
+#define SNMP_INTEGER     ASN_INTEGER
+#define SNMP_STRING      ASN_OCTET_STR
+#define SNMP_OBJID       ASN_OBJECT_ID
+#define SNMP_NULLOBJ     ASN_NULL
+#define SNMP_BITSTRING   ASN_BIT_STR
+#define SNMP_BITS        ASN_BIT_STR
+
+/* Object Syntax - application types */
+#define SNMP_IPADDRESS   (ASN_APPLICATION | 0)
+#define SNMP_COUNTER     (ASN_APPLICATION | 1)
+#define SNMP_GAUGE       (ASN_APPLICATION | 2)
+#define SNMP_UINTEGER    (ASN_APPLICATION | 2)
+#define SNMP_TIMETICKS   (ASN_APPLICATION | 3)
+#define SNMP_OPAQUE      (ASN_APPLICATION | 4)
+#define SNMP_NSAP        (ASN_APPLICATION | 5)
+#define SNMP_COUNTER64   (ASN_APPLICATION | 6)
+
+
+#endif /* _SNMP_H_ */
diff -ru -ruN apache_1.3.34_orig/src/modules/snmp_agt/src_snmp/snmp_community.c apache_1.3.34/src/modules/snmp_agt/src_snmp/snmp_community.c
--- apache_1.3.34_orig/src/modules/snmp_agt/src_snmp/snmp_community.c	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/src/modules/snmp_agt/src_snmp/snmp_community.c	2006-05-18 16:49:19.297763496 +0200
@@ -0,0 +1,133 @@
+/* ====================================================================
+ * Copyright (c) 1997 - 2000 
+ *                      SMASH, Harrie Hazewinkel.  All rights reserved.
+ *
+ * This product is developed by Harrie Hazewinkel and updates the
+ * original SMUT compiler made as his graduation project at the
+ * University of Twente.
+ *
+ * SMASH is a software package containing an SNMP MIB compiler and
+ * an SNMP agent system. The package can be used for development
+ * of monolithic SNMP agents and contains a compiler which compiles
+ * MIB definitions into C-code to developed an SNMP agent.
+ * More information about him and this software product can
+ * be found on http://www.simpleweb.org/software/packages/smash/.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by Harrie Hazewinkel"
+ *
+ * 4. The name of the Copyright holder must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission.
+ *
+ * 5. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by Harrie Hazewinkel"
+ *    Also acknowledged are:
+ *    - The Simple group of the University of Twente,
+ *          http://wwwsnmp.cs.utwente.nl/
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR, ITS DISTRIBUTORS
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================*/
+/* Apache config include */
+#include "ap_config.h"
+
+/* General includes */
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <strings.h>
+
+/* SNMP engine includes */
+#include "snmp_config.h"
+#include	"asn1.h"
+#include	"snmp.h"
+#include	"agt_engine.h"
+#include	"snmp_community.h"
+
+
+Community_t	communities[ MAX_COMMUNITIES ] = {
+		{"", 0, 0}, {"", 0, 0}, {"", 0, 0}, {"", 0, 0}, {"", 0, 0}, 
+		{"", 0, 0}, {"", 0, 0}, {"", 0, 0}, {"", 0, 0}, {"", 0, 0}} ;
+int		nr_communities = 0;
+		
+char	*set_community(FILE *f, char *arg)
+{
+int	i;
+
+    for (i = 0; i < nr_communities ; i++) {
+    	if (0 == strcmp(communities[i].string, arg)) {
+            return NULL;
+    	}
+    }
+    nr_communities++;
+    if (nr_communities < MAX_COMMUNITIES) {
+        strcpy(communities[i].string, arg);
+        communities[i].length = strlen(arg);
+        communities[i].number = nr_communities;
+        return NULL;
+    }
+    return "Could not add community";
+}
+
+
+void ensure_communities(void)
+{
+    if(nr_communities == 0) {
+        fprintf(stderr,"Warning: NO communities defined, SNMP access set to '" DEFAULT_COMM "' !\n");
+	nr_communities = 1;
+	strcpy(communities[0].string, DEFAULT_COMM);
+	communities[0].length = strlen(DEFAULT_COMM);
+	communities[0].number = 1;
+    }
+}
+
+
+unsigned char	*snmp_parse_community(unsigned char *data, int *length,
+	snmp_info_t *mesg)
+{
+unsigned char		type;
+int		i;
+
+    data = asn_parse_string(data, length, &type, 
+		mesg->community, &(mesg->community_length));
+    if (data == NULL){
+	return NULL;
+    }
+    for (i  = 0 ; i < nr_communities ; i++){
+	if ((mesg->community_length == communities[i].length)
+		&& !(memcmp((char *)mesg->community, communities[i].string,
+						mesg->community_length))) {
+	    mesg->community_id = communities[i].number;
+	    return (unsigned char *)data;
+	}
+    }
+    return NULL;
+}
+
+
diff -ru -ruN apache_1.3.34_orig/src/modules/snmp_agt/src_snmp/snmp_community.h apache_1.3.34/src/modules/snmp_agt/src_snmp/snmp_community.h
--- apache_1.3.34_orig/src/modules/snmp_agt/src_snmp/snmp_community.h	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/src/modules/snmp_agt/src_snmp/snmp_community.h	2006-05-18 16:49:19.298763344 +0200
@@ -0,0 +1,76 @@
+/* ====================================================================
+ * Copyright (c) 1997 - 2000 
+ *                      SMASH, Harrie Hazewinkel.  All rights reserved.
+ *
+ * This product is developed by Harrie Hazewinkel and updates the
+ * original SMUT compiler made as his graduation project at the
+ * University of Twente.
+ *
+ * SMASH is a software package containing an SNMP MIB compiler and
+ * an SNMP agent system. The package can be used for development
+ * of monolithic SNMP agents and contains a compiler which compiles
+ * MIB definitions into C-code to developed an SNMP agent.
+ * More information about him and this software product can
+ * be found on http://www.simpleweb.org/software/packages/smash/.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by Harrie Hazewinkel"
+ *
+ * 4. The name of the Copyright holder must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission.
+ *
+ * 5. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by Harrie Hazewinkel"
+ *    Also acknowledged are:
+ *    - The Simple group of the University of Twente,
+ *          http://wwwsnmp.cs.utwente.nl/
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR, ITS DISTRIBUTORS
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================*/
+#ifndef _SNMP_COMMUNITIES_H_
+#define _SNMP_COMMUNITIES_H_
+
+#define	MAX_COMMUNITIES		10 
+#define MAX_COMMUNITY_LEN       64
+#define DEFAULT_COMM		"public"
+
+typedef struct {
+    char                        string[MAX_COMMUNITY_LEN];
+    int                         length;
+    int                         number;
+    } Community_t;
+
+
+char	*set_community(FILE *f, char *arg);
+unsigned char *snmp_parse_community(unsigned char *data, int *length,
+        snmp_info_t *record);
+void ensure_communities(void);
+
+#endif /* _SNMP_COMMUNITIES_H_ */
+
diff -ru -ruN apache_1.3.34_orig/src/modules/snmp_agt/src_snmp/snmp_config.h apache_1.3.34/src/modules/snmp_agt/src_snmp/snmp_config.h
--- apache_1.3.34_orig/src/modules/snmp_agt/src_snmp/snmp_config.h	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/src/modules/snmp_agt/src_snmp/snmp_config.h	2006-05-18 16:49:19.297763496 +0200
@@ -0,0 +1,11 @@
+#ifndef _snmp_config_h_
+#define _snmp_config_h_
+
+#ifdef DEBUG
+#define SNMP_DEBUG(string)      printf("%s(%d): %s\n",__FILE__, __LINE__, string);
+#else
+#define SNMP_DEBUG(string)
+#endif
+
+
+#endif /* _snmp_config_h_ */
diff -ru -ruN apache_1.3.34_orig/src/modules/snmp_agt/www-mib.c apache_1.3.34/src/modules/snmp_agt/www-mib.c
--- apache_1.3.34_orig/src/modules/snmp_agt/www-mib.c	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/src/modules/snmp_agt/www-mib.c	2006-05-18 16:49:19.295763800 +0200
@@ -0,0 +1,1157 @@
+/* ====================================================================
+ * Copyright (c) 1997-2000 Harrie Hazewinkel.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by Harrie Hazewinkel."
+ *
+ * 4. The name of the Copyright holder must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission.
+ *
+ * 5. Products derived from this software may not be called "MOD-SNMP"
+ *    nor may "MOD-SNMP" appear in their names  without prior written
+ *    permission of the Harrie Hazewinkel.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by Harrie Hazewinkel"
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * The creator of this module is harrie@mod-snmp.com
+ * This file contains generated code of SMASH also created by Harrie.
+ *
+ *
+ */
+
+/* Apache includes */
+#include "httpd.h"
+#include "scoreboard.h"
+#include "http_config.h"
+
+/* SNMP includes */
+#include "asn1.h"
+#include "snmp.h"
+#include "agt_engine.h"
+#include "agt_mib.h"
+#include "www-mib.h"
+#include "snmpv2-mib.h"
+
+#include "mod_snmp.h"
+
+
+#ifndef MIN
+#define MIN(A,B)	A<B?A:B
+#endif
+
+extern server_rec       *www_services;
+extern scoreboard	*ap_scoreboard_image;
+
+/* WWW_MIB initialisation (must also register the MIB module tree */
+void init_WWW_MIB()
+{
+
+    register_subtrees_of_WWW_MIB();
+    /* insert the Object Resource in sysORTable */
+    { static struct sysOREntry_struct value = { NULL, 1, {7, {O_wwwMIB}}, "The WWW service MIB module", 0};
+      insert_sysOREntry(&value);
+    }
+
+}
+
+
+
+void
+init_wwwServiceOperStatus()
+{
+int i;
+
+    if (ap_scoreboard_image) {
+	for (i=0; i < HARD_VIRTUAL_HOST_MAX ; i++) {
+	    ap_scoreboard_image->global.operStatus[i] = VHOST_RUNNING;
+	}
+    }
+}
+
+int
+vHostOperational(int hostNr)
+{
+    if (ap_scoreboard_image->global.operStatus[ hostNr ] == VHOST_RUNNING)
+	return(0);
+    return(1);
+}
+
+
+int
+getOperStatusOf(int hostNr)
+{
+    return(ap_scoreboard_image->global.operStatus[hostNr]);
+}
+
+int
+getLastChangeOf(int hostNr)
+{
+    return(ap_scoreboard_image->global.lastChange[hostNr]);
+}
+
+
+server_rec *
+serviceIndexCreation(int searchType, server_rec *server,
+	Oid *req_oid, Oid *var_oid)
+{
+int	var_oidlen = var_oid->namelen++;
+
+    while (server) {
+        var_oid->name[ var_oidlen ] = (server->vhost_index) + 1;
+        switch (searchType) {
+            case NEXT:
+                if ( 0 > compare(req_oid, var_oid)) {
+                    return(server);
+                }
+                break;
+            case EXACT:
+                if ( 0 == compare(req_oid, var_oid)) {
+                    return(server);
+                }
+                break;
+            case INDEX:
+                if ( 0 >= compare_tree(req_oid, var_oid)) {
+                    return(server);
+                }
+                break;
+        }
+        server = server->next;
+    }
+    return(NULL);
+}
+
+unsigned char *
+var_wwwServiceEntry( int *var_len,
+	Oid *newoid, Oid *reqoid, int searchType,
+	snmp_info_t *mesg, int (**write_method)()	)
+{
+static oid	protocol_oid[] = { O_mib_2, 6, 80 };
+int		column = newoid->name[11];
+server_rec	*service;
+
+    service = serviceIndexCreation(searchType, www_services, reqoid, newoid);
+    if (!service) {
+	return NULL; 
+    }
+
+    *write_method = 0;
+    *var_len = sizeof(long);
+    switch (column) {
+/*	case I_wwwServiceIndex:
+	    return (unsigned char *) NULL; not-accesible */
+	case I_wwwServiceDescription:
+	    strcpy(return_buf, SERVER_VERSION " - " SERVER_PROTOCOL " - " SNMP_AGT_VERSION); 
+	    *var_len = strlen(return_buf);
+	    return (unsigned char *) return_buf;
+	case I_wwwServiceContact:
+	    *var_len = strlen(service->server_admin);
+	    return (unsigned char *) service->server_admin;
+	case I_wwwServiceProtocol:
+	    *var_len = sizeof(protocol_oid);
+	    return (unsigned char *) protocol_oid;
+	case I_wwwServiceName:
+	    *var_len = strlen(service->server_hostname);
+	    return (unsigned char *) service->server_hostname;
+	case I_wwwServiceType:
+	    long_return = 2; /* server only */
+	    return (unsigned char *) &long_return;
+	case I_wwwServiceStartTime:
+	    *var_len = snmp_time2DateAndTime(ap_restart_time, return_buf);
+	    return (unsigned char *) return_buf;
+	case I_wwwServiceOperStatus:
+	    long_return = getOperStatusOf(service->vhost_index);
+	    return (unsigned char *) &long_return;
+	case I_wwwServiceLastChange:
+	    *var_len = snmp_time2DateAndTime(ap_restart_time, return_buf);
+	    return (unsigned char *) return_buf;
+        default:
+            return NULL;
+    }
+}
+
+unsigned char *
+var_wwwSummaryEntry(	int *var_len,
+	Oid *newoid, Oid *reqoid, int searchType,
+	snmp_info_t *mesg, int (**write_method)()	)
+{
+int		column = newoid->name[11];
+WwwStats	*wwwStats;
+server_rec	*service;
+
+    service = serviceIndexCreation(searchType, www_services, reqoid, newoid);
+    if (!service) {
+	return NULL;
+    }
+    wwwStats = service->snmp_www_stats;
+    *var_len = sizeof(long);
+
+    switch (column) {
+	case I_wwwSummaryInRequests:
+	    return (unsigned char *) &(wwwStats->summaryInRequests);
+	case I_wwwSummaryOutRequests:
+	    return (unsigned char *) NULL;
+	case I_wwwSummaryInResponses:
+	    return (unsigned char *) NULL;
+	case I_wwwSummaryOutResponses:
+	    return (unsigned char *) &(wwwStats->summaryOutResponses);
+	case I_wwwSummaryInBytes:
+	    return (unsigned char *) NULL;
+	case I_wwwSummaryInLowBytes:
+	    return (unsigned char *) &(wwwStats->summaryInLowBytes);
+	case I_wwwSummaryOutBytes:
+	    return (unsigned char *) NULL;
+	case I_wwwSummaryOutLowBytes:
+	    return (unsigned char *) &(wwwStats->summaryOutLowBytes);
+        default:
+            return NULL;
+    }
+}
+
+
+int
+methodIndexCreation( int searchType, Oid *req_oid, Oid *var_oid)
+{
+int     methodArrayIndex;
+int     i, result;
+int	var_oidlen = var_oid->namelen + 1;
+
+    /* NOTE: "METHODS-1", since INVALID is also included in METHODS */
+    for(methodArrayIndex=0; methodArrayIndex < METHODS -1; methodArrayIndex++) {
+
+        var_oid->name[ var_oidlen - 1 ] = strlen(requestTypes[methodArrayIndex]);
+
+        /* build the OID string from the chars as in the status_codes.h
+         * file; which is automatically made from httpd.h; NOTE that things
+         * barf horribly if the httpd.h file and this status_codes.h file
+         * are out of sync! Also note that the sort order is of importance.
+         */
+        for(i=0;i<strlen(requestTypes[methodArrayIndex]);i++)
+                var_oid->name[ var_oidlen + i ] = requestTypes[methodArrayIndex][i];
+	var_oid->namelen =  var_oidlen + i;
+        result = compare(req_oid, var_oid);
+        /* return, depending of the type of search we are doing
+	 * if (searchType == EXACT and result == 0) OR
+	 *    (searchType == NEXT  and result <  0)
+	 */
+        if (((searchType == EXACT) && (result == 0)) ||
+			((searchType == NEXT) && (result < 0))) {
+            return(methodArrayIndex);
+        } /* if */
+
+     } /* for loop */
+return(-1);
+}
+
+#ifdef WWW_REQUEST_IN_GROUP
+unsigned char *
+var_wwwRequestInEntry(	int *var_len,
+	Oid *newoid, Oid *reqoid, int searchType,
+	snmp_info_t *mesg, int (**write_method)()	)
+{
+int		column = newoid->name[11];
+WwwStats	*wwwStats;
+server_rec	*service = www_services;
+int		methodIndex;
+
+    do {
+        service = serviceIndexCreation(INDEX, service, reqoid, newoid);
+        if (!service) return(NULL);
+	wwwStats = service->snmp_www_stats;
+	if (wwwStats) {
+            methodIndex = methodIndexCreation(searchType, reqoid, newoid) ;
+            if ( methodIndex < 0 ) {
+		service = service->next;
+		newoid->namelen = 12;
+	    }
+	} else {
+	    methodIndex = -1;
+	}
+    } while ( methodIndex < 0 );
+
+    *var_len = sizeof(long);    /* default length */
+    switch (column) {
+/*	case I_wwwRequestInIndex:
+	    return (unsigned char *) NULL; not-accessable */
+	case I_wwwRequestInRequests:
+	    return (unsigned char *) &(wwwStats->requestInEntries[methodIndex].count);
+	case I_wwwRequestInBytes:
+	    return (unsigned char *) &(wwwStats->requestInEntries[methodIndex].bytes);
+	case I_wwwRequestInLastTime:
+	    *var_len = snmp_time2DateAndTime(wwwStats->requestInEntries[methodIndex].lastTime, return_buf);
+	    return (unsigned char *) return_buf;
+        default:
+            return NULL;
+    }
+}
+#endif
+
+#ifdef WWW_REQUEST_OUT_GROUP
+unsigned char *
+var_wwwRequestOutEntry(	int *var_len,
+	Oid *newoid, Oid *reqoid, int searchType,
+	snmp_info_t *mesg, int (**write_method)()	)
+{
+int     column = newoid->name[11];
+/* Variables defined */
+int	result;
+
+/* Check OID */
+    result = compare(reqoid, newoid);
+    if (((searchType == EXACT) && (result != 0)) ||
+        ((searchType == NEXT) && (result >= 0)))
+        return NULL;
+
+    *write_method = 0;
+    *var_len = sizeof(long);    /* default length */
+
+    switch (column) {
+	case I_wwwRequestOutIndex:
+	    return (unsigned char *) NULL;
+	case I_wwwRequestOutRequests:
+	    return (unsigned char *) NULL;
+	case I_wwwRequestOutBytes:
+	    return (unsigned char *) NULL;
+	case I_wwwRequestOutLastTime:
+	    return (unsigned char *) NULL;
+        default:
+            return NULL;
+    }
+}
+#endif /* WWW_REQUEST_OUT_GROUP */
+
+#ifdef WWW_RESPONSE_OUT_GROUP
+int
+responseCodeIndexCreation(int searchType, Oid *req_oid, Oid *var_oid  )
+{
+int	responseArrayIndex;
+int	result;
+int	var_oidLen = var_oid->namelen++;
+
+    responseArrayIndex = 0;
+    while (responseTypes[ responseArrayIndex ] > 0) {
+	var_oid->name[ var_oidLen ] = responseTypes[responseArrayIndex];
+	result = compare(req_oid, var_oid);
+	if (((searchType == EXACT) && (result == 0)) || ((searchType == NEXT) && (0 > result))) {
+	    return(responseArrayIndex);
+	} /* if */
+	responseArrayIndex++;
+    } /* for */
+return(-1);
+}
+#endif
+
+#ifdef WWW_RESPONSE_IN_GROUP
+unsigned char *
+var_wwwResponseInEntry(	int *var_len,
+	Oid *newoid, Oid *reqoid, int searchType,
+	snmp_info_t *mesg, int (**write_method)()	)
+{
+int     column = newoid->name[(newoid->namelen - 1)];
+int	result;
+
+    /* Check OID */
+    result = compare(reqoid, newoid);
+    if (((searchType == EXACT) && (result != 0)) ||
+        ((searchType == NEXT) && (result >= 0)))
+        return NULL;
+
+    *write_method = 0;
+    *var_len = sizeof(long);    /* default length */
+
+    switch (column) {
+	case I_wwwResponseInIndex:
+	    return (unsigned char *) NULL;
+	case I_wwwResponseInResponses:
+	    return (unsigned char *) NULL;
+	case I_wwwResponseInBytes:
+	    return (unsigned char *) NULL;
+	case I_wwwResponseInLastTime:
+	    return (unsigned char *) NULL;
+        default:
+            return NULL;
+    }
+}
+#endif /* WWW_RESPONSE_IN_GROUP */
+
+#ifdef WWW_RESPONSE_OUT_GROUP
+unsigned char *
+var_wwwResponseOutEntry( int *var_len,
+	Oid *newoid, Oid *reqoid, int searchType,
+	snmp_info_t *mesg, int (**write_method)()	)
+{
+int		column = newoid->name[11];
+WwwStats	*wwwStats;
+server_rec	*service = www_services;
+int		responseIndex;
+
+    do {
+	service = serviceIndexCreation(INDEX, service, reqoid, newoid);
+	if (!service) {
+	    return(NULL);
+	}
+	wwwStats = service->snmp_www_stats;
+	if (wwwStats) {
+	    responseIndex = responseCodeIndexCreation(searchType, reqoid, newoid);
+            if ( responseIndex < 0 ) {
+		service =  service->next;
+		newoid->namelen = 12;
+	    }
+        } else {
+	    responseIndex = -1;
+	}
+    } while ( responseIndex < 0 );
+
+    *var_len = sizeof(long);    /* default length */
+    switch (column) {
+/*	case I_wwwResponseOutIndex:
+	    return (unsigned char *) NULL; */
+	case I_wwwResponseOutResponses:
+	    return (unsigned char *) &(wwwStats->responseOutEntries[responseIndex].count);
+	case I_wwwResponseOutBytes:
+	    return (unsigned char *) &(wwwStats->responseOutEntries[responseIndex].bytes);
+	case I_wwwResponseOutLastTime:
+	    *var_len = snmp_time2DateAndTime(wwwStats->responseOutEntries[responseIndex].lastTime, return_buf);
+	    return (unsigned char *) return_buf;
+        default:
+            return NULL;
+    }
+}
+#endif /* WWW_RESPONSE_OUT_GROUP */
+#ifdef WWW_DOCUMENTS_GROUP
+server_rec *get_wwwService_with_index(int index)
+{
+server_rec *service = www_services;
+
+    index--;
+    while (service) {
+	if (service->vhost_index == index) {
+	    return(service);
+	}
+	service = service->next;
+    }
+    return(NULL);
+}
+
+/* An entry used to configure the wwwDocLastNTable,
+ * the wwwDocBucketTable, the wwwDocAccessTopNTable,
+ * and the wwwDocBytesTopNTable.
+ */
+int
+write_wwwDocCtrlLastNSize(int action,
+	unsigned char *var_val, unsigned char var_val_type, int var_val_len,
+	unsigned char *statP, Oid *setoid)
+{
+int size = 4;
+int wwwServiceIndex = setoid->name[ setoid->namelen - 1];
+server_rec *wwwService = get_wwwService_with_index(wwwServiceIndex);
+WwwStats *wwwServiceSnmpData;
+
+    if (wwwService == NULL) {
+        return(SNMP_ERROR_NOTWRITABLE);
+    }
+    wwwServiceSnmpData = wwwService->snmp_www_stats;
+    if (wwwServiceSnmpData == NULL) {
+        return(SNMP_ERROR_NOTWRITABLE);
+    }
+
+    switch (action) {
+    case CHECK:
+	if (var_val_type != SNMP_UINTEGER) {
+	    return SNMP_ERROR_WRONGTYPE;
+	}
+        if (NULL == asn_parse_int(var_val, &size, &var_val_type,
+	        (long *)&(wwwServiceSnmpData->snmpset_temp_docCtrlLastNSize),
+		sizeof (unsigned long))) {
+	    return(PARSE_ERROR);
+	}
+	if ((wwwServiceSnmpData->snmpset_temp_docCtrlLastNSize < 0) || (wwwServiceSnmpData->snmpset_temp_docCtrlLastNSize > MAX_LASTNSIZE)) {
+	    return SNMP_ERROR_WRONGVALUE;
+	}
+	break; 
+    case COMMIT:
+	wwwServiceSnmpData->docCtrlLastNSize = wwwServiceSnmpData->snmpset_temp_docCtrlLastNSize;
+	break;
+    case FREE:
+	break;
+    }
+    return SNMP_ERROR_NOERROR;
+}
+
+int
+write_wwwDocCtrlBuckets(int action,
+	unsigned char *var_val, unsigned char var_val_type, int var_val_len,
+	unsigned char *statP, Oid *setoid)
+{
+int size = 4;
+int wwwServiceIndex = setoid->name[ setoid->namelen - 1];
+server_rec *wwwService = get_wwwService_with_index(wwwServiceIndex);
+WwwStats *wwwServiceSnmpData;
+
+    if (wwwService == NULL) {
+        return(SNMP_ERROR_NOTWRITABLE);
+    }
+    wwwServiceSnmpData = wwwService->snmp_www_stats;
+    if (wwwServiceSnmpData == NULL) {
+        return(SNMP_ERROR_NOTWRITABLE);
+    }
+
+    switch (action) {
+    case CHECK:
+	if (var_val_type != SNMP_UINTEGER) {
+	    return SNMP_ERROR_WRONGTYPE;
+	}
+        if (NULL == asn_parse_int(var_val, &size, &var_val_type,
+	        (long *)&(wwwServiceSnmpData->snmpset_temp_docCtrlBuckets),
+		sizeof (unsigned long))) {
+	    return(PARSE_ERROR);
+	}
+	if ((wwwServiceSnmpData->snmpset_temp_docCtrlBuckets < 0) || (wwwServiceSnmpData->snmpset_temp_docCtrlBuckets > MAX_BUCKETS)) {
+	    return SNMP_ERROR_WRONGVALUE;
+	}
+	break; 
+    case COMMIT:
+	wwwServiceSnmpData->docCtrlBuckets = wwwServiceSnmpData->snmpset_temp_docCtrlBuckets;
+	break;
+    case FREE:
+	break;
+    }
+    return SNMP_ERROR_NOERROR;
+}
+
+int
+write_wwwDocCtrlBucketTimeInterval(int action,
+	unsigned char *var_val, unsigned char var_val_type, int var_val_len,
+	unsigned char *statP, Oid *setoid)
+{
+int size = 4;
+int wwwServiceIndex = setoid->name[ setoid->namelen - 1];
+server_rec *wwwService = get_wwwService_with_index(wwwServiceIndex);
+WwwStats *wwwServiceSnmpData;
+
+    if (wwwService == NULL) {
+        return(SNMP_ERROR_NOTWRITABLE);
+    }
+    wwwServiceSnmpData = wwwService->snmp_www_stats;
+    if (wwwServiceSnmpData == NULL) {
+        return(SNMP_ERROR_NOTWRITABLE);
+    }
+
+    switch (action) {
+    case CHECK:
+	if (var_val_type != SNMP_UINTEGER) {
+	    return SNMP_ERROR_WRONGTYPE;
+	}
+        if (NULL == asn_parse_int(var_val, &size, &var_val_type,
+	        (long *)&(wwwServiceSnmpData->snmpset_temp_docCtrlBucketTimeInterval),
+		sizeof (unsigned long))) {
+	    return(PARSE_ERROR);
+	}
+	/* We check here if the time is really in seconds. Although,	 */
+	/* it should milliseconds the "alarm()"-function knows only seconds */
+	/* We even protect ourselfs agains creating buckets each second. */
+	/* Only possible in multiples of 10 seconds. */
+	if ((wwwServiceSnmpData->snmpset_temp_docCtrlBucketTimeInterval % 1000) != 0) {
+	    return SNMP_ERROR_WRONGVALUE;
+	}
+	break; 
+    case COMMIT:
+	wwwServiceSnmpData->docCtrlBucketTimeInterval = wwwServiceSnmpData->snmpset_temp_docCtrlBucketTimeInterval;
+	break;
+    case FREE:
+	break;
+    }
+    return SNMP_ERROR_NOERROR;
+}
+
+int
+write_wwwDocCtrlTopNSize(int action,
+	unsigned char *var_val, unsigned char var_val_type, int var_val_len,
+	unsigned char *statP, Oid *setoid)
+{
+int size = 4;
+int wwwServiceIndex = setoid->name[ setoid->namelen - 1];
+server_rec *wwwService = get_wwwService_with_index(wwwServiceIndex);
+WwwStats *wwwServiceSnmpData;
+
+    if (wwwService == NULL) {
+        return(SNMP_ERROR_NOTWRITABLE);
+    }
+    wwwServiceSnmpData = wwwService->snmp_www_stats;
+    if (wwwServiceSnmpData == NULL) {
+        return(SNMP_ERROR_NOTWRITABLE);
+    }
+
+    switch (action) {
+    case CHECK:
+	if (var_val_type != SNMP_UINTEGER) {
+	    return SNMP_ERROR_WRONGTYPE;
+	}
+        if (NULL == asn_parse_int(var_val, &size, &var_val_type,
+	        (long *)&(wwwServiceSnmpData->snmpset_temp_docCtrlTopNSize),
+		sizeof (unsigned long))) {
+	    return(PARSE_ERROR);
+	}
+	if ((wwwServiceSnmpData->snmpset_temp_docCtrlTopNSize < 0) || (wwwServiceSnmpData->snmpset_temp_docCtrlTopNSize > MAX_TOPNSIZE)) {
+	    return SNMP_ERROR_WRONGVALUE;
+	}
+	break; 
+    case COMMIT:
+	wwwServiceSnmpData->docCtrlTopNSize = wwwServiceSnmpData->snmpset_temp_docCtrlTopNSize;
+	break;
+    case FREE:
+	break;
+    }
+    return SNMP_ERROR_NOERROR;
+}
+
+unsigned char *
+var_wwwDocCtrlEntry(int *var_len,
+	Oid *newoid, Oid *reqoid, int searchType,
+	snmp_info_t *mesg,
+	int (**write_method)(int, unsigned char *, unsigned char, int, unsigned char *, Oid *))
+{
+int		column = newoid->name[(newoid->namelen - 1)];
+server_rec	*service;
+WwwStats	*wwwStats;
+
+    service = serviceIndexCreation(searchType, www_services, reqoid, newoid);
+    if (!service) return(NULL);
+    wwwStats = service->snmp_www_stats;
+    if (!service->snmp_www_stats) return(NULL);
+    *var_len = sizeof(long);
+    switch (column) {
+	case I_wwwDocCtrlLastNSize:
+	    *write_method = write_wwwDocCtrlLastNSize;
+	    return (unsigned char *) &(wwwStats->docCtrlLastNSize);
+	case I_wwwDocCtrlLastNLock:
+	  /*	    *write_method = write_wwwDocCtrlLastNLock;*/
+	    *write_method = 0;
+	    return (unsigned char *) &(wwwStats->docCtrlLastNLock);
+	case I_wwwDocCtrlBuckets:
+	    *write_method = write_wwwDocCtrlBuckets;
+	    return (unsigned char *) &(wwwStats->docCtrlBuckets);
+	case I_wwwDocCtrlBucketTimeInterval:
+	    *write_method = write_wwwDocCtrlBucketTimeInterval;
+	    return (unsigned char *) &(wwwStats->docCtrlBucketTimeInterval);
+	case I_wwwDocCtrlTopNSize:
+	    *write_method = write_wwwDocCtrlTopNSize;
+	    return (unsigned char *) &(wwwStats->docCtrlTopNSize);
+        default:
+            return NULL;
+    }
+}
+
+
+WwwDocLastN *
+wwwDocLastNIndexCreation(int searchType, WwwStats *wwwStats,
+		Oid* req_oid, Oid *var_oid)
+{
+int	result;
+
+    if (!wwwStats) return(NULL);
+    if (!wwwStats->docLastNTable) return(NULL);
+    var_oid->namelen = 14;
+    if (0 < (int)(wwwStats->docLastNIndex - wwwStats->docCtrlLastNSize)) {
+	var_oid->name[13] = (wwwStats->docLastNIndex - wwwStats->docCtrlLastNSize);
+    } else {
+	var_oid->name[13] = 0;
+    }
+    while (++var_oid->name[13] <= wwwStats->docLastNIndex) {
+	result = compare(req_oid, var_oid);
+	if (((searchType == EXACT) && (result == 0)) ||
+		((searchType == NEXT) && (result < 0))) {
+	    return(&(wwwStats->docLastNTable[ var_oid->name[13] % MAX_LASTNSIZE ]));
+	}
+    }
+    return(NULL);
+}
+
+
+unsigned char *
+var_wwwDocLastNEntry(	int *var_len,
+	Oid *newoid, Oid *reqoid, int searchType,
+	snmp_info_t *mesg, int (**write_method)()	)
+{
+int     	column = newoid->name[11];
+server_rec	*service = www_services;
+WwwDocLastN	*currentRow;
+
+    do {
+	/* select first index 'wwwServiceIndex' */
+	service = serviceIndexCreation(INDEX, service, reqoid, newoid);
+	if (!service) return(NULL);
+
+	currentRow = wwwDocLastNIndexCreation(searchType,
+				service->snmp_www_stats, reqoid, newoid);
+	if (!currentRow) {
+	    service = service->next;	/* Go to next service		*/
+	    newoid->namelen = 12;	/* Reset length of variable oid */
+	}
+    } while (!currentRow);
+
+    *write_method = 0;
+    *var_len = sizeof(long);    /* default length */
+    switch (column) {
+    /*	case I_wwwDocLastNIndex: not-accessible
+	    return (unsigned char *) NULL; */
+	case I_wwwDocLastNName:
+	    *var_len = strlen(currentRow->docName);
+	    return (unsigned char *) currentRow->docName;
+	case I_wwwDocLastNTimeStamp:
+	    *var_len = snmp_time2DateAndTime(currentRow->requestTime,
+								return_buf);
+	    return (unsigned char *) return_buf;
+	case I_wwwDocLastNRequestType:
+	    if (currentRow->requestType == -1) {
+		*var_len = 0;
+		return (unsigned char *) return_buf;
+	    }
+	    *var_len = strlen(requestTypes[currentRow->requestType]);
+	    return (unsigned char *) requestTypes[currentRow->requestType];
+	case I_wwwDocLastNResponseType:
+	    if (currentRow->responseType) {
+		*var_len = sizeof(unsigned long);
+		return (unsigned char *) &responseTypes[currentRow->responseType];
+	    }
+	    return(NULL);
+	case I_wwwDocLastNStatusMsg:
+	    return(NULL);
+	    *var_len = strlen(currentRow->statusMsg);
+	    return (unsigned char *) currentRow->statusMsg;
+	case I_wwwDocLastNBytes:
+	    *var_len = sizeof(currentRow->docBytes);
+	    return (unsigned char *) &currentRow->docBytes;
+        default:
+            return NULL;
+    }
+}
+
+WwwDocBucket *
+wwwDocBucketIndexCreation(int searchType, WwwStats *wwwStats,
+                Oid* req_oid, Oid *var_oid)
+{
+int	result;
+
+    if (!wwwStats) return(NULL);
+    var_oid->namelen = 14;
+    if (0 < (int)(wwwStats->docBucketIndex - wwwStats->docCtrlBuckets)) {
+	var_oid->name[13] = wwwStats->docBucketIndex - wwwStats->docCtrlBuckets;
+    } else {
+	var_oid->name[13] = 0;
+    }
+    while ((++var_oid->name[13]) <= wwwStats->docBucketIndex) {
+	result = compare(req_oid, var_oid);
+	if (((searchType == EXACT) && (result == 0)) ||
+				((searchType == NEXT) && (0 > result))) {
+	    return(&(wwwStats->docBucketTable[ (int)var_oid->name[13] % MAX_BUCKETS ]));
+	}
+    }
+    var_oid->namelen = 12; /* Reset the var_oid length */
+    return(NULL);
+}
+
+
+unsigned char *
+var_wwwDocBucketEntry(	int *var_len,
+	Oid *newoid, Oid *reqoid, int searchType,
+	snmp_info_t *mesg, int (**write_method)()	)
+{
+int		column = newoid->name[11];
+server_rec	*service = www_services;
+WwwStats	*wwwStats;
+WwwDocBucket	*bucket;
+
+    do {
+	/* select first index 'wwwServiceIndex' */
+	service = serviceIndexCreation(INDEX, service, reqoid, newoid);
+	if (!service) return(NULL);
+	wwwStats = service->snmp_www_stats;
+	if (!wwwStats) return(NULL);
+	bucket = wwwDocBucketIndexCreation(searchType, wwwStats, reqoid, newoid);
+	if (!bucket) {
+	    service = service->next;
+	}
+    } while (!bucket);
+
+    *write_method = 0;
+    *var_len = sizeof(unsigned long);    /* default length */
+    switch (column) {
+    /*	case I_wwwDocBucketIndex:
+	    return (unsigned char *) NULL; */
+	case I_wwwDocBucketTimeStamp:
+	    *var_len = snmp_time2DateAndTime(bucket->bucketCreateTime,
+								return_buf);
+	    return (unsigned char *) return_buf;
+	case I_wwwDocBucketAccesses:
+	    return (unsigned char *) &(bucket->accesses);
+	case I_wwwDocBucketDocuments:
+	    return (unsigned char *) &(bucket->documents);
+	case I_wwwDocBucketBytes:
+	    return (unsigned char *) &(bucket->bytes);
+        default:
+            return NULL;
+    }
+}
+WwwDocTopN *
+wwwDocTopNIndexCreation(int searchType, WwwStats *wwwStats, int whichTopN,
+	Oid *req_oid, Oid *var_oid)
+{
+int		result;
+WwwDocBucket	*bucket;
+int		topNSize;
+
+    if (!wwwStats) return(NULL);
+    if (0 < (int)(wwwStats->docBucketIndex - wwwStats->docCtrlBuckets)) {
+	var_oid->name[13] = wwwStats->docBucketIndex - wwwStats->docCtrlBuckets;
+    } else {
+	var_oid->name[13] = 0;
+    }
+    var_oid->namelen = 15;
+    while ((++var_oid->name[13]) <= wwwStats->docBucketIndex) {
+	bucket = &(wwwStats->docBucketTable[ var_oid->name[13] % MAX_BUCKETS ]);
+	topNSize = MIN(bucket->documents, MIN(wwwStats->docCtrlTopNSize, 25));
+	var_oid->name[14] = 0;
+	while ((++var_oid->name[14]) <= topNSize) {
+	     result = compare(req_oid, var_oid);
+	     if (((searchType == EXACT) && (result == 0)) ||
+				((searchType == NEXT) && (result < 0))) {
+		if (whichTopN == 0) {
+		     return(&(bucket->accessTopNTable[(var_oid->name[14] - 1)]));
+		} else {
+		     return(&(bucket->bytesTopNTable[(var_oid->name[14] - 1)]));
+		}
+	     }
+	}
+    }
+    var_oid->namelen = 12; /* Reset the var_oid length */
+    return(NULL);
+}
+
+unsigned char *
+var_wwwDocAccessTopNEntry( int *var_len,
+	Oid *newoid, Oid *reqoid, int searchType,
+	snmp_info_t *mesg, int (**write_method)()	)
+{
+int		column = newoid->name[11];
+server_rec      *service = www_services;
+WwwStats	*wwwStats;
+WwwDocTopN	*currentRow;
+
+    do {
+	/* select first index 'wwwServiceIndex' */
+	service = serviceIndexCreation(INDEX, service, reqoid, newoid);
+	if (!service) return(NULL);
+	wwwStats = service->snmp_www_stats;
+	currentRow = wwwDocTopNIndexCreation(searchType, wwwStats, 0, reqoid, newoid);
+	if (!currentRow) {
+	    service = service->next;
+	}
+    } while (!currentRow);
+
+    switch (column) {
+	case I_wwwDocAccessTopNIndex:
+	    return (unsigned char *) NULL;
+	case I_wwwDocAccessTopNName:
+	    *var_len = strlen(currentRow->name);
+	    return (unsigned char *) currentRow->name;
+	case I_wwwDocAccessTopNAccesses:
+	    *var_len = sizeof(currentRow->accesses);
+	    return (unsigned char *) &(currentRow->accesses);
+	case I_wwwDocAccessTopNBytes:
+	    *var_len = sizeof(currentRow->bytes);
+	    return (unsigned char *) &(currentRow->bytes);
+	case I_wwwDocAccessTopNLastResponseType:
+	    *var_len = sizeof(currentRow->lastResponseType);
+	    return (unsigned char *) &responseTypes[currentRow->lastResponseType];
+        default:
+            return NULL;
+    }
+}
+
+unsigned char *
+var_wwwDocBytesTopNEntry( int *var_len,
+	Oid *newoid, Oid *reqoid, int searchType,
+	snmp_info_t *mesg, int (**write_method)()	)
+{
+int		column = newoid->name[11];
+server_rec      *service = www_services;
+WwwStats	*wwwStats;
+WwwDocTopN	*currentRow;
+
+    do {
+	/* select first index 'wwwServiceIndex' */
+	service = serviceIndexCreation(INDEX, service, reqoid, newoid);
+	if (!service) return(NULL);
+	wwwStats =  service->snmp_www_stats;
+	currentRow = wwwDocTopNIndexCreation(searchType, wwwStats, 1, reqoid, newoid);
+	if (!currentRow) {
+	    service = service->next; 
+	}
+    } while (!currentRow);
+
+    *var_len = sizeof(long);    /* default length */
+    switch (column) {
+	case I_wwwDocBytesTopNIndex:
+	    return (unsigned char *) NULL;
+	case I_wwwDocBytesTopNName:
+	    *var_len = strlen(currentRow->name);
+	    return (unsigned char *) currentRow->name;
+	case I_wwwDocBytesTopNAccesses:
+	    *var_len = sizeof(currentRow->accesses);
+	    return (unsigned char *) &(currentRow->accesses);
+	case I_wwwDocBytesTopNBytes:
+	    *var_len = sizeof(currentRow->bytes);
+	    return (unsigned char *) &(currentRow->bytes);
+	case I_wwwDocBytesTopNLastResponseType:
+	    return (unsigned char *) &responseTypes[currentRow->lastResponseType];
+        default:
+            return NULL;
+    }
+}
+#endif /* WWW_DOCUMENTS_GROUP */
+
+static oid wwwServiceEntry_oid[] = { O_wwwServiceEntry };
+static Object wwwServiceEntry_variables[] = {
+    { SNMP_STRING, (RONLY| COLUMN), var_wwwServiceEntry,
+                {1, { I_wwwServiceDescription }}},
+    { SNMP_STRING, (RONLY| COLUMN), var_wwwServiceEntry,
+                {1, { I_wwwServiceContact }}},
+    { SNMP_OBJID, (RONLY| COLUMN), var_wwwServiceEntry,
+                {1, { I_wwwServiceProtocol }}},
+    { SNMP_STRING, (RONLY| COLUMN), var_wwwServiceEntry,
+                {1, { I_wwwServiceName }}},
+    { SNMP_INTEGER, (RONLY| COLUMN), var_wwwServiceEntry,
+                {1, { I_wwwServiceType }}},
+    { SNMP_STRING, (RONLY| COLUMN), var_wwwServiceEntry,
+                {1, { I_wwwServiceStartTime }}},
+    { SNMP_INTEGER, (RONLY| COLUMN), var_wwwServiceEntry,
+                {1, { I_wwwServiceOperStatus }}},
+    { SNMP_STRING, (RONLY| COLUMN), var_wwwServiceEntry,
+                {1, { I_wwwServiceLastChange }}},
+    { 0, 0, NULL, {0, {0}}}
+    };
+static SubTree wwwServiceEntry_tree =  { NULL, wwwServiceEntry_variables,
+	        (sizeof(wwwServiceEntry_oid)/sizeof(oid)), wwwServiceEntry_oid};
+
+static oid wwwSummaryEntry_oid[] = { O_wwwSummaryEntry };
+static Object wwwSummaryEntry_variables[] = {
+    { SNMP_COUNTER, (RONLY| COLUMN), var_wwwSummaryEntry,
+                {1, { I_wwwSummaryInRequests }}},
+    { SNMP_COUNTER, (RONLY| COLUMN), var_wwwSummaryEntry,
+                {1, { I_wwwSummaryOutRequests }}},
+    { SNMP_COUNTER, (RONLY| COLUMN), var_wwwSummaryEntry,
+                {1, { I_wwwSummaryInResponses }}},
+    { SNMP_COUNTER, (RONLY| COLUMN), var_wwwSummaryEntry,
+                {1, { I_wwwSummaryOutResponses }}},
+    { SNMP_COUNTER64, (RONLY| COLUMN), var_wwwSummaryEntry,
+                {1, { I_wwwSummaryInBytes }}},
+    { SNMP_COUNTER, (RONLY| COLUMN), var_wwwSummaryEntry,
+                {1, { I_wwwSummaryInLowBytes }}},
+    { SNMP_COUNTER64, (RONLY| COLUMN), var_wwwSummaryEntry,
+                {1, { I_wwwSummaryOutBytes }}},
+    { SNMP_COUNTER, (RONLY| COLUMN), var_wwwSummaryEntry,
+                {1, { I_wwwSummaryOutLowBytes }}},
+    { 0, 0, NULL, {0, {0}}}
+    };
+static SubTree wwwSummaryEntry_tree =  { NULL, wwwSummaryEntry_variables,
+	        (sizeof(wwwSummaryEntry_oid)/sizeof(oid)), wwwSummaryEntry_oid};
+
+#ifdef WWW_REQUEST_IN_GROUP
+static oid wwwRequestInEntry_oid[] = { O_wwwRequestInEntry };
+static Object wwwRequestInEntry_variables[] = {
+    { SNMP_COUNTER, (RONLY| COLUMN), var_wwwRequestInEntry,
+                {1, { I_wwwRequestInRequests }}},
+    { SNMP_COUNTER, (RONLY| COLUMN), var_wwwRequestInEntry,
+                {1, { I_wwwRequestInBytes }}},
+    { SNMP_STRING, (RONLY| COLUMN), var_wwwRequestInEntry,
+                {1, { I_wwwRequestInLastTime }}},
+    { 0, 0, NULL, {0, {0}}}
+    };
+static SubTree wwwRequestInEntry_tree =  { NULL, wwwRequestInEntry_variables,
+	        (sizeof(wwwRequestInEntry_oid)/sizeof(oid)), wwwRequestInEntry_oid};
+#endif /* WWW_REQUEST_IN_GROUP */
+
+#ifdef WWW_REQUEST_OUT_GROUP
+static oid wwwRequestOutEntry_oid[] = { O_wwwRequestOutEntry };
+static Object wwwRequestOutEntry_variables[] = {
+    { SNMP_COUNTER, (RONLY| COLUMN), var_wwwRequestOutEntry,
+                {1, { I_wwwRequestOutRequests }}},
+    { SNMP_COUNTER, (RONLY| COLUMN), var_wwwRequestOutEntry,
+                {1, { I_wwwRequestOutBytes }}},
+    { SNMP_STRING, (RONLY| COLUMN), var_wwwRequestOutEntry,
+                {1, { I_wwwRequestOutLastTime }}},
+    { 0, 0, NULL, {0, {0}}}
+    };
+static SubTree wwwRequestOutEntry_tree =  { NULL, wwwRequestOutEntry_variables,
+	        (sizeof(wwwRequestOutEntry_oid)/sizeof(oid)), wwwRequestOutEntry_oid};
+#endif /* WWW_REQUEST_OUT_GROUP */
+
+#ifdef WWW_RESPONSE_IN_GROUP
+static oid wwwResponseInEntry_oid[] = { O_wwwResponseInEntry };
+static Object wwwResponseInEntry_variables[] = {
+    { SNMP_COUNTER, (RONLY| COLUMN), var_wwwResponseInEntry,
+                {1, { I_wwwResponseInResponses }}},
+    { SNMP_COUNTER, (RONLY| COLUMN), var_wwwResponseInEntry,
+                {1, { I_wwwResponseInBytes }}},
+    { SNMP_STRING, (RONLY| COLUMN), var_wwwResponseInEntry,
+                {1, { I_wwwResponseInLastTime }}},
+    { 0, 0, NULL, {0, {0}}}
+    };
+static SubTree wwwResponseInEntry_tree =  { NULL, wwwResponseInEntry_variables,
+	        (sizeof(wwwResponseInEntry_oid)/sizeof(oid)), wwwResponseInEntry_oid};
+#endif /* WWW_RESPONSE_IN_GROUP */
+
+#ifdef WWW_RESPONSE_OUT_GROUP
+static oid wwwResponseOutEntry_oid[] = { O_wwwResponseOutEntry };
+static Object wwwResponseOutEntry_variables[] = {
+    { SNMP_COUNTER, (RONLY| COLUMN), var_wwwResponseOutEntry,
+                {1, { I_wwwResponseOutResponses }}},
+    { SNMP_COUNTER, (RONLY| COLUMN), var_wwwResponseOutEntry,
+                {1, { I_wwwResponseOutBytes }}},
+    { SNMP_STRING, (RONLY| COLUMN), var_wwwResponseOutEntry,
+                {1, { I_wwwResponseOutLastTime }}},
+    { 0, 0, NULL, {0, {0}}}
+    };
+static SubTree wwwResponseOutEntry_tree =  { NULL, wwwResponseOutEntry_variables,
+	        (sizeof(wwwResponseOutEntry_oid)/sizeof(oid)), wwwResponseOutEntry_oid};
+#endif /* WWW_RESPONSE_OUT_GROUP */
+
+#ifdef WWW_DOCUMENTS_GROUP
+static oid wwwDocCtrlEntry_oid[] = { O_wwwDocCtrlEntry };
+static Object wwwDocCtrlEntry_variables[] = {
+    { SNMP_UINTEGER, (RWRITE| COLUMN), var_wwwDocCtrlEntry,
+                {1, { I_wwwDocCtrlLastNSize }}},
+    { SNMP_TIMETICKS, (RWRITE| COLUMN), var_wwwDocCtrlEntry,
+                {1, { I_wwwDocCtrlLastNLock }}},
+    { SNMP_UINTEGER, (RWRITE| COLUMN), var_wwwDocCtrlEntry,
+                {1, { I_wwwDocCtrlBuckets }}},
+    { SNMP_INTEGER, (RWRITE| COLUMN), var_wwwDocCtrlEntry,
+                {1, { I_wwwDocCtrlBucketTimeInterval }}},
+    { SNMP_UINTEGER, (RWRITE| COLUMN), var_wwwDocCtrlEntry,
+                {1, { I_wwwDocCtrlTopNSize }}},
+    { 0, 0, NULL, {0, {0}}}
+    };
+static SubTree wwwDocCtrlEntry_tree =  { NULL, wwwDocCtrlEntry_variables,
+	        (sizeof(wwwDocCtrlEntry_oid)/sizeof(oid)), wwwDocCtrlEntry_oid};
+
+static oid wwwDocLastNEntry_oid[] = { O_wwwDocLastNEntry };
+static Object wwwDocLastNEntry_variables[] = {
+    { SNMP_STRING, (RONLY| COLUMN), var_wwwDocLastNEntry,
+                {1, { I_wwwDocLastNName }}},
+    { SNMP_STRING, (RONLY| COLUMN), var_wwwDocLastNEntry,
+                {1, { I_wwwDocLastNTimeStamp }}},
+    { SNMP_STRING, (RONLY| COLUMN), var_wwwDocLastNEntry,
+                {1, { I_wwwDocLastNRequestType }}},
+    { SNMP_INTEGER, (RONLY| COLUMN), var_wwwDocLastNEntry,
+                {1, { I_wwwDocLastNResponseType }}},
+    { SNMP_STRING, (RONLY| COLUMN), var_wwwDocLastNEntry,
+                {1, { I_wwwDocLastNStatusMsg }}},
+    { SNMP_UINTEGER, (RONLY| COLUMN), var_wwwDocLastNEntry,
+                {1, { I_wwwDocLastNBytes }}},
+    { 0, 0, NULL, {0, {0}}}
+    };
+static SubTree wwwDocLastNEntry_tree =  { NULL, wwwDocLastNEntry_variables,
+	        (sizeof(wwwDocLastNEntry_oid)/sizeof(oid)), wwwDocLastNEntry_oid};
+
+static oid wwwDocBucketEntry_oid[] = { O_wwwDocBucketEntry };
+static Object wwwDocBucketEntry_variables[] = {
+    { SNMP_STRING, (RONLY| COLUMN), var_wwwDocBucketEntry,
+                {1, { I_wwwDocBucketTimeStamp }}},
+    { SNMP_UINTEGER, (RONLY| COLUMN), var_wwwDocBucketEntry,
+                {1, { I_wwwDocBucketAccesses }}},
+    { SNMP_UINTEGER, (RONLY| COLUMN), var_wwwDocBucketEntry,
+                {1, { I_wwwDocBucketDocuments }}},
+    { SNMP_UINTEGER, (RONLY| COLUMN), var_wwwDocBucketEntry,
+                {1, { I_wwwDocBucketBytes }}},
+    { 0, 0, NULL, {0, {0}}}
+    };
+static SubTree wwwDocBucketEntry_tree =  { NULL, wwwDocBucketEntry_variables,
+	        (sizeof(wwwDocBucketEntry_oid)/sizeof(oid)), wwwDocBucketEntry_oid};
+
+static oid wwwDocAccessTopNEntry_oid[] = { O_wwwDocAccessTopNEntry };
+static Object wwwDocAccessTopNEntry_variables[] = {
+    { SNMP_STRING, (RONLY| COLUMN), var_wwwDocAccessTopNEntry,
+                {1, { I_wwwDocAccessTopNName }}},
+    { SNMP_UINTEGER, (RONLY| COLUMN), var_wwwDocAccessTopNEntry,
+                {1, { I_wwwDocAccessTopNAccesses }}},
+    { SNMP_UINTEGER, (RONLY| COLUMN), var_wwwDocAccessTopNEntry,
+                {1, { I_wwwDocAccessTopNBytes }}},
+    { SNMP_INTEGER, (RONLY| COLUMN), var_wwwDocAccessTopNEntry,
+                {1, { I_wwwDocAccessTopNLastResponseType }}},
+    { 0, 0, NULL, {0, {0}}}
+    };
+static SubTree wwwDocAccessTopNEntry_tree =  { NULL, wwwDocAccessTopNEntry_variables,
+	        (sizeof(wwwDocAccessTopNEntry_oid)/sizeof(oid)), wwwDocAccessTopNEntry_oid};
+
+static oid wwwDocBytesTopNEntry_oid[] = { O_wwwDocBytesTopNEntry };
+static Object wwwDocBytesTopNEntry_variables[] = {
+    { SNMP_STRING, (RONLY| COLUMN), var_wwwDocBytesTopNEntry,
+                {1, { I_wwwDocBytesTopNName }}},
+    { SNMP_UINTEGER, (RONLY| COLUMN), var_wwwDocBytesTopNEntry,
+                {1, { I_wwwDocBytesTopNAccesses }}},
+    { SNMP_UINTEGER, (RONLY| COLUMN), var_wwwDocBytesTopNEntry,
+                {1, { I_wwwDocBytesTopNBytes }}},
+    { SNMP_INTEGER, (RONLY| COLUMN), var_wwwDocBytesTopNEntry,
+                {1, { I_wwwDocBytesTopNLastResponseType }}},
+    { 0, 0, NULL, {0, {0}}}
+    };
+static SubTree wwwDocBytesTopNEntry_tree =  { NULL, wwwDocBytesTopNEntry_variables,
+	        (sizeof(wwwDocBytesTopNEntry_oid)/sizeof(oid)), wwwDocBytesTopNEntry_oid};
+#endif /* WWW_DOCUMENTS_GROUP */
+
+/* This is the MIB registration function. This should be called */
+/* within the init_WWW_MIB-function */
+void register_subtrees_of_WWW_MIB()
+{
+    insert_group_in_mib(&wwwServiceEntry_tree);
+    insert_group_in_mib(&wwwSummaryEntry_tree);
+#ifdef WWW_REQUEST_IN_GROUP
+    insert_group_in_mib(&wwwRequestInEntry_tree);
+#endif
+#ifdef WWW_REQUEST_OUT_GROUP
+    insert_group_in_mib(&wwwRequestOutEntry_tree);
+#endif
+#ifdef WWW_RESPONSE_IN_GROUP
+    insert_group_in_mib(&wwwResponseInEntry_tree);
+#endif
+#ifdef WWW_RESPONSE_OUT_GROUP
+    insert_group_in_mib(&wwwResponseOutEntry_tree);
+#endif
+#ifdef WWW_DOCUMENTS_GROUP
+    insert_group_in_mib(&wwwDocCtrlEntry_tree);
+    insert_group_in_mib(&wwwDocLastNEntry_tree);
+    insert_group_in_mib(&wwwDocBucketEntry_tree);
+    insert_group_in_mib(&wwwDocAccessTopNEntry_tree);
+    insert_group_in_mib(&wwwDocBytesTopNEntry_tree);
+#endif
+}
diff -ru -ruN apache_1.3.34_orig/src/modules/snmp_agt/www-mib.h apache_1.3.34/src/modules/snmp_agt/www-mib.h
--- apache_1.3.34_orig/src/modules/snmp_agt/www-mib.h	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/src/modules/snmp_agt/www-mib.h	2006-05-18 16:49:19.295763800 +0200
@@ -0,0 +1,478 @@
+/* ====================================================================
+ * Copyright (c) 1997-2000 Harrie Hazewinkel.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by Harrie Hazewinkel."
+ *
+ * 4. The name of the Copyright holder must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission.
+ *
+ * 5. Products derived from this software may not be called "MOD-SNMP"
+ *    nor may "MOD-SNMP" appear in their names  without prior written
+ *    permission of the Harrie Hazewinkel.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the Harrie Hazewinkel"
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * The creator of this module is Harrie.Hazewinkel@bigfoot.com
+ * This file contains generated code of SMASH also created by Harrie.
+ *
+ *
+ */
+#ifndef	_WWW_MIB_
+#define	_WWW_MIB_
+
+/* required include files (IMPORTS) */
+#include	"snmpv2-conf.h"
+#include	"snmpv2-tc.h"
+#include	"snmpv2-smi.h"
+
+
+void init_WWW_MIB();
+void register_subtrees_of_WWW_MIB();
+
+/* defined objects in this module */
+
+/* MIB object wwwMIB = mib_2, 65 */
+#define	I_wwwMIB	65
+#define	O_wwwMIB	1, 3, 6, 1, 2, 1, 65
+
+/* MIB object wwwMIBObjects = wwwMIB, 1 */
+#define	I_wwwMIBObjects	1
+#define	O_wwwMIBObjects	1, 3, 6, 1, 2, 1, 65, 1
+
+/* MIB object wwwMIBConformance = wwwMIB, 2 */
+#define	I_wwwMIBConformance	2
+#define	O_wwwMIBConformance	1, 3, 6, 1, 2, 1, 65, 2
+
+/* MIB object wwwService = wwwMIBObjects, 1 */
+#define	I_wwwService	1
+#define	O_wwwService	1, 3, 6, 1, 2, 1, 65, 1, 1
+
+/* MIB object wwwServiceTable = wwwService, 1 */
+#define	I_wwwServiceTable	1
+#define	O_wwwServiceTable	1, 3, 6, 1, 2, 1, 65, 1, 1, 1
+
+/* MIB object wwwServiceEntry = wwwServiceTable, 1 */
+#define	I_wwwServiceEntry	1
+#define	O_wwwServiceEntry	1, 3, 6, 1, 2, 1, 65, 1, 1, 1, 1
+
+/* MIB object wwwServiceIndex = wwwServiceEntry, 1 */
+#define	I_wwwServiceIndex	1
+#define	O_wwwServiceIndex	1, 3, 6, 1, 2, 1, 65, 1, 1, 1, 1, 1
+
+/* MIB object wwwServiceDescription = wwwServiceEntry, 2 */
+#define	I_wwwServiceDescription	2
+#define	O_wwwServiceDescription	1, 3, 6, 1, 2, 1, 65, 1, 1, 1, 1, 2
+
+/* MIB object wwwServiceContact = wwwServiceEntry, 3 */
+#define	I_wwwServiceContact	3
+#define	O_wwwServiceContact	1, 3, 6, 1, 2, 1, 65, 1, 1, 1, 1, 3
+
+/* MIB object wwwServiceProtocol = wwwServiceEntry, 4 */
+#define	I_wwwServiceProtocol	4
+#define	O_wwwServiceProtocol	1, 3, 6, 1, 2, 1, 65, 1, 1, 1, 1, 4
+
+/* MIB object wwwServiceName = wwwServiceEntry, 5 */
+#define	I_wwwServiceName	5
+#define	O_wwwServiceName	1, 3, 6, 1, 2, 1, 65, 1, 1, 1, 1, 5
+
+/* MIB object wwwServiceType = wwwServiceEntry, 6 */
+#define	I_wwwServiceType	6
+#define	O_wwwServiceType	1, 3, 6, 1, 2, 1, 65, 1, 1, 1, 1, 6
+
+/* MIB object wwwServiceStartTime = wwwServiceEntry, 7 */
+#define	I_wwwServiceStartTime	7
+#define	O_wwwServiceStartTime	1, 3, 6, 1, 2, 1, 65, 1, 1, 1, 1, 7
+
+/* MIB object wwwServiceOperStatus = wwwServiceEntry, 8 */
+#define	I_wwwServiceOperStatus	8
+#define	O_wwwServiceOperStatus	1, 3, 6, 1, 2, 1, 65, 1, 1, 1, 1, 8
+
+/* enumerated wwwServiceOperStatus */
+#define VHOST_DOWN		1
+#define VHOST_RUNNING		2
+#define VHOST_HALTED		3
+#define VHOST_CONGESTED		4
+#define VHOST_RESTARTING	5
+
+/* MIB object wwwServiceLastChange = wwwServiceEntry, 9 */
+#define	I_wwwServiceLastChange	9
+#define	O_wwwServiceLastChange	1, 3, 6, 1, 2, 1, 65, 1, 1, 1, 1, 9
+
+/* MIB object wwwProtocolStatistics = wwwMIBObjects, 2 */
+#define	I_wwwProtocolStatistics	2
+#define	O_wwwProtocolStatistics	1, 3, 6, 1, 2, 1, 65, 1, 2
+
+/* MIB object wwwSummaryTable = wwwProtocolStatistics, 1 */
+#define	I_wwwSummaryTable	1
+#define	O_wwwSummaryTable	1, 3, 6, 1, 2, 1, 65, 1, 2, 1
+
+/* MIB object wwwSummaryEntry = wwwSummaryTable, 1 */
+#define	I_wwwSummaryEntry	1
+#define	O_wwwSummaryEntry	1, 3, 6, 1, 2, 1, 65, 1, 2, 1, 1
+
+/* MIB object wwwSummaryInRequests = wwwSummaryEntry, 1 */
+#define	I_wwwSummaryInRequests	1
+#define	O_wwwSummaryInRequests	1, 3, 6, 1, 2, 1, 65, 1, 2, 1, 1, 1
+
+/* MIB object wwwSummaryOutRequests = wwwSummaryEntry, 2 */
+#define	I_wwwSummaryOutRequests	2
+#define	O_wwwSummaryOutRequests	1, 3, 6, 1, 2, 1, 65, 1, 2, 1, 1, 2
+
+/* MIB object wwwSummaryInResponses = wwwSummaryEntry, 3 */
+#define	I_wwwSummaryInResponses	3
+#define	O_wwwSummaryInResponses	1, 3, 6, 1, 2, 1, 65, 1, 2, 1, 1, 3
+
+/* MIB object wwwSummaryOutResponses = wwwSummaryEntry, 4 */
+#define	I_wwwSummaryOutResponses	4
+#define	O_wwwSummaryOutResponses	1, 3, 6, 1, 2, 1, 65, 1, 2, 1, 1, 4
+
+/* MIB object wwwSummaryInBytes = wwwSummaryEntry, 5 */
+#define	I_wwwSummaryInBytes	5
+#define	O_wwwSummaryInBytes	1, 3, 6, 1, 2, 1, 65, 1, 2, 1, 1, 5
+
+/* MIB object wwwSummaryInLowBytes = wwwSummaryEntry, 6 */
+#define	I_wwwSummaryInLowBytes	6
+#define	O_wwwSummaryInLowBytes	1, 3, 6, 1, 2, 1, 65, 1, 2, 1, 1, 6
+
+/* MIB object wwwSummaryOutBytes = wwwSummaryEntry, 7 */
+#define	I_wwwSummaryOutBytes	7
+#define	O_wwwSummaryOutBytes	1, 3, 6, 1, 2, 1, 65, 1, 2, 1, 1, 7
+
+/* MIB object wwwSummaryOutLowBytes = wwwSummaryEntry, 8 */
+#define	I_wwwSummaryOutLowBytes	8
+#define	O_wwwSummaryOutLowBytes	1, 3, 6, 1, 2, 1, 65, 1, 2, 1, 1, 8
+
+/* MIB object wwwRequestInTable = wwwProtocolStatistics, 2 */
+#define	I_wwwRequestInTable	2
+#define	O_wwwRequestInTable	1, 3, 6, 1, 2, 1, 65, 1, 2, 2
+
+/* MIB object wwwRequestInEntry = wwwRequestInTable, 1 */
+#define	I_wwwRequestInEntry	1
+#define	O_wwwRequestInEntry	1, 3, 6, 1, 2, 1, 65, 1, 2, 2, 1
+
+/* MIB object wwwRequestInIndex = wwwRequestInEntry, 1 */
+#define	I_wwwRequestInIndex	1
+#define	O_wwwRequestInIndex	1, 3, 6, 1, 2, 1, 65, 1, 2, 2, 1, 1
+
+/* MIB object wwwRequestInRequests = wwwRequestInEntry, 2 */
+#define	I_wwwRequestInRequests	2
+#define	O_wwwRequestInRequests	1, 3, 6, 1, 2, 1, 65, 1, 2, 2, 1, 2
+
+/* MIB object wwwRequestInBytes = wwwRequestInEntry, 3 */
+#define	I_wwwRequestInBytes	3
+#define	O_wwwRequestInBytes	1, 3, 6, 1, 2, 1, 65, 1, 2, 2, 1, 3
+
+/* MIB object wwwRequestInLastTime = wwwRequestInEntry, 4 */
+#define	I_wwwRequestInLastTime	4
+#define	O_wwwRequestInLastTime	1, 3, 6, 1, 2, 1, 65, 1, 2, 2, 1, 4
+
+/* MIB object wwwRequestOutTable = wwwProtocolStatistics, 3 */
+#define	I_wwwRequestOutTable	3
+#define	O_wwwRequestOutTable	1, 3, 6, 1, 2, 1, 65, 1, 2, 3
+
+/* MIB object wwwRequestOutEntry = wwwRequestOutTable, 1 */
+#define	I_wwwRequestOutEntry	1
+#define	O_wwwRequestOutEntry	1, 3, 6, 1, 2, 1, 65, 1, 2, 3, 1
+
+/* MIB object wwwRequestOutIndex = wwwRequestOutEntry, 1 */
+#define	I_wwwRequestOutIndex	1
+#define	O_wwwRequestOutIndex	1, 3, 6, 1, 2, 1, 65, 1, 2, 3, 1, 1
+
+/* MIB object wwwRequestOutRequests = wwwRequestOutEntry, 2 */
+#define	I_wwwRequestOutRequests	2
+#define	O_wwwRequestOutRequests	1, 3, 6, 1, 2, 1, 65, 1, 2, 3, 1, 2
+
+/* MIB object wwwRequestOutBytes = wwwRequestOutEntry, 3 */
+#define	I_wwwRequestOutBytes	3
+#define	O_wwwRequestOutBytes	1, 3, 6, 1, 2, 1, 65, 1, 2, 3, 1, 3
+
+/* MIB object wwwRequestOutLastTime = wwwRequestOutEntry, 4 */
+#define	I_wwwRequestOutLastTime	4
+#define	O_wwwRequestOutLastTime	1, 3, 6, 1, 2, 1, 65, 1, 2, 3, 1, 4
+
+/* MIB object wwwResponseInTable = wwwProtocolStatistics, 4 */
+#define	I_wwwResponseInTable	4
+#define	O_wwwResponseInTable	1, 3, 6, 1, 2, 1, 65, 1, 2, 4
+
+/* MIB object wwwResponseInEntry = wwwResponseInTable, 1 */
+#define	I_wwwResponseInEntry	1
+#define	O_wwwResponseInEntry	1, 3, 6, 1, 2, 1, 65, 1, 2, 4, 1
+
+/* MIB object wwwResponseInIndex = wwwResponseInEntry, 1 */
+#define	I_wwwResponseInIndex	1
+#define	O_wwwResponseInIndex	1, 3, 6, 1, 2, 1, 65, 1, 2, 4, 1, 1
+
+/* MIB object wwwResponseInResponses = wwwResponseInEntry, 2 */
+#define	I_wwwResponseInResponses	2
+#define	O_wwwResponseInResponses	1, 3, 6, 1, 2, 1, 65, 1, 2, 4, 1, 2
+
+/* MIB object wwwResponseInBytes = wwwResponseInEntry, 3 */
+#define	I_wwwResponseInBytes	3
+#define	O_wwwResponseInBytes	1, 3, 6, 1, 2, 1, 65, 1, 2, 4, 1, 3
+
+/* MIB object wwwResponseInLastTime = wwwResponseInEntry, 4 */
+#define	I_wwwResponseInLastTime	4
+#define	O_wwwResponseInLastTime	1, 3, 6, 1, 2, 1, 65, 1, 2, 4, 1, 4
+
+/* MIB object wwwResponseOutTable = wwwProtocolStatistics, 5 */
+#define	I_wwwResponseOutTable	5
+#define	O_wwwResponseOutTable	1, 3, 6, 1, 2, 1, 65, 1, 2, 5
+
+/* MIB object wwwResponseOutEntry = wwwResponseOutTable, 1 */
+#define	I_wwwResponseOutEntry	1
+#define	O_wwwResponseOutEntry	1, 3, 6, 1, 2, 1, 65, 1, 2, 5, 1
+
+/* MIB object wwwResponseOutIndex = wwwResponseOutEntry, 1 */
+#define	I_wwwResponseOutIndex	1
+#define	O_wwwResponseOutIndex	1, 3, 6, 1, 2, 1, 65, 1, 2, 5, 1, 1
+
+/* MIB object wwwResponseOutResponses = wwwResponseOutEntry, 2 */
+#define	I_wwwResponseOutResponses	2
+#define	O_wwwResponseOutResponses	1, 3, 6, 1, 2, 1, 65, 1, 2, 5, 1, 2
+
+/* MIB object wwwResponseOutBytes = wwwResponseOutEntry, 3 */
+#define	I_wwwResponseOutBytes	3
+#define	O_wwwResponseOutBytes	1, 3, 6, 1, 2, 1, 65, 1, 2, 5, 1, 3
+
+/* MIB object wwwResponseOutLastTime = wwwResponseOutEntry, 4 */
+#define	I_wwwResponseOutLastTime	4
+#define	O_wwwResponseOutLastTime	1, 3, 6, 1, 2, 1, 65, 1, 2, 5, 1, 4
+
+/* MIB object wwwDocumentStatistics = wwwMIBObjects, 3 */
+#define	I_wwwDocumentStatistics	3
+#define	O_wwwDocumentStatistics	1, 3, 6, 1, 2, 1, 65, 1, 3
+
+/* MIB object wwwDocCtrlTable = wwwDocumentStatistics, 1 */
+#define	I_wwwDocCtrlTable	1
+#define	O_wwwDocCtrlTable	1, 3, 6, 1, 2, 1, 65, 1, 3, 1
+
+/* MIB object wwwDocCtrlEntry = wwwDocCtrlTable, 1 */
+#define	I_wwwDocCtrlEntry	1
+#define	O_wwwDocCtrlEntry	1, 3, 6, 1, 2, 1, 65, 1, 3, 1, 1
+
+/* MIB object wwwDocCtrlLastNSize = wwwDocCtrlEntry, 1 */
+#define	I_wwwDocCtrlLastNSize	1
+#define	O_wwwDocCtrlLastNSize	1, 3, 6, 1, 2, 1, 65, 1, 3, 1, 1, 1
+
+/* MIB object wwwDocCtrlLastNLock = wwwDocCtrlEntry, 2 */
+#define	I_wwwDocCtrlLastNLock	2
+#define	O_wwwDocCtrlLastNLock	1, 3, 6, 1, 2, 1, 65, 1, 3, 1, 1, 2
+
+/* MIB object wwwDocCtrlBuckets = wwwDocCtrlEntry, 3 */
+#define	I_wwwDocCtrlBuckets	3
+#define	O_wwwDocCtrlBuckets	1, 3, 6, 1, 2, 1, 65, 1, 3, 1, 1, 3
+
+/* MIB object wwwDocCtrlBucketTimeInterval = wwwDocCtrlEntry, 4 */
+#define	I_wwwDocCtrlBucketTimeInterval	4
+#define	O_wwwDocCtrlBucketTimeInterval	1, 3, 6, 1, 2, 1, 65, 1, 3, 1, 1, 4
+
+/* MIB object wwwDocCtrlTopNSize = wwwDocCtrlEntry, 5 */
+#define	I_wwwDocCtrlTopNSize	5
+#define	O_wwwDocCtrlTopNSize	1, 3, 6, 1, 2, 1, 65, 1, 3, 1, 1, 5
+
+/* MIB object wwwDocLastNTable = wwwDocumentStatistics, 2 */
+#define	I_wwwDocLastNTable	2
+#define	O_wwwDocLastNTable	1, 3, 6, 1, 2, 1, 65, 1, 3, 2
+
+/* MIB object wwwDocLastNEntry = wwwDocLastNTable, 1 */
+#define	I_wwwDocLastNEntry	1
+#define	O_wwwDocLastNEntry	1, 3, 6, 1, 2, 1, 65, 1, 3, 2, 1
+
+/* MIB object wwwDocLastNIndex = wwwDocLastNEntry, 1 */
+#define	I_wwwDocLastNIndex	1
+#define	O_wwwDocLastNIndex	1, 3, 6, 1, 2, 1, 65, 1, 3, 2, 1, 1
+
+/* MIB object wwwDocLastNName = wwwDocLastNEntry, 2 */
+#define	I_wwwDocLastNName	2
+#define	O_wwwDocLastNName	1, 3, 6, 1, 2, 1, 65, 1, 3, 2, 1, 2
+
+/* MIB object wwwDocLastNTimeStamp = wwwDocLastNEntry, 3 */
+#define	I_wwwDocLastNTimeStamp	3
+#define	O_wwwDocLastNTimeStamp	1, 3, 6, 1, 2, 1, 65, 1, 3, 2, 1, 3
+
+/* MIB object wwwDocLastNRequestType = wwwDocLastNEntry, 4 */
+#define	I_wwwDocLastNRequestType	4
+#define	O_wwwDocLastNRequestType	1, 3, 6, 1, 2, 1, 65, 1, 3, 2, 1, 4
+
+/* MIB object wwwDocLastNResponseType = wwwDocLastNEntry, 5 */
+#define	I_wwwDocLastNResponseType	5
+#define	O_wwwDocLastNResponseType	1, 3, 6, 1, 2, 1, 65, 1, 3, 2, 1, 5
+
+/* MIB object wwwDocLastNStatusMsg = wwwDocLastNEntry, 6 */
+#define	I_wwwDocLastNStatusMsg	6
+#define	O_wwwDocLastNStatusMsg	1, 3, 6, 1, 2, 1, 65, 1, 3, 2, 1, 6
+
+/* MIB object wwwDocLastNBytes = wwwDocLastNEntry, 7 */
+#define	I_wwwDocLastNBytes	7
+#define	O_wwwDocLastNBytes	1, 3, 6, 1, 2, 1, 65, 1, 3, 2, 1, 7
+
+/* MIB object wwwDocBucketTable = wwwDocumentStatistics, 3 */
+#define	I_wwwDocBucketTable	3
+#define	O_wwwDocBucketTable	1, 3, 6, 1, 2, 1, 65, 1, 3, 3
+
+/* MIB object wwwDocBucketEntry = wwwDocBucketTable, 1 */
+#define	I_wwwDocBucketEntry	1
+#define	O_wwwDocBucketEntry	1, 3, 6, 1, 2, 1, 65, 1, 3, 3, 1
+
+/* MIB object wwwDocBucketIndex = wwwDocBucketEntry, 1 */
+#define	I_wwwDocBucketIndex	1
+#define	O_wwwDocBucketIndex	1, 3, 6, 1, 2, 1, 65, 1, 3, 3, 1, 1
+
+/* MIB object wwwDocBucketTimeStamp = wwwDocBucketEntry, 2 */
+#define	I_wwwDocBucketTimeStamp	2
+#define	O_wwwDocBucketTimeStamp	1, 3, 6, 1, 2, 1, 65, 1, 3, 3, 1, 2
+
+/* MIB object wwwDocBucketAccesses = wwwDocBucketEntry, 3 */
+#define	I_wwwDocBucketAccesses	3
+#define	O_wwwDocBucketAccesses	1, 3, 6, 1, 2, 1, 65, 1, 3, 3, 1, 3
+
+/* MIB object wwwDocBucketDocuments = wwwDocBucketEntry, 4 */
+#define	I_wwwDocBucketDocuments	4
+#define	O_wwwDocBucketDocuments	1, 3, 6, 1, 2, 1, 65, 1, 3, 3, 1, 4
+
+/* MIB object wwwDocBucketBytes = wwwDocBucketEntry, 5 */
+#define	I_wwwDocBucketBytes	5
+#define	O_wwwDocBucketBytes	1, 3, 6, 1, 2, 1, 65, 1, 3, 3, 1, 5
+
+/* MIB object wwwDocAccessTopNTable = wwwDocumentStatistics, 4 */
+#define	I_wwwDocAccessTopNTable	4
+#define	O_wwwDocAccessTopNTable	1, 3, 6, 1, 2, 1, 65, 1, 3, 4
+
+/* MIB object wwwDocAccessTopNEntry = wwwDocAccessTopNTable, 1 */
+#define	I_wwwDocAccessTopNEntry	1
+#define	O_wwwDocAccessTopNEntry	1, 3, 6, 1, 2, 1, 65, 1, 3, 4, 1
+
+/* MIB object wwwDocAccessTopNIndex = wwwDocAccessTopNEntry, 1 */
+#define	I_wwwDocAccessTopNIndex	1
+#define	O_wwwDocAccessTopNIndex	1, 3, 6, 1, 2, 1, 65, 1, 3, 4, 1, 1
+
+/* MIB object wwwDocAccessTopNName = wwwDocAccessTopNEntry, 2 */
+#define	I_wwwDocAccessTopNName	2
+#define	O_wwwDocAccessTopNName	1, 3, 6, 1, 2, 1, 65, 1, 3, 4, 1, 2
+
+/* MIB object wwwDocAccessTopNAccesses = wwwDocAccessTopNEntry, 3 */
+#define	I_wwwDocAccessTopNAccesses	3
+#define	O_wwwDocAccessTopNAccesses	1, 3, 6, 1, 2, 1, 65, 1, 3, 4, 1, 3
+
+/* MIB object wwwDocAccessTopNBytes = wwwDocAccessTopNEntry, 4 */
+#define	I_wwwDocAccessTopNBytes	4
+#define	O_wwwDocAccessTopNBytes	1, 3, 6, 1, 2, 1, 65, 1, 3, 4, 1, 4
+
+/* MIB object wwwDocAccessTopNLastResponseType = wwwDocAccessTopNEntry, 5 */
+#define	I_wwwDocAccessTopNLastResponseType	5
+#define	O_wwwDocAccessTopNLastResponseType	1, 3, 6, 1, 2, 1, 65, 1, 3, 4, 1, 5
+
+/* MIB object wwwDocBytesTopNTable = wwwDocumentStatistics, 5 */
+#define	I_wwwDocBytesTopNTable	5
+#define	O_wwwDocBytesTopNTable	1, 3, 6, 1, 2, 1, 65, 1, 3, 5
+
+/* MIB object wwwDocBytesTopNEntry = wwwDocBytesTopNTable, 1 */
+#define	I_wwwDocBytesTopNEntry	1
+#define	O_wwwDocBytesTopNEntry	1, 3, 6, 1, 2, 1, 65, 1, 3, 5, 1
+
+/* MIB object wwwDocBytesTopNIndex = wwwDocBytesTopNEntry, 1 */
+#define	I_wwwDocBytesTopNIndex	1
+#define	O_wwwDocBytesTopNIndex	1, 3, 6, 1, 2, 1, 65, 1, 3, 5, 1, 1
+
+/* MIB object wwwDocBytesTopNName = wwwDocBytesTopNEntry, 2 */
+#define	I_wwwDocBytesTopNName	2
+#define	O_wwwDocBytesTopNName	1, 3, 6, 1, 2, 1, 65, 1, 3, 5, 1, 2
+
+/* MIB object wwwDocBytesTopNAccesses = wwwDocBytesTopNEntry, 3 */
+#define	I_wwwDocBytesTopNAccesses	3
+#define	O_wwwDocBytesTopNAccesses	1, 3, 6, 1, 2, 1, 65, 1, 3, 5, 1, 3
+
+/* MIB object wwwDocBytesTopNBytes = wwwDocBytesTopNEntry, 4 */
+#define	I_wwwDocBytesTopNBytes	4
+#define	O_wwwDocBytesTopNBytes	1, 3, 6, 1, 2, 1, 65, 1, 3, 5, 1, 4
+
+/* MIB object wwwDocBytesTopNLastResponseType = wwwDocBytesTopNEntry, 5 */
+#define	I_wwwDocBytesTopNLastResponseType	5
+#define	O_wwwDocBytesTopNLastResponseType	1, 3, 6, 1, 2, 1, 65, 1, 3, 5, 1, 5
+
+/* MIB object wwwMIBCompliances = wwwMIBConformance, 1 */
+#define	I_wwwMIBCompliances	1
+#define	O_wwwMIBCompliances	1, 3, 6, 1, 2, 1, 65, 2, 1
+
+/* MIB object wwwMIBGroups = wwwMIBConformance, 2 */
+#define	I_wwwMIBGroups	2
+#define	O_wwwMIBGroups	1, 3, 6, 1, 2, 1, 65, 2, 2
+
+/* MIB object wwwMinimalCompliance = wwwMIBCompliances, 1 */
+#define	I_wwwMinimalCompliance	1
+#define	O_wwwMinimalCompliance	1, 3, 6, 1, 2, 1, 65, 2, 1, 1
+
+/* MIB object wwwFullCompliance = wwwMIBCompliances, 2 */
+#define	I_wwwFullCompliance	2
+#define	O_wwwFullCompliance	1, 3, 6, 1, 2, 1, 65, 2, 1, 2
+
+/* MIB object wwwServiceGroup = wwwMIBGroups, 1 */
+#define	I_wwwServiceGroup	1
+#define	O_wwwServiceGroup	1, 3, 6, 1, 2, 1, 65, 2, 2, 1
+
+/* MIB object wwwSummaryGroup = wwwMIBGroups, 2 */
+#define	I_wwwSummaryGroup	2
+#define	O_wwwSummaryGroup	1, 3, 6, 1, 2, 1, 65, 2, 2, 2
+
+/* MIB object wwwRequestInGroup = wwwMIBGroups, 3 */
+#define	I_wwwRequestInGroup	3
+#define	O_wwwRequestInGroup	1, 3, 6, 1, 2, 1, 65, 2, 2, 3
+
+/* MIB object wwwRequestOutGroup = wwwMIBGroups, 4 */
+#define	I_wwwRequestOutGroup	4
+#define	O_wwwRequestOutGroup	1, 3, 6, 1, 2, 1, 65, 2, 2, 4
+
+/* MIB object wwwResponseInGroup = wwwMIBGroups, 5 */
+#define	I_wwwResponseInGroup	5
+#define	O_wwwResponseInGroup	1, 3, 6, 1, 2, 1, 65, 2, 2, 5
+
+/* MIB object wwwResponseOutGroup = wwwMIBGroups, 6 */
+#define	I_wwwResponseOutGroup	6
+#define	O_wwwResponseOutGroup	1, 3, 6, 1, 2, 1, 65, 2, 2, 6
+
+/* MIB object wwwDocumentGroup = wwwMIBGroups, 7 */
+#define	I_wwwDocumentGroup	7
+#define	O_wwwDocumentGroup	1, 3, 6, 1, 2, 1, 65, 2, 2, 7
+
+#ifdef WWWFULLCOMPLIANCE
+#define WWW_REQUEST_IN_GROUP
+#define WWW_REQUEST_OUT_GROUP
+#define WWW_RESPONSE_IN_GROUP
+#define WWW_RESPONSE_OUT_GROUP
+#define WWW_DOCUMENT_GROUP
+#endif
+
+void init_wwwServiceOperStatus();
+
+#endif	/* _WWW_MIB_ */
diff -ru -ruN apache_1.3.34_orig/src/modules/standard/mod_status.c apache_1.3.34/src/modules/standard/mod_status.c
--- apache_1.3.34_orig/src/modules/standard/mod_status.c	2006-05-18 16:49:19.241772008 +0200
+++ apache_1.3.34/src/modules/standard/mod_status.c	2006-05-18 16:49:19.338757264 +0200
@@ -275,7 +275,7 @@
 	    ready++;
 	else if (res != SERVER_DEAD)
 	    busy++;
-	if (ap_extended_status) {
+	if (SNMP_SCOREBOARD(ap_extended_status)) {
 	    lres = score_record.access_count;
 	    bytes = score_record.bytes_served;
 	    if (lres != 0 || (res != SERVER_READY && res != SERVER_DEAD)) {
@@ -320,7 +320,7 @@
 	ap_rputs("<br>\n", r);
     }
 
-    if (ap_extended_status) {
+    if (SNMP_SCOREBOARD(ap_extended_status)) {
 	if (short_report) {
 	    ap_rprintf(r, "Total Accesses: %lu\nTotal kBytes: %lu\n",
 		count, kbcount);
@@ -416,7 +416,7 @@
 	ap_rputs("\"<B><code>G</code></B>\" Gracefully finishing, \n", r);
 	ap_rputs("\"<B><code>.</code></B>\" Open slot with no current process<P>\n", r);
 	ap_rputs("<P>\n", r);
-	if (!ap_extended_status) {
+	if (! SNMP_SCOREBOARD(ap_extended_status)) {
 	    int j = 0;
 	    ap_rputs("PID Key: <br>\n", r);
 	    ap_rputs("<PRE>\n", r);
@@ -435,8 +435,7 @@
 	    ap_rputs("</PRE>\n", r);
 	}
     }
-
-    if (ap_extended_status) {
+    if (SNMP_SCOREBOARD(ap_extended_status)) {
 	if (!short_report) {
 	    if (no_table_report)
 		ap_rputs("<p><hr><h2>Server Details</h2>\n\n", r);
diff -ru -ruN apache_1.3.34_orig/src/support/snmp/get_ext_status apache_1.3.34/src/support/snmp/get_ext_status
--- apache_1.3.34_orig/src/support/snmp/get_ext_status	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/src/support/snmp/get_ext_status	2006-05-18 16:49:19.302762736 +0200
@@ -0,0 +1,39 @@
+#!/usr/local/bin/perl
+
+use SNMP 1.8;
+
+require "parameters.plib";
+
+
+$var = new SNMP::Varbind(['1.3.6.1.4.1.785.6.1.1', '0']);
+
+$session = new SNMP::Session ( DestHost => $host,
+                                Community => $community,
+                                RemotePort => $port );
+
+print "Could not open session"
+                if !defined($session);
+
+$resp = $session->get($var);
+
+print "SNMP-request error\n"
+                if !defined($resp);
+
+$value = $var->[$SNMP::Varbind::val_f];
+
+if ($session->{ErrorInd} != 0) {
+	printf "Return error status '%d' means '%s' at index '%d'\n",
+			$session->{ErrorNum}, 
+			$session->{ErrorStr}, 
+			$session->{ErrorInd};
+} else {
+	if ($value == 1) {
+		print "The Extended Scoreboard Status 'ON'\n";
+	} elsif ($value == 2) {
+		print "The Extended Scoreboard Status 'OFF'\n";
+	} else {
+		print "Panic, should not be possible\n";
+	}
+}
+
+
diff -ru -ruN apache_1.3.34_orig/src/support/snmp/get_limit_servers apache_1.3.34/src/support/snmp/get_limit_servers
--- apache_1.3.34_orig/src/support/snmp/get_limit_servers	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/src/support/snmp/get_limit_servers	2006-05-18 16:49:19.300763040 +0200
@@ -0,0 +1,29 @@
+#!/usr/local/bin/perl
+
+use SNMP 1.8;
+
+require "parameters.plib";
+
+
+$var = new SNMP::Varbind(['1.3.6.1.4.1.785.6.1.5', '0']);
+
+$session = new SNMP::Session ( DestHost => $host,
+                                Community => $community,
+                                RemotePort => $port );
+
+print "Could not open session"
+                if !defined($session);
+
+$resp = $session->get($var);
+
+if (!defined($resp)) {
+	die "SNMP-request error\n";
+}
+
+$value = $var->[$SNMP::Varbind::val_f];
+
+if ($session->{ErrorInd} != 0) {
+	printf "Return error status '%d' means '%s' at index '%d'\n", $session->{ErrorNum}, $session->{ErrorStr}, $session->{ErrorInd};
+} else {
+	print "The max servers is '$value'\n";
+}
diff -ru -ruN apache_1.3.34_orig/src/support/snmp/get_max_spare_servers apache_1.3.34/src/support/snmp/get_max_spare_servers
--- apache_1.3.34_orig/src/support/snmp/get_max_spare_servers	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/src/support/snmp/get_max_spare_servers	2006-05-18 16:49:19.300763040 +0200
@@ -0,0 +1,28 @@
+#!/usr/local/bin/perl
+
+use SNMP 1.8;
+
+require "parameters.plib";
+
+$var = new SNMP::Varbind(['1.3.6.1.4.1.785.6.1.7', '0']);
+
+$session = new SNMP::Session ( DestHost => $host,
+                                Community => $community,
+                                RemotePort => $port );
+
+print "Could not open session"
+                if !defined($session);
+
+$resp = $session->get($var);
+
+if (!defined($resp)) {
+	die "SNMP-request error\n";
+}
+
+$value = $var->[$SNMP::Varbind::val_f];
+
+if ($session->{ErrorInd} != 0) {
+	printf "Return error status '%d' means '%s' at index '%d'\n", $session->{ErrorNum}, $session->{ErrorStr}, $session->{ErrorInd};
+} else {
+	print "The max spare servers is '$value'\n";
+}
diff -ru -ruN apache_1.3.34_orig/src/support/snmp/get_min_spare_servers apache_1.3.34/src/support/snmp/get_min_spare_servers
--- apache_1.3.34_orig/src/support/snmp/get_min_spare_servers	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/src/support/snmp/get_min_spare_servers	2006-05-18 16:49:19.302762736 +0200
@@ -0,0 +1,28 @@
+#!/usr/local/bin/perl
+
+use SNMP 1.8;
+
+require "parameters.plib";
+
+$var = new SNMP::Varbind(['1.3.6.1.4.1.785.6.1.6', '0']);
+
+$session = new SNMP::Session ( DestHost => $host,
+                                Community => $community,
+                                RemotePort => $port );
+
+print "Could not open session"
+                if !defined($session);
+
+$resp = $session->get($var);
+
+if (!defined($resp)) {
+	die "SNMP-request error\n";
+}
+
+$value = $var->[$SNMP::Varbind::val_f];
+
+if ($session->{ErrorInd} != 0) {
+	printf "Return error status '%d' means '%s' at index '%d'\n", $session->{ErrorNum}, $session->{ErrorStr}, $session->{ErrorInd};
+} else {
+	print "The min spare servers is '$value'\n";
+}
diff -ru -ruN apache_1.3.34_orig/src/support/snmp/parameters.plib apache_1.3.34/src/support/snmp/parameters.plib
--- apache_1.3.34_orig/src/support/snmp/parameters.plib	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/src/support/snmp/parameters.plib	2006-05-18 16:49:19.303762584 +0200
@@ -0,0 +1,18 @@
+
+# The host name for the SNMP-agent.
+$host = 'localhost';
+
+# The community string for the SNMP-agent
+$community = 'public';
+
+# The port number for the SNMP-agent
+$port = 1161;
+
+# The SNMP protocol version
+$version = 2;
+
+# Debugging of the SNP packets (0 == on, 0 == off)
+$SNMP::dump_packet= 1;
+
+return 1;
+
diff -ru -ruN apache_1.3.34_orig/src/support/snmp/set_ext_status apache_1.3.34/src/support/snmp/set_ext_status
--- apache_1.3.34_orig/src/support/snmp/set_ext_status	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/src/support/snmp/set_ext_status	2006-05-18 16:49:19.301762888 +0200
@@ -0,0 +1,50 @@
+#!/usr/local/bin/perl
+
+use SNMP 1.8;
+
+require "parameters.plib";
+
+
+if ($ARGV[0] =~ /^ON$/) {
+	$newvalue = 1;
+} elsif ($ARGV[0] =~ /^OFF$/) {
+	$newvalue = 2;
+} else {
+	print "Not supported status value\n";
+	print "Usage: set_ext_status (ON|OFF)\n";
+	exit;
+}
+
+
+$var = new SNMP::Varbind(['1.3.6.1.4.1.785.6.1.1', '0', $newvalue, INTEGER]);
+
+$session = new SNMP::Session ( DestHost => $host,
+                                Community => $community,
+                                RemotePort => $port );
+
+print "Could not open session"
+                if !defined($session);
+
+$resp = $session->set($var);
+
+print "SNMP-request error\n"
+                if !defined($resp);
+
+$value = $var->[$SNMP::Varbind::val_f];
+
+if ($session->{ErrorInd} != 0) {
+	printf "Return error status '%d' means '%s' at index '%d'\n",
+			$session->{ErrorNum}, 
+			$session->{ErrorStr}, 
+			$session->{ErrorInd};
+} else {
+	if ($value == 1) {
+		print "The Extended Scoreboard Status 'ON'\n";
+	} elsif ($value == 2) {
+		print "The Extended Scoreboard Status 'OFF'\n";
+	} else {
+		print "Panic, should not be possible\n";
+	}
+}
+
+
diff -ru -ruN apache_1.3.34_orig/src/support/snmp/set_limit_servers apache_1.3.34/src/support/snmp/set_limit_servers
--- apache_1.3.34_orig/src/support/snmp/set_limit_servers	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/src/support/snmp/set_limit_servers	2006-05-18 16:49:19.301762888 +0200
@@ -0,0 +1,34 @@
+#!/usr/local/bin/perl
+
+if ($#ARGV != 0) {
+	die "Need value '$0 <#>'\n";
+}
+
+use SNMP 1.8;
+
+require "parameters.plib";
+
+$newvalue = $ARGV[0];
+
+$var = new SNMP::Varbind(['1.3.6.1.4.1.785.6.1.5', '0', $newvalue, INTEGER]);
+
+$session = new SNMP::Session ( DestHost => $host,
+                                Community => $community,
+                                RemotePort => $port );
+
+print "Could not open session"
+                if !defined($session);
+
+$resp = $session->set($var);
+
+if (!defined($resp)) {
+	die "SNMP-request error\n";
+}
+
+$value = $var->[$SNMP::Varbind::val_f];
+
+if ($session->{ErrorInd} != 0) {
+	printf "Return error status '%d' means '%s' at index '%d'\n", $session->{ErrorNum}, $session->{ErrorStr}, $session->{ErrorInd};
+} else {
+	print "The max servers is set to '$value'\n";
+}
diff -ru -ruN apache_1.3.34_orig/src/support/snmp/set_max_spare_servers apache_1.3.34/src/support/snmp/set_max_spare_servers
--- apache_1.3.34_orig/src/support/snmp/set_max_spare_servers	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/src/support/snmp/set_max_spare_servers	2006-05-18 16:49:19.302762736 +0200
@@ -0,0 +1,34 @@
+#!/usr/local/bin/perl
+
+if ($#ARGV != 0) {
+	die "Need value '$0 <#>'\n";
+}
+
+use SNMP 1.8;
+
+require "parameters.plib";
+
+$newvalue = $ARGV[0];
+
+$var = new SNMP::Varbind(['1.3.6.1.4.1.785.6.1.7', '0', $newvalue, INTEGER]);
+
+$session = new SNMP::Session ( DestHost => $host,
+                                Community => $community,
+                                RemotePort => $port );
+
+print "Could not open session"
+                if !defined($session);
+
+$resp = $session->set($var);
+
+if (!defined($resp)) {
+	die "SNMP-request error\n";
+}
+
+$value = $var->[$SNMP::Varbind::val_f];
+
+if ($session->{ErrorInd} != 0) {
+	printf "Return error status '%d' means '%s' at index '%d'\n", $session->{ErrorNum}, $session->{ErrorStr}, $session->{ErrorInd};
+} else {
+	print "The max spare servers is set to '$value'\n";
+}
diff -ru -ruN apache_1.3.34_orig/src/support/snmp/set_min_spare_servers apache_1.3.34/src/support/snmp/set_min_spare_servers
--- apache_1.3.34_orig/src/support/snmp/set_min_spare_servers	1970-01-01 01:00:00.000000000 +0100
+++ apache_1.3.34/src/support/snmp/set_min_spare_servers	2006-05-18 16:49:19.303762584 +0200
@@ -0,0 +1,34 @@
+#!/usr/local/bin/perl
+
+if ($#ARGV != 0) {
+	die "Need value '$0 <#>'\n";
+}
+
+use SNMP 1.8;
+
+require "parameters.plib";
+
+$newvalue = $ARGV[0];
+
+$var = new SNMP::Varbind(['1.3.6.1.4.1.785.6.1.6', '0', $newvalue, INTEGER]);
+
+$session = new SNMP::Session ( DestHost => $host,
+                                Community => $community,
+                                RemotePort => $port );
+
+print "Could not open session"
+                if !defined($session);
+
+$resp = $session->set($var);
+
+if (!defined($resp)) {
+	die "SNMP-request error\n";
+}
+
+$value = $var->[$SNMP::Varbind::val_f];
+
+if ($session->{ErrorInd} != 0) {
+	printf "Return error status '%d' means '%s' at index '%d'\n", $session->{ErrorNum}, $session->{ErrorStr}, $session->{ErrorInd};
+} else {
+	print "The min spare servers is set to '$value'\n";
+}
diff -ru -ru apache_1.3.36_orig/src/modules/snmp_agt/mod_snmp.c apache_1.3.36/src/modules/snmp_agt/mod_snmp.c
--- apache_1.3.36_orig/src/modules/snmp_agt/mod_snmp.c	2006-07-07 16:06:02.000000000 +0200
+++ apache_1.3.36/src/modules/snmp_agt/mod_snmp.c	2006-07-07 16:07:46.000000000 +0200
@@ -88,7 +88,7 @@
 
 pid_t			snmpagent_pid;
 int			snmp_port = SNMP_PORT;
-char*			snmp_addr = "0.0.0.0";
+char*			snmp_addr = "127.0.0.1";
 char			*snmp_temp_dir = SNMP_AGT_BUCKET_DEFAULT_DIR;
 int			snmp_module_debug_level = 0;
 
