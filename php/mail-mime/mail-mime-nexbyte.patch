--- mimeDecode.php	2006-04-25 14:30:52.816910304 +0200
+++ mimeDecode.php	2005-01-13 14:20:08.000000000 +0100
@@ -136,6 +115,14 @@
     var $_decode_headers;
 
     /**
+    * If invoked from a class, $this will be set. This has problematic
+    * connotations for calling decode() statically. Hence this variable
+    * is used to determine if we are indeed being called statically or
+    * via an object.
+    */
+    var $mailMimeDecode;
+
+    /**
      * Constructor.
      *
      * Sets up the object, initialise the variables, and splits and
@@ -153,6 +140,8 @@
         $this->_body           = $body;
         $this->_decode_bodies  = false;
         $this->_include_bodies = true;
+        
+        $this->mailMimeDecode  = true;
     }
 
     /**
@@ -174,28 +163,22 @@
      */
     function decode($params = null)
     {
-        // determine if this method has been called statically
-        $isStatic = !(isset($this) && get_class($this) == __CLASS__);
 
-        // Have we been called statically?
-	// If so, create an object and pass details to that.
-        if ($isStatic AND isset($params['input'])) {
+        // Have we been called statically? If so, create an object and pass details to that.
+        if (!isset($this->mailMimeDecode) AND isset($params['input'])) {
 
             $obj = new Mail_mimeDecode($params['input']);
             $structure = $obj->decode($params);
 
         // Called statically but no input
-        } elseif ($isStatic) {
+        } elseif (!isset($this->mailMimeDecode)) {
             return PEAR::raiseError('Called statically and no input given');
 
         // Called via an object
         } else {
-            $this->_include_bodies = isset($params['include_bodies']) ?
-	                             $params['include_bodies'] : false;
-            $this->_decode_bodies  = isset($params['decode_bodies']) ?
-	                             $params['decode_bodies']  : false;
-            $this->_decode_headers = isset($params['decode_headers']) ?
-	                             $params['decode_headers'] : false;
+            $this->_include_bodies = isset($params['include_bodies'])  ? $params['include_bodies']  : false;
+            $this->_decode_bodies  = isset($params['decode_bodies'])   ? $params['decode_bodies']   : false;
+            $this->_decode_headers = isset($params['decode_headers'])  ? $params['decode_headers']  : false;
 
             $structure = $this->_decode($this->_header, $this->_body);
             if ($structure === false) {
@@ -219,7 +202,6 @@
     function _decode($headers, $body, $default_ctype = 'text/plain')
     {
         $return = new stdClass;
-        $return->headers = array();
         $headers = $this->_parseHeaders($headers);
 
         foreach ($headers as $value) {
@@ -255,7 +237,7 @@
                     }
                     break;
 
-                case 'content-disposition':
+                case 'content-disposition';
                     $content_disposition = $this->_parseHeaderValue($headers[$key]['value']);
                     $return->disposition   = $content_disposition['value'];
                     if (isset($content_disposition['other'])) {
@@ -271,6 +253,7 @@
             }
         }
 
+
         if (isset($content_type)) {
             switch (strtolower($content_type['value'])) {
                 case 'text/plain':
@@ -309,9 +292,7 @@
 
                 case 'message/rfc822':
                     $obj = &new Mail_mimeDecode($body);
-                    $return->parts[] = $obj->decode(array('include_bodies' => $this->_include_bodies,
-					                                      'decode_bodies'  => $this->_decode_bodies,
-														  'decode_headers' => $this->_decode_headers));
+                    $return->parts[] = $obj->decode(array('include_bodies' => $this->_include_bodies));
                     unset($obj);
                     break;
 
@@ -449,22 +430,13 @@
             if (strlen($input) > 0) {
 
                 // This splits on a semi-colon, if there's no preceeding backslash
-                // Now works with quoted values; had to glue the \; breaks in PHP
-                // the regex is already bordering on incomprehensible
-                $splitRegex = '/([^;\'"]*[\'"]([^\'"]*([^\'"]*)*)[\'"][^;\'"]*|([^;]+))(;|$)/';
-                preg_match_all($splitRegex, $input, $matches);
-                $parameters = array();
-                for ($i=0; $i<count($matches[0]); $i++) {
-                    $param = $matches[0][$i];
-                    while (substr($param, -2) == '\;') {
-                        $param .= $matches[0][++$i];
-                    }
-                    $parameters[] = $param;
-                }
+                // Can't handle if it's in double quotes however. (Of course anyone
+                // sending that needs a good slap).
+                $parameters = preg_split('/\s*(?<!\\\\);\s*/i', $input);
 
                 for ($i = 0; $i < count($parameters); $i++) {
-                    $param_name  = trim(substr($parameters[$i], 0, $pos = strpos($parameters[$i], '=')), "'\";\t\\ ");
-                    $param_value = trim(str_replace('\;', ';', substr($parameters[$i], $pos + 1)), "'\";\t\\ ");
+                    $param_name  = substr($parameters[$i], 0, $pos = strpos($parameters[$i], '='));
+                    $param_value = substr($parameters[$i], $pos + 1);
                     if ($param_value[0] == '"') {
                         $param_value = substr($param_value, 1, -1);
                     }
@@ -489,18 +461,9 @@
      */
     function _boundarySplit($input, $boundary)
     {
-        $parts = array();
-
-        $bs_possible = substr($boundary, 2, -2);
-        $bs_check = '\"' . $bs_possible . '\"';
+        $tmp = explode('--'.$boundary, $input);
 
-        if ($boundary == $bs_check) {
-            $boundary = $bs_possible;
-        }
-
-        $tmp = explode('--' . $boundary, $input);
-
-        for ($i = 1; $i < count($tmp) - 1; $i++) {
+        for ($i=1; $i<count($tmp)-1; $i++) {
             $parts[] = $tmp[$i];
         }
 
@@ -560,7 +523,7 @@
      */
     function _decodeBody($input, $encoding = '7bit')
     {
-        switch (strtolower($encoding)) {
+        switch ($encoding) {
             case '7bit':
                 return $input;
                 break;
@@ -592,7 +555,7 @@
         $input = preg_replace("/=\r?\n/", '', $input);
 
         // Replace encoded characters
-		$input = preg_replace('/=([a-f0-9]{2})/ie', "chr(hexdec('\\1'))", $input);
+        $input = preg_replace('/=([a-f0-9]{2})/ie', "chr(hexdec('\\1'))", $input);
 
         return $input;
     }
@@ -718,6 +681,14 @@
         return array($to,$header,$this->_body);
     } 
 
+
+
+
+
+
+
+
+
     /**
      * Returns a xml copy of the output of
      * Mail_mimeDecode::decode. Pass the output in as the
diff -ru work/pkg/usr/local/lib/php/Mail/mime.php /usr/local/lib/php/Mail/mime.php
--- mime.php	2006-04-25 14:30:52.816910304 +0200
+++ mime.php	2005-09-30 13:30:57.000000000 +0200
@@ -35,87 +33,90 @@
 // |         Tomas V.V.Cox <cox@idecnet.com> (port to PEAR)                |
 // +-----------------------------------------------------------------------+
 //
-// $Id: mail-mime-nexbyte.patch,v 1.1 2006/05/16 18:02:40 roman Exp $
+// $Id: mail-mime-nexbyte.patch,v 1.1 2006/05/16 18:02:40 roman Exp $
 
-require_once('PEAR.php');
-require_once('Mail/mimePart.php');
+require_once 'PEAR.php';
+require_once 'Mail/mimePart.php';
 
 /**
- * Mime mail composer class. Can handle: text and html bodies, embedded html
- * images and attachments.
- * Documentation and examples of this class are avaible here:
- * http://pear.php.net/manual/
- *
- * @notes This class is based on HTML Mime Mail class from
- *   Richard Heyes <richard@phpguru.org> which was based also
- *   in the mime_mail.class by Tobias Ratschiller <tobias@dnet.it> and
- *   Sascha Schumann <sascha@schumann.cx>
- *
- * @author   Richard Heyes <richard.heyes@heyes-computing.net>
- * @author   Tomas V.V.Cox <cox@idecnet.com>
- * @package  Mail
- * @access   public
- */
+* Mime mail composer class. Can handle: text and html bodies, embedded html
+* images and attachments.
+* Documentation and examples of this class are avaible here:
+* http://pear.php.net/manual/
+*
+* @notes This class is based on HTML Mime Mail class from
+*   Richard Heyes <richard@phpguru.org> which was based also
+*   in the mime_mail.class by Tobias Ratschiller <tobias@dnet.it> and
+*   Sascha Schumann <sascha@schumann.cx>.
+* 
+* @notes Method _encodeHeaders() modified by t.bruederli@nexbyte.com
+*
+* @author Richard Heyes <richard.heyes@heyes-computing.net>
+* @author Tomas V.V.Cox <cox@idecnet.com>
+* @package Mail
+* @access public
+*/
 class Mail_mime
 {
     /**
-     * Contains the plain text part of the email
-     * @var string
-     */
+    * Contains the plain text part of the email
+    * @var string
+    */
     var $_txtbody;
     /**
-     * Contains the html part of the email
-     * @var string
-     */
+    * Contains the html part of the email
+    * @var string
+    */
     var $_htmlbody;
     /**
-     * contains the mime encoded text
-     * @var string
-     */
+    * contains the mime encoded text
+    * @var string
+    */
     var $_mime;
     /**
-     * contains the multipart content
-     * @var string
-     */
+    * contains the multipart content
+    * @var string
+    */
     var $_multipart;
     /**
-     * list of the attached images
-     * @var array
-     */
+    * list of the attached images
+    * @var array
+    */
     var $_html_images = array();
     /**
-     * list of the attachements
-     * @var array
-     */
+    * list of the attachements
+    * @var array
+    */
     var $_parts = array();
     /**
-     * Build parameters
-     * @var array
-     */
+    * Build parameters
+    * @var array
+    */
     var $_build_params = array();
     /**
-     * Headers for the mail
-     * @var array
-     */
+    * Headers for the mail
+    * @var array
+    */
     var $_headers = array();
-    /**
-     * End Of Line sequence (for serialize)
-     * @var string
-     */
-    var $_eol;
 
 
-    /**
-     * Constructor function
-     *
-     * @access public
-     */
+    /*
+    * Constructor function
+    *
+    * @access public
+    */
     function Mail_mime($crlf = "\r\n")
     {
-        $this->_setEOL($crlf);
+        if (!defined('MAIL_MIME_CRLF')) {
+            define('MAIL_MIME_CRLF', $crlf, true);
+        }
+
+        $this->_boundary = '=_' . md5(uniqid(time()));
+
         $this->_build_params = array(
                                      'text_encoding' => '7bit',
                                      'html_encoding' => 'quoted-printable',
+                                     'head_encoding' => 'quoted-printable',
                                      '7bit_wrap'     => 998,
                                      'html_charset'  => 'ISO-8859-1',
                                      'text_charset'  => 'ISO-8859-1',
@@ -123,32 +124,21 @@
                                     );
     }
 
-    /**
-     * Wakeup (unserialize) - re-sets EOL constant
-     *
-     * @access private
-     */
-    function __wakeup()
-    {
-        $this->_setEOL($this->_eol);
-    }
-
-    /**
-     * Accessor function to set the body text. Body text is used if
-     * it's not an html mail being sent or else is used to fill the
-     * text/plain part that emails clients who don't support
-     * html should show.
-     *
-     * @param  string  $data   Either a string or
-     *                         the file name with the contents
-     * @param  bool    $isfile If true the first param should be treated
-     *                         as a file name, else as a string (default)
-     * @param  bool    $append If true the text or file is appended to
-     *                         the existing body, else the old body is
-     *                         overwritten
-     * @return mixed   true on success or PEAR_Error object
-     * @access public
-     */
+    /*
+    * Accessor function to set the body text. Body text is used if
+    * it's not an html mail being sent or else is used to fill the
+    * text/plain part that emails clients who don't support
+    * html should show.
+    *
+    * @param string $data Either a string or the file name with the
+    *        contents
+    * @param bool $isfile If true the first param should be trated
+    *        as a file name, else as a string (default)
+    * @param bool If true the text or file is appended to the
+    *        existing body, else the old body is overwritten
+    * @return mixed true on success or PEAR_Error object
+    * @access public
+    */
     function setTXTBody($data, $isfile = false, $append = false)
     {
         if (!$isfile) {
@@ -163,24 +153,24 @@
                 return $cont;
             }
             if (!$append) {
-                $this->_txtbody = $cont;
-            } else {
-                $this->_txtbody .= $cont;
-            }
+                 $this->_txtbody = $cont;
+             } else {
+                 $this->_txtbody .= $cont;
+             }
         }
         return true;
     }
 
-    /**
-     * Adds a html part to the mail
-     *
-     * @param  string  $data   Either a string or the file name with the
-     *                         contents
-     * @param  bool    $isfile If true the first param should be treated
-     *                         as a file name, else as a string (default)
-     * @return mixed   true on success or PEAR_Error object
-     * @access public
-     */
+    /*
+    * Adds a html part to the mail
+    *
+    * @param string $data Either a string or the file name with the
+    *        contents
+    * @param bool $isfile If true the first param should be trated
+    *        as a file name, else as a string (default)
+    * @return mixed true on success or PEAR_Error object
+    * @access public
+    */
     function setHTMLBody($data, $isfile = false)
     {
         if (!$isfile) {
@@ -196,28 +186,20 @@
         return true;
     }
 
-    /**
-     * Adds an image to the list of embedded images.
-     *
-     * @param  string  $file       The image file name OR image data itself
-     * @param  string  $c_type     The content type
-     * @param  string  $name       The filename of the image.
-     *                             Only use if $file is the image data
-     * @param  bool    $isfilename Whether $file is a filename or not
-     *                             Defaults to true
-     * @return mixed   true on success or PEAR_Error object
-     * @access public
-     */
-    function addHTMLImage($file, $c_type='application/octet-stream',
-                          $name = '', $isfilename = true)
+    /*
+    * Adds an image to the list of embedded images.
+    *
+    * @param string $file The image file name OR image data itself
+    * @param string $c_type The content type
+    * @param string $name The filename of the image. Only use if $file is the image data
+    * @param bool $isfilename Whether $file is a filename or not. Defaults to true
+    * @return mixed true on success or PEAR_Error object
+    * @access public
+    */
+    function addHTMLImage($file, $c_type='application/octet-stream', $name = '', $isfilename = true)
     {
-        $filedata = ($isfilename === true) ? $this->_file2str($file)
-                                           : $file;
-        if ($isfilename === true) {
-            $filename = ($name == '' ? basename($file) : basename($name));
-        } else {
-            $filename = basename($name);
-        }
+        $filedata = ($isfilename === true) ? $this->_file2str($file) : $file;
+        $filename = ($isfilename === true) ? basename($file) : basename($name);
         if (PEAR::isError($filedata)) {
             return $filedata;
         }
@@ -230,25 +212,19 @@
         return true;
     }
 
-    /**
-     * Adds a file to the list of attachments.
-     *
-     * @param  string  $file       The file name of the file to attach
-     *                             OR the file data itself
-     * @param  string  $c_type     The content type
-     * @param  string  $name       The filename of the attachment
-     *                             Only use if $file is the file data
-     * @param  bool    $isFilename Whether $file is a filename or not
-     *                             Defaults to true
-     * @return mixed true on success or PEAR_Error object
-     * @access public
-     */
-    function addAttachment($file, $c_type = 'application/octet-stream',
-                           $name = '', $isfilename = true,
-                           $encoding = 'base64')
+    /*
+    * Adds a file to the list of attachments.
+    *
+    * @param string $file The file name of the file to attach OR the file data itself
+    * @param string $c_type The content type
+    * @param string $name The filename of the attachment. Only use if $file is the file data
+    * @param bool $isFilename Whether $file is a filename or not. Defaults to true
+    * @return mixed true on success or PEAR_Error object
+    * @access public
+    */
+    function addAttachment($file, $c_type='application/octet-stream', $name = '', $isfilename = true, $encoding = 'base64')
     {
-        $filedata = ($isfilename === true) ? $this->_file2str($file)
-                                           : $file;
+        $filedata = ($isfilename === true) ? $this->_file2str($file) : $file;
         if ($isfilename === true) {
             // Force the name the user supplied, otherwise use $file
             $filename = (!empty($name)) ? $name : $file;
@@ -256,9 +232,7 @@
             $filename = $name;
         }
         if (empty($filename)) {
-            return PEAR::raiseError(
-              'The supplied filename for the attachment can\'t be empty'
-            );
+            return PEAR::raiseError('The supplied filename for the attachment can\'t be empty');
         }
         $filename = basename($filename);
         if (PEAR::isError($filedata)) {
@@ -274,14 +248,13 @@
         return true;
     }
 
-    /**
-     * Get the contents of the given file name as string
-     *
-     * @param  string  $file_name  path of file to process
-     * @return string  contents of $file_name
-     * @access private
-     */
-    function &_file2str($file_name)
+    /*
+    * Returns the contents of the given file name as string
+    * @param string $file_name
+    * @return string
+    * @acces private
+    */
+    function & _file2str($file_name)
     {
         if (!is_readable($file_name)) {
             return PEAR::raiseError('File is not readable ' . $file_name);
@@ -289,28 +262,23 @@
         if (!$fd = fopen($file_name, 'rb')) {
             return PEAR::raiseError('Could not open ' . $file_name);
         }
-        $filesize = filesize($file_name);
-        if ($filesize == 0){
-            $cont =  "";
-        }else{
-            $cont = fread($fd, $filesize);
-        }
+        $cont = fread($fd, filesize($file_name));
         fclose($fd);
         return $cont;
     }
 
-    /**
-     * Adds a text subpart to the mimePart object and
-     * returns it during the build process.
-     *
-     * @param mixed    The object to add the part to, or
-     *                 null if a new object is to be created.
-     * @param string   The text to add.
-     * @return object  The text mimePart object
-     * @access private
-     */
-    function &_addTextPart(&$obj, $text)
-    {
+    /*
+    * Adds a text subpart to the mimePart object and
+    * returns it during the build process.
+    *
+    * @param mixed    The object to add the part to, or
+    *                 null if a new object is to be created.
+    * @param string   The text to add.
+    * @return object  The text mimePart object
+    * @access private
+    */
+    function &_addTextPart(&$obj, $text){
+
         $params['content_type'] = 'text/plain';
         $params['encoding']     = $this->_build_params['text_encoding'];
         $params['charset']      = $this->_build_params['text_charset'];
@@ -321,17 +289,17 @@
         }
     }
 
-    /**
-     * Adds a html subpart to the mimePart object and
-     * returns it during the build process.
-     *
-     * @param  mixed   The object to add the part to, or
-     *                 null if a new object is to be created.
-     * @return object  The html mimePart object
-     * @access private
-     */
-    function &_addHtmlPart(&$obj)
-    {
+    /*
+    * Adds a html subpart to the mimePart object and
+    * returns it during the build process.
+    *
+    * @param mixed    The object to add the part to, or
+    *                 null if a new object is to be created.
+    * @return object  The html mimePart object
+    * @access private
+    */
+    function &_addHtmlPart(&$obj){
+
         $params['content_type'] = 'text/html';
         $params['encoding']     = $this->_build_params['html_encoding'];
         $params['charset']      = $this->_build_params['html_charset'];
@@ -342,32 +310,32 @@
         }
     }
 
-    /**
-     * Creates a new mimePart object, using multipart/mixed as
-     * the initial content-type and returns it during the
-     * build process.
-     *
-     * @return object  The multipart/mixed mimePart object
-     * @access private
-     */
-    function &_addMixedPart()
-    {
+    /*
+    * Creates a new mimePart object, using multipart/mixed as
+    * the initial content-type and returns it during the
+    * build process.
+    *
+    * @return object  The multipart/mixed mimePart object
+    * @access private
+    */
+    function &_addMixedPart(){
+
         $params['content_type'] = 'multipart/mixed';
         return new Mail_mimePart('', $params);
     }
 
-    /**
-     * Adds a multipart/alternative part to a mimePart
-     * object (or creates one), and returns it during
-     * the build process.
-     *
-     * @param  mixed   The object to add the part to, or
-     *                 null if a new object is to be created.
-     * @return object  The multipart/mixed mimePart object
-     * @access private
-     */
-    function &_addAlternativePart(&$obj)
-    {
+    /*
+    * Adds a multipart/alternative part to a mimePart
+    * object, (or creates one), and returns it  during
+    * the build process.
+    *
+    * @param mixed    The object to add the part to, or
+    *                 null if a new object is to be created.
+    * @return object  The multipart/mixed mimePart object
+    * @access private
+    */
+    function &_addAlternativePart(&$obj){
+
         $params['content_type'] = 'multipart/alternative';
         if (is_object($obj)) {
             return $obj->addSubpart('', $params);
@@ -376,18 +344,18 @@
         }
     }
 
-    /**
-     * Adds a multipart/related part to a mimePart
-     * object (or creates one), and returns it during
-     * the build process.
-     *
-     * @param mixed    The object to add the part to, or
-     *                 null if a new object is to be created
-     * @return object  The multipart/mixed mimePart object
-     * @access private
-     */
-    function &_addRelatedPart(&$obj)
-    {
+    /*
+    * Adds a multipart/related part to a mimePart
+    * object, (or creates one), and returns it  during
+    * the build process.
+    *
+    * @param mixed    The object to add the part to, or
+    *                 null if a new object is to be created.
+    * @return object  The multipart/mixed mimePart object
+    * @access private
+    */
+    function &_addRelatedPart(&$obj){
+
         $params['content_type'] = 'multipart/related';
         if (is_object($obj)) {
             return $obj->addSubpart('', $params);
@@ -396,17 +364,17 @@
         }
     }
 
-    /**
-     * Adds an html image subpart to a mimePart object
-     * and returns it during the build process.
-     *
-     * @param  object  The mimePart to add the image to
-     * @param  array   The image information
-     * @return object  The image mimePart object
-     * @access private
-     */
-    function &_addHtmlImagePart(&$obj, $value)
-    {
+    /*
+    * Adds an html image subpart to a mimePart object
+    * and returns it during the build process.
+    *
+    * @param  object  The mimePart to add the image to
+    * @param  array   The image information
+    * @return object  The image mimePart object
+    * @access private
+    */
+    function &_addHtmlImagePart(&$obj, $value){
+
         $params['content_type'] = $value['c_type'];
         $params['encoding']     = 'base64';
         $params['disposition']  = 'inline';
@@ -415,17 +383,17 @@
         $obj->addSubpart($value['body'], $params);
     }
 
-    /**
-     * Adds an attachment subpart to a mimePart object
-     * and returns it during the build process.
-     *
-     * @param  object  The mimePart to add the image to
-     * @param  array   The attachment information
-     * @return object  The image mimePart object
-     * @access private
-     */
-    function &_addAttachmentPart(&$obj, $value)
-    {
+    /*
+    * Adds an attachment subpart to a mimePart object
+    * and returns it during the build process.
+    *
+    * @param  object  The mimePart to add the image to
+    * @param  array   The attachment information
+    * @return object  The image mimePart object
+    * @access private
+    */
+    function &_addAttachmentPart(&$obj, $value){
+
         $params['content_type'] = $value['c_type'];
         $params['encoding']     = $value['encoding'];
         $params['disposition']  = 'attachment';
@@ -433,28 +401,28 @@
         $obj->addSubpart($value['body'], $params);
     }
 
-    /**
-     * Builds the multipart message from the list ($this->_parts) and
-     * returns the mime content.
-     *
-     * @param  array  Build parameters that change the way the email
-     *                is built. Should be associative. Can contain:
-     *                text_encoding  -  What encoding to use for plain text
-     *                                  Default is 7bit
-     *                html_encoding  -  What encoding to use for html
-     *                                  Default is quoted-printable
-     *                7bit_wrap      -  Number of characters before text is
-     *                                  wrapped in 7bit encoding
-     *                                  Default is 998
-     *                html_charset   -  The character set to use for html.
-     *                                  Default is iso-8859-1
-     *                text_charset   -  The character set to use for text.
-     *                                  Default is iso-8859-1
-     *                head_charset   -  The character set to use for headers.
-     *                                  Default is iso-8859-1
-     * @return string The mime content
-     * @access public
-     */
+    /*
+    * Builds the multipart message from the list ($this->_parts) and
+    * returns the mime content.
+    *
+    * @param  array  Build parameters that change the way the email
+    *                is built. Should be associative. Can contain:
+    *                text_encoding  -  What encoding to use for plain text
+    *                                  Default is 7bit
+    *                html_encoding  -  What encoding to use for html
+    *                                  Default is quoted-printable
+    *                7bit_wrap      -  Number of characters before text is
+    *                                  wrapped in 7bit encoding
+    *                                  Default is 998
+    *                html_charset   -  The character set to use for html.
+    *                                  Default is iso-8859-1
+    *                text_charset   -  The character set to use for text.
+    *                                  Default is iso-8859-1
+    *                head_charset   -  The character set to use for headers.
+    *                                  Default is iso-8859-1
+    * @return string The mime content
+    * @access public
+    */
     function &get($build_params = null)
     {
         if (isset($build_params)) {
@@ -465,121 +433,118 @@
 
         if (!empty($this->_html_images) AND isset($this->_htmlbody)) {
             foreach ($this->_html_images as $value) {
-                $regex = '#(\s)((?i)src|background|href(?-i))\s*=\s*(["\']?)' . preg_quote($value['name'], '#') .
-                         '\3#';
-                $rep = '\1\2=\3cid:' . $value['cid'] .'\3';
-                $this->_htmlbody = preg_replace($regex, $rep,
-                                       $this->_htmlbody
-                                   );
+                $this->_htmlbody = str_replace($value['name'], 'cid:'.$value['cid'], $this->_htmlbody);
             }
         }
 
         $null        = null;
-        $attachments = !empty($this->_parts)                ? true : false;
-        $html_images = !empty($this->_html_images)          ? true : false;
-        $html        = !empty($this->_htmlbody)             ? true : false;
-        $text        = (!$html AND !empty($this->_txtbody)) ? true : false;
-
-        switch (true) {
-        case $text AND !$attachments:
-            $message =& $this->_addTextPart($null, $this->_txtbody);
-            break;
-
-        case !$text AND !$html AND $attachments:
-            $message =& $this->_addMixedPart();
-            for ($i = 0; $i < count($this->_parts); $i++) {
-                $this->_addAttachmentPart($message, $this->_parts[$i]);
-            }
-            break;
-
-        case $text AND $attachments:
-            $message =& $this->_addMixedPart();
-            $this->_addTextPart($message, $this->_txtbody);
-            for ($i = 0; $i < count($this->_parts); $i++) {
-                $this->_addAttachmentPart($message, $this->_parts[$i]);
-            }
-            break;
+        $attachments = !empty($this->_parts)                ? TRUE : FALSE;
+        $html_images = !empty($this->_html_images)          ? TRUE : FALSE;
+        $html        = !empty($this->_htmlbody)             ? TRUE : FALSE;
+        $text        = (!$html AND !empty($this->_txtbody)) ? TRUE : FALSE;
+
+        switch (TRUE) {
+            case $text AND !$attachments:
+                $message =& $this->_addTextPart($null, $this->_txtbody);
+                break;
+
+            case !$text AND !$html AND $attachments:
+                $message =& $this->_addMixedPart();
+
+                for ($i = 0; $i < count($this->_parts); $i++) {
+                    $this->_addAttachmentPart($message, $this->_parts[$i]);
+                }
+                break;
 
-        case $html AND !$attachments AND !$html_images:
-            if (isset($this->_txtbody)) {
-                $message =& $this->_addAlternativePart($null);
+            case $text AND $attachments:
+                $message =& $this->_addMixedPart();
                 $this->_addTextPart($message, $this->_txtbody);
-                $this->_addHtmlPart($message);
-            } else {
-                $message =& $this->_addHtmlPart($null);
-            }
-            break;
-
-        case $html AND !$attachments AND $html_images:
-            if (isset($this->_txtbody)) {
-                $message =& $this->_addAlternativePart($null);
-                $this->_addTextPart($message, $this->_txtbody);
-                $related =& $this->_addRelatedPart($message);
-            } else {
-                $message =& $this->_addRelatedPart($null);
-                $related =& $message;
-            }
-            $this->_addHtmlPart($related);
-            for ($i = 0; $i < count($this->_html_images); $i++) {
-                $this->_addHtmlImagePart($related, $this->_html_images[$i]);
-            }
-            break;
-
-        case $html AND $attachments AND !$html_images:
-            $message =& $this->_addMixedPart();
-            if (isset($this->_txtbody)) {
-                $alt =& $this->_addAlternativePart($message);
-                $this->_addTextPart($alt, $this->_txtbody);
-                $this->_addHtmlPart($alt);
-            } else {
-                $this->_addHtmlPart($message);
-            }
-            for ($i = 0; $i < count($this->_parts); $i++) {
-                $this->_addAttachmentPart($message, $this->_parts[$i]);
-            }
-            break;
 
-        case $html AND $attachments AND $html_images:
-            $message =& $this->_addMixedPart();
-            if (isset($this->_txtbody)) {
-                $alt =& $this->_addAlternativePart($message);
-                $this->_addTextPart($alt, $this->_txtbody);
-                $rel =& $this->_addRelatedPart($alt);
-            } else {
-                $rel =& $this->_addRelatedPart($message);
-            }
-            $this->_addHtmlPart($rel);
-            for ($i = 0; $i < count($this->_html_images); $i++) {
-                $this->_addHtmlImagePart($rel, $this->_html_images[$i]);
-            }
-            for ($i = 0; $i < count($this->_parts); $i++) {
-                $this->_addAttachmentPart($message, $this->_parts[$i]);
-            }
-            break;
+                for ($i = 0; $i < count($this->_parts); $i++) {
+                    $this->_addAttachmentPart($message, $this->_parts[$i]);
+                }
+                break;
+
+            case $html AND !$attachments AND !$html_images:
+                if (isset($this->_txtbody)) {
+                    $message =& $this->_addAlternativePart($null);
+                       $this->_addTextPart($message, $this->_txtbody);
+                    $this->_addHtmlPart($message);
+
+                } else {
+                    $message =& $this->_addHtmlPart($null);
+                }
+                break;
+
+            case $html AND !$attachments AND $html_images:
+                if (isset($this->_txtbody)) {
+                    $message =& $this->_addAlternativePart($null);
+                    $this->_addTextPart($message, $this->_txtbody);
+                    $related =& $this->_addRelatedPart($message);
+                } else {
+                    $message =& $this->_addRelatedPart($null);
+                    $related =& $message;
+                }
+                $this->_addHtmlPart($related);
+                for ($i = 0; $i < count($this->_html_images); $i++) {
+                    $this->_addHtmlImagePart($related, $this->_html_images[$i]);
+                }
+                break;
+
+            case $html AND $attachments AND !$html_images:
+                $message =& $this->_addMixedPart();
+                if (isset($this->_txtbody)) {
+                    $alt =& $this->_addAlternativePart($message);
+                    $this->_addTextPart($alt, $this->_txtbody);
+                    $this->_addHtmlPart($alt);
+                } else {
+                    $this->_addHtmlPart($message);
+                }
+                for ($i = 0; $i < count($this->_parts); $i++) {
+                    $this->_addAttachmentPart($message, $this->_parts[$i]);
+                }
+                break;
+
+            case $html AND $attachments AND $html_images:
+                $message =& $this->_addMixedPart();
+                if (isset($this->_txtbody)) {
+                    $alt =& $this->_addAlternativePart($message);
+                    $this->_addTextPart($alt, $this->_txtbody);
+                    $rel =& $this->_addRelatedPart($alt);
+                } else {
+                    $rel =& $this->_addRelatedPart($message);
+                }
+                $this->_addHtmlPart($rel);
+                for ($i = 0; $i < count($this->_html_images); $i++) {
+                    $this->_addHtmlImagePart($rel, $this->_html_images[$i]);
+                }
+                for ($i = 0; $i < count($this->_parts); $i++) {
+                    $this->_addAttachmentPart($message, $this->_parts[$i]);
+                }
+                break;
 
         }
 
         if (isset($message)) {
             $output = $message->encode();
-            $this->_headers = array_merge($this->_headers,
-                                          $output['headers']);
+            $this->_headers = array_merge($this->_headers, $output['headers']);
+
             return $output['body'];
 
         } else {
-            return false;
+            return FALSE;
         }
     }
 
-    /**
-     * Returns an array with the headers needed to prepend to the email
-     * (MIME-Version and Content-Type). Format of argument is:
-     * $array['header-name'] = 'header-value';
-     *
-     * @param  array $xtra_headers Assoc array with any extra headers.
-     *                             Optional.
-     * @return array Assoc array with the mime headers
-     * @access public
-     */
+    /*
+    * Returns an array with the headers needed to prepend to the email
+    * (MIME-Version and Content-Type). Format of argument is:
+    * $array['header-name'] = 'header-value';
+    *
+    * @param  array $xtra_headers Assoc array with any extra headers. Optional.
+    * @return array Assoc array with the mime headers
+    * @access public
+    */
     function &headers($xtra_headers = null)
     {
         // Content-Type header should already be present,
@@ -594,14 +559,13 @@
     }
 
     /**
-     * Get the text version of the headers
-     * (usefull if you want to use the PHP mail() function)
-     *
-     * @param  array   $xtra_headers Assoc array with any extra headers.
-     *                               Optional.
-     * @return string  Plain text headers
-     * @access public
-     */
+    * Get the text version of the headers
+    * (usefull if you want to use the PHP mail() function)
+    *
+    * @param  array $xtra_headers Assoc array with any extra headers. Optional.
+    * @return string Plain text headers
+    * @access public
+    */
     function txtHeaders($xtra_headers = null)
     {
         $headers = $this->headers($xtra_headers);
@@ -613,34 +577,34 @@
     }
 
     /**
-     * Sets the Subject header
-     *
-     * @param  string $subject String to set the subject to
-     * access  public
-     */
+    * Sets the Subject header
+    * 
+    * @param  string $subject String to set the subject to
+    * access  public
+    */
     function setSubject($subject)
     {
         $this->_headers['Subject'] = $subject;
     }
 
     /**
-     * Set an email to the From (the sender) header
-     *
-     * @param  string $email The email direction to add
-     * @access public
-     */
+    * Set an email to the From (the sender) header
+    *
+    * @param string $email The email direction to add
+    * @access public
+    */
     function setFrom($email)
     {
         $this->_headers['From'] = $email;
     }
 
     /**
-     * Add an email to the Cc (carbon copy) header
-     * (multiple calls to this method are allowed)
-     *
-     * @param  string $email The email direction to add
-     * @access public
-     */
+    * Add an email to the Cc (carbon copy) header
+    * (multiple calls to this method is allowed)
+    *
+    * @param string $email The email direction to add
+    * @access public
+    */
     function addCc($email)
     {
         if (isset($this->_headers['Cc'])) {
@@ -651,12 +615,12 @@
     }
 
     /**
-     * Add an email to the Bcc (blank carbon copy) header
-     * (multiple calls to this method are allowed)
-     *
-     * @param  string $email The email direction to add
-     * @access public
-     */
+    * Add an email to the Bcc (blank carbon copy) header
+    * (multiple calls to this method is allowed)
+    *
+    * @param string $email The email direction to add
+    * @access public
+    */
     function addBcc($email)
     {
         if (isset($this->_headers['Bcc'])) {
@@ -665,49 +629,79 @@
             $this->_headers['Bcc'] = $email;
         }
     }
+    
 
     /**
-     * Encodes a header as per RFC2047
-     *
-     * @param  string  $input The header data to encode
-     * @return string  Encoded data
-     * @access private
-     */
+    * Encodes a header as per RFC2047
+    * Written by ed@avi.ru and nexbyte.com
+    *
+    * @param  string  $input The header data to encode
+    * @return string         Encoded data
+    * @access private
+    */
     function _encodeHeaders($input)
     {
+    foreach ($input as $hdr_name => $hdr_value) {
+        preg_match_all('/([\w\-]*[\x80-\xFF]+[\w\-]*(\s+[\w\-]*[\x80-\xFF]+[\w\-]*)*)\s*/', $hdr_value, $matches);
+        foreach ($matches[1] as $value) {
+		        switch ($head_encoding = $this->_build_params['head_encoding']) {
+                case 'base64':
+                  $symbol = 'B';
+                  $replacement = base64_encode($value);
+                  break;
+
+            default:
+                if ($head_encoding != 'quoted-printable') {
+                    PEAR::raiseError('Invalid header encoding specified; using `quoted-printable` instead',
+                                     NULL,
+                                     PEAR_ERROR_TRIGGER,
+                                     E_USER_WARNING);
+                }
+
+                $symbol = 'Q';
+                $replacement = preg_replace('/([\x80-\xFF\s_=\?])/e', '"=" . strtoupper(dechex(ord("\1")))', $value);
+            }
+            $hdr_value = str_replace($value, '=?' . $this->_build_params['head_charset'] . '?' . $symbol . '?' . $replacement . '?=', $hdr_value);
+        }
+
+        // prevents from mail injection 13.09.2005/pb
+        $hdr_value = preg_replace('/[\r\n]+/', ' ', $hdr_value);
+        $input[$hdr_name] = $hdr_value;
+    }
+    
+    return $input;
+    }
+
+
+    /**
+    * Encodes a header as per RFC2047
+    * Version by nexbyte.com
+    *
+    * @param  string  $input The header data to encode
+    * @return string         Encoded data
+    * @access private
+    *
+    function _encodeHeaders($input)
+    {
+    $enc_prefix = '=?' . $this->_build_params['head_charset'] . '?Q?';
         foreach ($input as $hdr_name => $hdr_value) {
-            preg_match_all('/(\w*[\x80-\xFF]+\w*)/', $hdr_value, $matches);
-            foreach ($matches[1] as $value) {
-                $replacement = preg_replace('/([\x80-\xFF])/e',
-                                            '"=" .
-                                            strtoupper(dechex(ord("\1")))',
-                                            $value);
-                $hdr_value = str_replace($value, '=?' .
-                                         $this->_build_params['head_charset'] .
-                                         '?Q?' . $replacement . '?=',
-                                         $hdr_value);
+            if (preg_match('/(\w*[\x80-\xFF\?]+\w*)/', $hdr_value)) {
+                $enc_value = preg_replace('/([\x80-\xFF\x3F\x3D\x5F])/e', '"=".strtoupper(dechex(ord("\1")))', $hdr_value);
+                // check for <email address> in string
+                if (preg_match('/<[a-z0-9\-\.\+\_]+@[a-z0-9]([a-z0-9\-].?)*[a-z0-9]\\.[a-z]{2,5}>/i', $enc_value) && ($p = strrpos($enc_value, '<'))) {
+                    $hdr_value = $enc_prefix . substr($enc_value, 0, $p-1) . '?= ' . substr($enc_value, $p, strlen($enc_value)-$p);
+                } else {
+                    $hdr_value = $enc_prefix . $enc_value . '?=';
+                }
             }
+            // prevents from mail injection 13.09.2005/pb
+            $hdr_value = preg_replace('/[\r\n]+/', ' ', $hdr_value);
             $input[$hdr_name] = $hdr_value;
         }
 
         return $input;
     }
-
-    /**
-     * Set the object's end-of-line and define the constant if applicable
-     *
-     * @param string $eol End Of Line sequence
-     * @access private
-     */
-    function _setEOL($eol)
-    {
-        $this->_eol = $eol;
-        if (!defined('MAIL_MIME_CRLF')) {
-            define('MAIL_MIME_CRLF', $this->_eol, true);
-        }
-    }
-
-    
+    */
 
 } // End of class
 ?>
